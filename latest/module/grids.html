

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Grids &mdash; brille 0.5.3+master.7d04597 documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" type="text/css" />
  <link rel="stylesheet" href="../_static/katex-math.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"></script>
        <script src="../_static/katex_autorenderer.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Symmetry" href="symmetry.html" />
    <link rel="prev" title="Brillouin Zone" href="bz.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> brille
          

          
            
            <img src="../_static/brille.svg" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                0.5.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">User documents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../install_guide.html">Installation Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../motivation.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../memory_usage.html">Memory Use</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial.html">User Guide</a></li>
</ul>
<p class="caption"><span class="caption-text">API documents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../brille.html">Python module <code class="xref py py-mod docutils literal notranslate"><span class="pre">brille</span></code></a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../brille.html#documented-thus-far">Documented thus far:</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="lattice.html">Lattices</a></li>
<li class="toctree-l2"><a class="reference internal" href="debug.html">Debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="bz.html">Brillouin Zone</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Grids</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#regular-grids">Regular grids</a></li>
<li class="toctree-l3"><a class="reference internal" href="#triangulated-grids">Triangulated grids</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#simple">Simple</a></li>
<li class="toctree-l4"><a class="reference internal" href="#hierarchy">Hierarchy</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#hybrid-grids">Hybrid grids</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="symmetry.html">Symmetry</a></li>
<li class="toctree-l2"><a class="reference internal" href="everything.html">Remainder</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../plotting.html">Plotting utilities for <code class="docutils literal notranslate"><span class="pre">brille</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../doxygen.html">Doxygen documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../undoc_brille.html">pybind11 module <code class="xref py py-mod docutils literal notranslate"><span class="pre">brille._brille</span></code></a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">brille</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../brille.html">Python module <code class="xref py py-mod docutils literal notranslate"><span class="pre">brille</span></code></a> &raquo;</li>
        
      <li>Grids</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/module/grids.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="grids">
<h1>Grids<a class="headerlink" href="#grids" title="Permalink to this headline">¶</a></h1>
<p>There are likely myriad ways one could divide an <span class="math">\(N\)</span> dimensional
space but the two most basic building blocks are the parallel piped
(or its <span class="math">\(N\)</span> dimensional equivalent) and the <span class="math">\(N\)</span>-simplex.
An <span class="math">\(N\)</span>-simplex always requires <span class="math">\(N+1\)</span> points
where a parallel piped requires <span class="math">\(2^N\)</span>.</p>
<p>The parallel piped lends itself to a regular grid while arrangements of <cite>N</cite>-simplexs can be regular or irregular.
In two dimensions the parallel piped grid is a regular cartesian grid:</p>
<div class="figure">
<p><img src="../_images/tikz-9b49e5823c5b67fda7921ff5e39427254d27da8f.png" alt="\begin{tikzpicture}[
dot/.style = {radius=0.04}, dotfill/.style={color=black, fill},
]
\draw[step=1 cm] (-0.6,-0.2) grid (2.1,1.6);
\coordinate (A) at (0,0);
\coordinate (B) at (0,1);
\coordinate (C) at (1,1);
\coordinate (D) at (1,0);
\coordinate (E) at (2,0);
\coordinate (F) at (2,1);
%
\draw (A) -- (B) -- (C) -- (D) -- cycle;
%
\draw[dotfill] (A) circle [dot];
\draw[dotfill] (B) circle [dot];
\draw[dotfill] (C) circle [dot];
\draw[dotfill] (D) circle [dot];
\draw[dotfill] (E) circle [dot];
\draw[dotfill] (F) circle [dot];
%
\end{tikzpicture}" /></p>
</div><p>while an irregular mesh of triangles is also possible:</p>
<div class="figure">
<p><img src="../_images/tikz-0409b50474d169000f3835a3eebd7216ad25c2dc.png" alt="\begin{tikzpicture}[%
dot/.style = {radius=0.04},
dotfill/.style={color=black, fill},
]
\coordinate (A) at (0,0);
\coordinate (B) at (1,-0.2);
\coordinate (C) at (2,1);
\coordinate (D) at (0.7,0.9);
\coordinate (E) at ($(C)+(0.5,0.8)$);
\coordinate (F) at ($(D)+(0.3,0.8)$);
\coordinate (G) at ($(A)+(-0.3,1.2)$);
\coordinate (H) at ($(B)+(1.4,0.3)$);
%
\draw (A) -- (B) -- (C) -- (E) -- (F) -- (G) -- cycle;
\draw (A) -- (D) -- (B);
\draw (D) -- (C) -- (F) -- cycle;
\draw (G) -- (D);
\draw (B) -- (H) -- (C);
\draw (H) -- (E);
%
\draw[dotfill] (A) circle [dot];
\draw[dotfill] (B) circle [dot];
\draw[dotfill] (C) circle [dot];
\draw[dotfill] (D) circle [dot];
\draw[dotfill] (E) circle [dot];
\draw[dotfill] (F) circle [dot];
\draw[dotfill] (G) circle [dot];
\draw[dotfill] (H) circle [dot];
%
\end{tikzpicture}" /></p>
</div><p>The <a class="reference internal" href="../undoc_brille.html#module-brille._brille" title="brille._brille"><code class="xref py py-mod docutils literal notranslate"><span class="pre">brille._brille</span></code></a> module implements multiple grid types for linear interpolation
within the first or irreducible Brillouin zone.
In most cases the <a class="reference internal" href="../undoc_brille.html#brille._brille.BZTrellisQdc" title="brille._brille.BZTrellisQdc"><code class="xref py py-class docutils literal notranslate"><span class="pre">BZTrellisQdc</span></code></a> should be used.</p>
<p>Since the grids are intended to be used with eigenvectors and their associated eigenvalues
each must support mixed real and complex data.
To allow this, each type of grid is exposed to Python three times with a suffix
<cite>dd</cite> for <cite>(double, double)</cite>, <cite>dc</cite> for <cite>(double, std::complex&lt;double&gt;)</cite>
and <cite>cc</cite> for <cite>(std::complex&lt;double&gt;, std::complex&lt;double&gt;)</cite>.</p>
<div class="section" id="regular-grids">
<h2>Regular grids<a class="headerlink" href="#regular-grids" title="Permalink to this headline">¶</a></h2>
<p>Interpolation using grids constructed of regular parallelpipeds is possible,
but will lead to artefacts near the Brillouin zone boundary if the primitive
lattice has any non-orthogonal basis vectors.
This is such a large restriction that regular grids are no longer supported in <a class="reference internal" href="../undoc_brille.html#module-brille._brille" title="brille._brille"><code class="xref py py-mod docutils literal notranslate"><span class="pre">brille._brille</span></code></a></p>
<div class="figure">
<p><img src="../_images/tikz-e0ae3754da374bddfe7ac535009b74dca4f59200.png" alt="\begin{tikzpicture}[
dot/.style = {radius=0.04}, dotfill/.style={color=black, fill},
adot/.style = {color=red},
bdot/.style = {color=blue},
cdot/.style = {color=green!50!black},
ddot/.style = {color=orange},
a/.style = {fill=red!50!white},
b/.style = {fill=blue!50!white},
c/.style = {fill=green!50!black!50!white},
d/.style = {fill=orange!50!white},
]
\draw[step=1 cm] (-0.6,-0.2) grid (2.1,1.6);
\coordinate (A) at (0,0);
\coordinate (B) at (0,1);
\coordinate (C) at (1,1);
\coordinate (D) at (1,0);
\coordinate (E) at (2,0);
\coordinate (F) at (2,1);
\coordinate (X) at (0.6, 0);
\coordinate (Y) at (0, 0.2);
\coordinate (XY) at ($(X)+(Y)$);
%
\fill[a] (C) rectangle (XY);
\fill[b] (D) rectangle (XY);
\fill[c] (A) rectangle (XY);
\fill[d] (B) rectangle (XY);
%
\draw (A) -- (B) -- (C) -- (D) -- cycle;
%
\draw[adot,a] (A) circle [dot];
\draw[bdot,b] (B) circle [dot];
\draw[cdot,c] (C) circle [dot];
\draw[ddot,d] (D) circle [dot];
\draw[color=black,fill=white] (XY) circle [dot];
\draw[color=black, fill] (E) circle [dot];
\draw[color=black, fill] (F) circle [dot];
%
\end{tikzpicture}" /></p>
</div></div>
<div class="section" id="triangulated-grids">
<h2>Triangulated grids<a class="headerlink" href="#triangulated-grids" title="Permalink to this headline">¶</a></h2>
<p>An alternative to the regular parallelpiped grid which may still have some utility is the
triangulation of a bounded space.
If the triangulated space is bounded by a polyhedron then the triangulation can always
represent it exactly, though possibly with sub-optimal triangulated cells.</p>
<div class="figure">
<p><img src="../_images/tikz-69b5c738b8af6eada71de2fd79c6cac957d00d78.png" alt="\begin{tikzpicture}[%
dot/.style = {radius=0.04},
afill/.style={color=purple!50!white},
bfill/.style={color=yellow!50!green!50!white},
cfill/.style={color=teal!50!white},
adot/.style={color=purple,fill=purple!50!white},
bdot/.style={color=yellow!50!green,fill=yellow!50!green!50!white},
cdot/.style={color=teal,fill=teal!50!white},
dotfill/.style={color=black, fill},
]
\coordinate (A) at (0,0);
\coordinate (B) at (1,-0.2);
\coordinate (C) at (2,1);
\coordinate (D) at (0.7,0.9);
\coordinate (E) at ($(C)+(0.5,0.8)$);
\coordinate (F) at ($(D)+(0.3,0.8)$);
\coordinate (G) at ($(A)+(-0.3,1.2)$);
\coordinate (H) at ($(B)+(1.4,0.3)$);
\coordinate (XY) at ($0.3*(B)+0.2*(C)+0.5*(D)$);
%
\fill[afill] (C) -- (D) -- (XY) -- cycle;
\fill[bfill] (B) -- (XY) -- (D) -- cycle;
\fill[cfill] (B) -- (C) -- (XY) -- cycle;
%
\draw (A) -- (B) -- (C) -- (E) -- (F) -- (G) -- cycle;
\draw (A) -- (D) -- (B);
\draw (D) -- (C) -- (F) -- cycle;
\draw (G) -- (D);
\draw (B) -- (H) -- (C);
\draw (H) -- (E);
%
\draw[dotfill] (A) circle [dot];
\draw[adot] (B) circle [dot];
\draw[bdot] (C) circle [dot];
\draw[cdot] (D) circle [dot];
\draw[color=black,fill=white] (XY) circle [dot];
\draw[dotfill] (E) circle [dot];
\draw[dotfill] (F) circle [dot];
\draw[dotfill] (G) circle [dot];
\draw[dotfill] (H) circle [dot];
%
\end{tikzpicture}" /></p>
</div><p>There are two exposed implementations of the triangulated grid,
both detailed below under the headings <a class="reference internal" href="#simple">Simple</a> and <a class="reference internal" href="#hierarchy">Hierarchy</a>.</p>
<div class="section" id="simple">
<h3>Simple<a class="headerlink" href="#simple" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="../undoc_brille.html#brille._brille.BZMeshQdc" title="brille._brille.BZMeshQdc"><code class="xref py py-class docutils literal notranslate"><span class="pre">BZMeshQdc</span></code></a> and its type-sibilings implement a simple triangulated grid.
Locating the tetrahedron within the grid which contains a test point could require as many in-tetrahedron
checks as there are tetrahedra in the grid.
This class should be fine for use in applications where intra-grid-point interpolation is not required,
such as Brillouin zone integrations, but should probably be avoided when interpolation at random points
is required.</p>
<dl class="py class">
<dt id="brille._brille.BZMeshQdd">
<em class="property">class </em><code class="sig-prename descclassname">brille._brille.</code><code class="sig-name descname">BZMeshQdd</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span><span class="p">:</span> <span class="n"><a class="reference internal" href="../undoc_brille.html#brille._brille.BZMeshQdd" title="brille._brille.BZMeshQdd">brille._brille.BZMeshQdd</a></span></em>, <em class="sig-param"><span class="n">brillouinzone</span><span class="p">:</span> <span class="n"><a class="reference internal" href="../undoc_brille.html#brille._brille.BrillouinZone" title="brille._brille.BrillouinZone">brille._brille.BrillouinZone</a></span></em>, <em class="sig-param"><span class="n">max_size</span><span class="p">:</span> <span class="n">float</span> <span class="o">=</span> <span class="default_value">- 1.0</span></em>, <em class="sig-param"><span class="n">num_levels</span><span class="p">:</span> <span class="n">int</span> <span class="o">=</span> <span class="default_value">3</span></em>, <em class="sig-param"><span class="n">max_points</span><span class="p">:</span> <span class="n">int</span> <span class="o">=</span> <span class="default_value">- 1</span></em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#brille._brille.BZMeshQdd" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt id="brille._brille.BZMeshQcc">
<em class="property">class </em><code class="sig-prename descclassname">brille._brille.</code><code class="sig-name descname">BZMeshQcc</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span><span class="p">:</span> <span class="n"><a class="reference internal" href="../undoc_brille.html#brille._brille.BZMeshQcc" title="brille._brille.BZMeshQcc">brille._brille.BZMeshQcc</a></span></em>, <em class="sig-param"><span class="n">brillouinzone</span><span class="p">:</span> <span class="n"><a class="reference internal" href="../undoc_brille.html#brille._brille.BrillouinZone" title="brille._brille.BrillouinZone">brille._brille.BrillouinZone</a></span></em>, <em class="sig-param"><span class="n">max_size</span><span class="p">:</span> <span class="n">float</span> <span class="o">=</span> <span class="default_value">- 1.0</span></em>, <em class="sig-param"><span class="n">num_levels</span><span class="p">:</span> <span class="n">int</span> <span class="o">=</span> <span class="default_value">3</span></em>, <em class="sig-param"><span class="n">max_points</span><span class="p">:</span> <span class="n">int</span> <span class="o">=</span> <span class="default_value">- 1</span></em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#brille._brille.BZMeshQcc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt id="brille._brille.BZMeshQdc">
<em class="property">class </em><code class="sig-prename descclassname">brille._brille.</code><code class="sig-name descname">BZMeshQdc</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span><span class="p">:</span> <span class="n"><a class="reference internal" href="../undoc_brille.html#brille._brille.BZMeshQdc" title="brille._brille.BZMeshQdc">brille._brille.BZMeshQdc</a></span></em>, <em class="sig-param"><span class="n">brillouinzone</span><span class="p">:</span> <span class="n"><a class="reference internal" href="../undoc_brille.html#brille._brille.BrillouinZone" title="brille._brille.BrillouinZone">brille._brille.BrillouinZone</a></span></em>, <em class="sig-param"><span class="n">max_size</span><span class="p">:</span> <span class="n">float</span> <span class="o">=</span> <span class="default_value">- 1.0</span></em>, <em class="sig-param"><span class="n">num_levels</span><span class="p">:</span> <span class="n">int</span> <span class="o">=</span> <span class="default_value">3</span></em>, <em class="sig-param"><span class="n">max_points</span><span class="p">:</span> <span class="n">int</span> <span class="o">=</span> <span class="default_value">- 1</span></em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#brille._brille.BZMeshQdc" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py method">
<dt id="brille._brille.BZMeshQdc.bytes_per_point">
<em class="property">property </em><code class="sig-name descname">bytes_per_point</code><a class="headerlink" href="#brille._brille.BZMeshQdc.bytes_per_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the memory required per interpolation point <em>result</em> in bytes</p>
</dd></dl>

<dl class="py method">
<dt id="brille._brille.BZMeshQdc.debye_waller">
<code class="sig-name descname">debye_waller</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span><span class="p">:</span> <span class="n"><a class="reference internal" href="../undoc_brille.html#brille._brille.BZMeshQdc" title="brille._brille.BZMeshQdc">brille._brille.BZMeshQdc</a></span></em>, <em class="sig-param"><span class="n">Q</span><span class="p">:</span> <span class="n">numpy.ndarray<span class="p">[</span>numpy.float64<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">masses</span><span class="p">:</span> <span class="n">numpy.ndarray<span class="p">[</span>numpy.float64<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">Temperature_in_K</span><span class="p">:</span> <span class="n">float</span></em><span class="sig-paren">)</span> &#x2192; numpy.ndarray<span class="p">[</span>numpy.float64<span class="p">]</span><a class="headerlink" href="#brille._brille.BZMeshQdc.debye_waller" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the Debye-Waller factor by integrating over the Brillouin zone grid</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pyX</strong> (<em>float, array_like</em>) – A two dimensional array with <cite>Q.shape[1] == 3</cite> containing the positions at
which to calculate the Debye-Waller factor</p></li>
<li><p><strong>pyM</strong> (<em>float, array_like</em>) – The atom masses in Atomic Mass Units, matching the atom types provided to
the <a class="reference internal" href="../undoc_brille.html#brille._brille.Direct" title="brille._brille.Direct"><code class="xref py py-class docutils literal notranslate"><span class="pre">Direct</span></code></a> constructor for the crystal basis</p></li>
<li><p><strong>temp_K</strong> (<em>float</em>) – The temperature at which to calculate the Debye-Waller factor in Kelvin</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A one-dimensional array of the Debye-Waller factor evaluated at each input</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="brille._brille.BZMeshQdc.fill">
<code class="sig-name descname">fill</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille._brille.BZMeshQdc.fill" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>fill(self: brille._brille.BZMeshQdc, values_data: numpy.ndarray[numpy.float64], values_elements: numpy.ndarray[numpy.int32], vectors_data: numpy.ndarray[numpy.complex128], vectors_elements: numpy.ndarray[numpy.int32], sort: bool = False) -&gt; None</p></li>
</ol>
<blockquote>
<div><p>Provide data required for interpolation to the grid without cost information.</p>
<p>This method should probably be followed by <code class="xref py py-meth docutils literal notranslate"><span class="pre">set_cost_info()</span></code> prior to
any attempt to interpolate the data in the grid.</p>
<dl>
<dt>values_data<span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></span></dt><dd><p>The eigenvalue data to be stored in the grid. The first dimension must be
equal in size to the number of grid-vertices. If two dimensional the second
dimension is interpreted as all information for a single mode flattened
and concatenated into (scalars, vectors, matrices) – in that order.
If more than two dimensional, the second dimension indexes modes and
higher dimensions will be flattend <em>as if row ordered</em> and must flatten into
a concatenated list of (scalars, vectors, matrices).
If the provided array can be interpreted as a contiguous row-ordered two
dimensional array it will be used in place, otherwise a copy will be made.</p>
</dd>
<dt>values_elements: integer vector-like</dt><dd><p>A multi-purpose vector containing, in order,
the number of scalar-like eigenvalue elements,
the number of vector-like eigenvalue <em>elements</em> (must be <span class="math">\(3\times N\)</span>),
the number of matrix-like eigenvalue <em>elements</em> (must be <span class="math">\(9\times N\)</span>),
and
<em>how</em> the vector-like and matrix-like parts transform under application
of a symmetry operation,
See the note below fore the meaning of the last three value.
Any extra entries are ignored.</p>
</dd>
<dt>vectors_data<span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></span></dt><dd><p>The eigenvector data to be stored in the grid. Same shape restrictions as
<cite>values_data</cite></p>
</dd>
<dt>vectors_elements:</dt><dd><p>Like <cite>values_elements</cite> but for the eigenvectors</p>
</dd>
<dt>sort<span class="classifier">logical (default False)</span></dt><dd><p>Whether the equivalent-mode permutations should be (re)determined following
the update to the flags and weights.</p>
</dd>
</dl>
<blockquote>
<div><p>Mapping of integers to <code class="xref py py-mod docutils literal notranslate"><span class="pre">RotatesLike</span></code> values:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 15%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><code class="xref py py-mod docutils literal notranslate"><span class="pre">RotatesLike</span></code></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>Real</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>Reciprocal</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>Axial</cite></p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p><cite>Gamma</cite></p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 0.</p>
</div></blockquote>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>fill(self: brille._brille.BZMeshQdc, values_data: numpy.ndarray[numpy.float64], values_elements: numpy.ndarray[numpy.int32], values_weights: numpy.ndarray[numpy.float64], vectors_data: numpy.ndarray[numpy.complex128], vectors_elements: numpy.ndarray[numpy.int32], vectors_weights: numpy.ndarray[numpy.float64], sort: bool = False) -&gt; None</p></li>
</ol>
<blockquote>
<div><p>Provide all data required for interpolation to the grid at once</p>
<dl>
<dt>values_data<span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></span></dt><dd><p>The eigenvalue data to be stored in the grid. The first dimension must be
equal in size to the number of grid-vertices. If two dimensional the second
dimension is interpreted as all information for a single mode flattened
and concatenated into (scalars, vectors, matrices) – in that order.
If more than two dimensional, the second dimension indexes modes and
higher dimensions will be flattend <em>as if row ordered</em> and must flatten into
a concatenated list of (scalars, vectors, matrices).
If the provided array can be interpreted as a contiguous row-ordered two
dimensional array it will be used in place, otherwise a copy will be made.</p>
</dd>
<dt>values_elements: integer vector-like</dt><dd><p>A multi-purpose vector containing, in order,
the number of scalar-like eigenvalue elements,
the number of vector-like eigenvalue <em>elements</em> (must be <span class="math">\(3\times N\)</span>),
the number of matrix-like eigenvalue <em>elements</em> (must be <span class="math">\(9\times N\)</span>),
<em>how</em> the vector-like and matrix-like parts transform under application
of a symmetry operation,
which scalar cost function should be used,
and which vector cost function should be used.
See the note below fore the meaning of the last three values.</p>
</dd>
<dt>values_weights<span class="classifier">float, vector-like</span></dt><dd><p>The relative cost weights between scalar-, vector-, and matrix- like
eigenvalue elements stored in the grid</p>
</dd>
<dt>vectors_data<span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></span></dt><dd><p>The eigenvector data to be stored in the grid. Same shape restrictions as
<cite>values_data</cite></p>
</dd>
<dt>vectors_elements:</dt><dd><p>Like <cite>values_elements</cite> but for the eigenvectors</p>
</dd>
<dt>vectors_weights<span class="classifier">float, vector-like</span></dt><dd><p>The relative cost weights between scalar-, vector-, and matrix- like
eigenvector elements stored in the grid</p>
</dd>
<dt>sort<span class="classifier">logical (default False)</span></dt><dd><p>Whether the equivalent-mode permutations should be (re)determined following
the update to the flags and weights.</p>
</dd>
</dl>
<blockquote>
<div><p>Mapping of integers to <code class="xref py py-mod docutils literal notranslate"><span class="pre">RotatesLike</span></code> values:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 15%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><code class="xref py py-mod docutils literal notranslate"><span class="pre">RotatesLike</span></code></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>Real</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>Reciprocal</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>Axial</cite></p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p><cite>Gamma</cite></p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to scalar cost function:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(x,y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>magnitude(x-y)</p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to vector cost function:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 16%" />
<col style="width: 84%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(vec_x, vec_y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>sin(hermitian_angle(vec_x, vec_y))</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>vector_distance(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>1 - vector_product(vec_x, vec_y)</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>vector_angle(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>hermitian_angle(vec_x, vec_y)</p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 0.</p>
</div></blockquote>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt id="brille._brille.BZMeshQdc.ir_interpolate_at">
<code class="sig-name descname">ir_interpolate_at</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span><span class="p">:</span> <span class="n"><a class="reference internal" href="../undoc_brille.html#brille._brille.BZMeshQdc" title="brille._brille.BZMeshQdc">brille._brille.BZMeshQdc</a></span></em>, <em class="sig-param"><span class="n">Q</span><span class="p">:</span> <span class="n">numpy.ndarray<span class="p">[</span>numpy.float64<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">useparallel</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">threads</span><span class="p">:</span> <span class="n">int</span> <span class="o">=</span> <span class="default_value">- 1</span></em>, <em class="sig-param"><span class="n">do_not_move_points</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em><span class="sig-paren">)</span> &#x2192; Tuple<span class="p">[</span>numpy.ndarray<span class="p">[</span>numpy.float64<span class="p">]</span><span class="p">, </span>numpy.ndarray<span class="p">[</span>numpy.complex128<span class="p">]</span><span class="p">]</span><a class="headerlink" href="#brille._brille.BZMeshQdc.ir_interpolate_at" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform linear interpolation of the stored data at irreducible equivalent points</p>
<p>The irreducible first Brillouin zone is the part of reciprocal space which is
invariant under application of the integer translations <em>and</em> the pointgroup
operations of a reciprocal space lattice. This method finds points equivalent
to the input within the irreducible first Brillouin zone and then interpolates
pre-stored information to provide an estimate at the found positions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Q</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>) – A two dimensional array with <cite>Q.shape[1] == 3</cite> containing the positions at
which an interpolated result is required, expressed in units of the
reciprocal lattice.</p></li>
<li><p><strong>useparallel</strong> (<em>bool, optional</em>) – Whether a serial or parallel code should be utilised</p></li>
<li><p><strong>threads</strong> (<em>int, optional</em>) – How many OpenMP workers should be utilised; if this value is less than one
the environment variable <cite>OMP_NUM_THREADS</cite> will be used.</p></li>
<li><p><strong>do_not_move_points</strong> (<em>bool, optional</em>) – If <cite>True</cite> the provided <cite>Q</cite> points must already lie within the first Brillouin
zone. No check is made to verify this requirement and if any <cite>Q</cite> lie outside
of the gridded volume out-of-bounds errors may result in bad data or runtime
errors.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The interpolated eigenvalues and eigenvectors at the equivalent
irreducible first Brillouin zone points.
The shape of each output will depend on the shape of the data provided to
the <cite>fill</cite> method. If the filled eigenvalues were of shape
<cite>[N_grid_points, N_modes, A, …, B]</cite>, the eigenvectors were of shape
<cite>[N_grid_points, N_modes, C, …, D]</cite>, and the provided points of shape
<cite>[N_Q_points, 3]</cite> then the output shapes will be
<cite>[N_Q_points, N_modes, A, …, B]</cite> and <cite>[N_Q_points, N_modes, C, …, D]</cite>
for the eigenvalues and eigenvectors, respectively.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="brille._brille.BZMeshQdc.ir_interpolate_at_dw">
<code class="sig-name descname">ir_interpolate_at_dw</code><span class="sig-paren">(</span><em class="sig-param">self: brille._brille.BZMeshQdc, Q: numpy.ndarray[numpy.float64], M/amu: numpy.ndarray[numpy.float64], temperature/K: float, useparallel: bool = False, threads: int = -1, do_not_move_points: bool = False</em><span class="sig-paren">)</span> &#x2192; Tuple<span class="p">[</span>numpy.ndarray<span class="p">[</span>numpy.float64<span class="p">]</span><span class="p">, </span>numpy.ndarray<span class="p">[</span>numpy.complex128<span class="p">]</span><span class="p">, </span>numpy.ndarray<span class="p">[</span>numpy.float64<span class="p">]</span><span class="p">]</span><a class="headerlink" href="#brille._brille.BZMeshQdc.ir_interpolate_at_dw" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform both the linear interpolation and Debye Waller calculation</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Q</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>) – A two dimensional array with <cite>Q.shape[1] == 3</cite> containing the positions at
which an interpolated result is required, expressed in units of the
reciprocal lattice.</p></li>
<li><p><strong>M</strong> (<em>vector like</em>) – The masses of atoms in the lattice basis in Atomic Mass Units (amu)</p></li>
<li><p><strong>temperature</strong> (<em>float</em>) – The temperature at which to perform the Debye Waller calculation</p></li>
<li><p><strong>useparallel</strong> (<em>bool, optional</em>) – Whether a serial or parallel code should be utilised</p></li>
<li><p><strong>threads</strong> (<em>int, optional</em>) – How many OpenMP workers should be utilised; if this value is less than one
the environment variable <cite>OMP_NUM_THREADS</cite> will be used.</p></li>
<li><p><strong>do_not_move_points</strong> (<em>bool, optional</em>) – If <cite>True</cite> the provided <cite>Q</cite> points must already lie within the first Brillouin
zone. No check is made to verify this requirement and if any <cite>Q</cite> lie outside
of the gridded volume out-of-bounds errors may result in bad data or runtime
errors.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The interpolated eigenvalues and eigenvectors at the equivalent
irreducible first Brillouin zone points, and the result of the
Debye-Waller calculation at the input Q points.
The shape of each output will depend on the shape of the data provided to
the <cite>fill</cite> method. If the filled eigenvalues were of shape
<cite>[N_grid_points, N_modes, A, …, B]</cite>, the eigenvectors were of shape
<cite>[N_grid_points, N_modes, C, …, D]</cite>, and the provided points of shape
<cite>[N_Q_points, 3]</cite> then the output shapes will be
<cite>[N_Q_points, N_modes, A, …, B]</cite> and <cite>[N_Q_points, N_modes, C, …, D]</cite>
for the eigenvalues and eigenvectors, respectively.
The Debye Waller result is always a <cite>[N_Q_points]</cite> vector.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="brille._brille.BZMeshQdc.set_flags_weights">
<code class="sig-name descname">set_flags_weights</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span><span class="p">:</span> <span class="n"><a class="reference internal" href="../undoc_brille.html#brille._brille.BZMeshQdc" title="brille._brille.BZMeshQdc">brille._brille.BZMeshQdc</a></span></em>, <em class="sig-param"><span class="n">values_flags</span><span class="p">:</span> <span class="n">numpy.ndarray<span class="p">[</span>numpy.int32<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">values_weights</span><span class="p">:</span> <span class="n">numpy.ndarray<span class="p">[</span>numpy.float64<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">vectors_flags</span><span class="p">:</span> <span class="n">numpy.ndarray<span class="p">[</span>numpy.int32<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">vectors_weights</span><span class="p">:</span> <span class="n">numpy.ndarray<span class="p">[</span>numpy.float64<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">sort</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#brille._brille.BZMeshQdc.set_flags_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Set RotatesLike and cost functions plus relative cost weights for the
values and vectors stored in the object</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>values_flags</strong> (<em>integer, vector-like</em>) – One or more values indicating the <code class="xref py py-mod docutils literal notranslate"><span class="pre">RotatesLike</span></code>
value for the eigenvalues stored in the object, plus which cost function
to use when comparing stored eigenvalues at neighbouring grid points for
scalar- and vector-like eigenvalues.</p></li>
<li><p><strong>values_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvalue elements stored in the grid</p></li>
<li><p><strong>vectors_flags</strong> (<em>integer, vector-like</em>) – One or more values indicating the <code class="xref py py-mod docutils literal notranslate"><span class="pre">RotatesLike</span></code>
value for the eigenvectors stored in the object, plus which cost function
to use when comparing stored eigenvectors at neighbouring grid points for
scalar- and vector-like eigenvectors.</p></li>
<li><p><strong>vectors_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvector elements stored in the grid</p></li>
<li><p><strong>sort</strong> (<em>bool, optional</em>) – Whether the equivalent-mode permutations should be (re)determined following
the update to the flags and weights.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Mapping of integers to <code class="xref py py-mod docutils literal notranslate"><span class="pre">RotatesLike</span></code> values:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 15%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><code class="xref py py-mod docutils literal notranslate"><span class="pre">RotatesLike</span></code></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>Real</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>Reciprocal</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>Axial</cite></p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p><cite>Gamma</cite></p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to scalar cost function:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(x,y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>magnitude(x-y)</p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to vector cost function:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 16%" />
<col style="width: 84%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(vec_x, vec_y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>sin(hermitian_angle(vec_x, vec_y))</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>vector_distance(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>1 - vector_product(vec_x, vec_y)</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>vector_angle(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>hermitian_angle(vec_x, vec_y)</p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 0.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="brille._brille.BZMeshQdc.sort">
<code class="sig-name descname">sort</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span><span class="p">:</span> <span class="n"><a class="reference internal" href="../undoc_brille.html#brille._brille.BZMeshQdc" title="brille._brille.BZMeshQdc">brille._brille.BZMeshQdc</a></span></em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#brille._brille.BZMeshQdc.sort" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="brille._brille.BZMeshQdc.values">
<em class="property">property </em><code class="sig-name descname">values</code><a class="headerlink" href="#brille._brille.BZMeshQdc.values" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a shared view of the stored eigenvalues</p>
</dd></dl>

<dl class="py method">
<dt id="brille._brille.BZMeshQdc.vectors">
<em class="property">property </em><code class="sig-name descname">vectors</code><a class="headerlink" href="#brille._brille.BZMeshQdc.vectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a shared view of the stored eigenvectors</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="hierarchy">
<h3>Hierarchy<a class="headerlink" href="#hierarchy" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="../undoc_brille.html#brille._brille.BZNestQdc" title="brille._brille.BZNestQdc"><code class="xref py py-class docutils literal notranslate"><span class="pre">BZNestQdc</span></code></a> and its type-siblings implements a triangulated grid with
multiple triangulations of the Brillouin Zone of increasingly finer maximum tetrahedron size;
overlapping regions of these triangulations are identified and stored to simplify later finding
the smallest tetrahedron containing a given point.</p>
<p>Starting from the coarsest ‘top’ <cite>layer</cite> of tetrahedra a containing tetrahedron should be quick to locate.
Then the list of overlapping next-finer <cite>layer</cite> tetrahedra can be used to locate the next containing tetrahedron.
This process repeats until the finest <cite>layer</cite> tetrahedron containin the point is found.
The total number of in-tetrahedron checks is then on the order of the sum of the average number of connected
tetrahedra at each layer over the number of layers; which should be chosen to be smaller than the total
number of tetrahedra at the finest layer.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>As implemented, the tetrahedra of two subsequent triangulations could have any overlapping relationship
including one finer-tetrahedron intersecting with two (or more) coarser-tetrahedra.
In practice it seems that the <cite>TetGen</cite> meshing algorithm always produces finer-tetrahedra which subdivide
a coarser-tetrahedra, so that a finite-tree is formed between the <cite>layers</cite> of the <cite>nest</cite>.
A class requiring this relationship should be able to extract memory and speed efficiencies which the
current implementation sacrificed for greater relationsional flexibility.</p>
</div>
<p>If any <span class="math">\(i^\text{th}\)</span> layer has tetrahedra each with an average overlapping number of tetrahedra
in the <span class="math">\((i+1)^\text{th}\)</span> layer <span class="math">\(\left&lt;m\right&gt;_i\)</span> then the typical number of in-tetrahedra
checks required to find the finest-tetrahedra containing any point is</p>
<div class="math">
\[N_\text{checks} \propto \sum_{i=1}^n \left< m \right>_i

\]</div>
<p>and the finest <cite>layer</cite> contains</p>
<div class="math">
\[N_\text{tetrahedra}^n = \prod_{i=1}^n \left< m \left>_i

\]</div>
<p>tetrahedra. As long as <span class="math">\(N_\text{checks} &lt; N_\text{tetrahedra}^n\)</span> this location method will be more efficient.</p>
<dl class="py class">
<dt id="brille._brille.BZNestQdd">
<em class="property">class </em><code class="sig-prename descclassname">brille._brille.</code><code class="sig-name descname">BZNestQdd</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille._brille.BZNestQdd" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: brille._brille.BZNestQdd, brillouinzone: brille._brille.BrillouinZone, max_volume: float, max_branchings: int = 5) -&gt; None</p></li>
<li><p>__init__(self: brille._brille.BZNestQdd, brillouinzone: brille._brille.BrillouinZone, number_density: int, max_branchings: int = 5) -&gt; None</p></li>
</ol>
</dd></dl>

<dl class="py class">
<dt id="brille._brille.BZNestQcc">
<em class="property">class </em><code class="sig-prename descclassname">brille._brille.</code><code class="sig-name descname">BZNestQcc</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille._brille.BZNestQcc" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: brille._brille.BZNestQcc, brillouinzone: brille._brille.BrillouinZone, max_volume: float, max_branchings: int = 5) -&gt; None</p></li>
<li><p>__init__(self: brille._brille.BZNestQcc, brillouinzone: brille._brille.BrillouinZone, number_density: int, max_branchings: int = 5) -&gt; None</p></li>
</ol>
</dd></dl>

<dl class="py class">
<dt id="brille._brille.BZNestQdc">
<em class="property">class </em><code class="sig-prename descclassname">brille._brille.</code><code class="sig-name descname">BZNestQdc</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille._brille.BZNestQdc" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: brille._brille.BZNestQdc, brillouinzone: brille._brille.BrillouinZone, max_volume: float, max_branchings: int = 5) -&gt; None</p></li>
<li><p>__init__(self: brille._brille.BZNestQdc, brillouinzone: brille._brille.BrillouinZone, number_density: int, max_branchings: int = 5) -&gt; None</p></li>
</ol>
<dl class="py method">
<dt id="brille._brille.BZNestQdc.bytes_per_point">
<em class="property">property </em><code class="sig-name descname">bytes_per_point</code><a class="headerlink" href="#brille._brille.BZNestQdc.bytes_per_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the memory required per interpolation point <em>result</em> in bytes</p>
</dd></dl>

<dl class="py method">
<dt id="brille._brille.BZNestQdc.debye_waller">
<code class="sig-name descname">debye_waller</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span><span class="p">:</span> <span class="n"><a class="reference internal" href="../undoc_brille.html#brille._brille.BZNestQdc" title="brille._brille.BZNestQdc">brille._brille.BZNestQdc</a></span></em>, <em class="sig-param"><span class="n">Q</span><span class="p">:</span> <span class="n">numpy.ndarray<span class="p">[</span>numpy.float64<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">masses</span><span class="p">:</span> <span class="n">numpy.ndarray<span class="p">[</span>numpy.float64<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">Temperature_in_K</span><span class="p">:</span> <span class="n">float</span></em><span class="sig-paren">)</span> &#x2192; numpy.ndarray<span class="p">[</span>numpy.float64<span class="p">]</span><a class="headerlink" href="#brille._brille.BZNestQdc.debye_waller" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the Debye-Waller factor by integrating over the Brillouin zone grid</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pyX</strong> (<em>float, array_like</em>) – A two dimensional array with <cite>Q.shape[1] == 3</cite> containing the positions at
which to calculate the Debye-Waller factor</p></li>
<li><p><strong>pyM</strong> (<em>float, array_like</em>) – The atom masses in Atomic Mass Units, matching the atom types provided to
the <a class="reference internal" href="../undoc_brille.html#brille._brille.Direct" title="brille._brille.Direct"><code class="xref py py-class docutils literal notranslate"><span class="pre">Direct</span></code></a> constructor for the crystal basis</p></li>
<li><p><strong>temp_K</strong> (<em>float</em>) – The temperature at which to calculate the Debye-Waller factor in Kelvin</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A one-dimensional array of the Debye-Waller factor evaluated at each input</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="brille._brille.BZNestQdc.fill">
<code class="sig-name descname">fill</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille._brille.BZNestQdc.fill" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>fill(self: brille._brille.BZNestQdc, values_data: numpy.ndarray[numpy.float64], values_elements: numpy.ndarray[numpy.int32], vectors_data: numpy.ndarray[numpy.complex128], vectors_elements: numpy.ndarray[numpy.int32], sort: bool = False) -&gt; None</p></li>
</ol>
<blockquote>
<div><p>Provide data required for interpolation to the grid without cost information.</p>
<p>This method should probably be followed by <code class="xref py py-meth docutils literal notranslate"><span class="pre">set_cost_info()</span></code> prior to
any attempt to interpolate the data in the grid.</p>
<dl>
<dt>values_data<span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></span></dt><dd><p>The eigenvalue data to be stored in the grid. The first dimension must be
equal in size to the number of grid-vertices. If two dimensional the second
dimension is interpreted as all information for a single mode flattened
and concatenated into (scalars, vectors, matrices) – in that order.
If more than two dimensional, the second dimension indexes modes and
higher dimensions will be flattend <em>as if row ordered</em> and must flatten into
a concatenated list of (scalars, vectors, matrices).
If the provided array can be interpreted as a contiguous row-ordered two
dimensional array it will be used in place, otherwise a copy will be made.</p>
</dd>
<dt>values_elements: integer vector-like</dt><dd><p>A multi-purpose vector containing, in order,
the number of scalar-like eigenvalue elements,
the number of vector-like eigenvalue <em>elements</em> (must be <span class="math">\(3\times N\)</span>),
the number of matrix-like eigenvalue <em>elements</em> (must be <span class="math">\(9\times N\)</span>),
and
<em>how</em> the vector-like and matrix-like parts transform under application
of a symmetry operation,
See the note below fore the meaning of the last three value.
Any extra entries are ignored.</p>
</dd>
<dt>vectors_data<span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></span></dt><dd><p>The eigenvector data to be stored in the grid. Same shape restrictions as
<cite>values_data</cite></p>
</dd>
<dt>vectors_elements:</dt><dd><p>Like <cite>values_elements</cite> but for the eigenvectors</p>
</dd>
<dt>sort<span class="classifier">logical (default False)</span></dt><dd><p>Whether the equivalent-mode permutations should be (re)determined following
the update to the flags and weights.</p>
</dd>
</dl>
<blockquote>
<div><p>Mapping of integers to <code class="xref py py-mod docutils literal notranslate"><span class="pre">RotatesLike</span></code> values:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 15%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><code class="xref py py-mod docutils literal notranslate"><span class="pre">RotatesLike</span></code></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>Real</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>Reciprocal</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>Axial</cite></p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p><cite>Gamma</cite></p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 0.</p>
</div></blockquote>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>fill(self: brille._brille.BZNestQdc, values_data: numpy.ndarray[numpy.float64], values_elements: numpy.ndarray[numpy.int32], values_weights: numpy.ndarray[numpy.float64], vectors_data: numpy.ndarray[numpy.complex128], vectors_elements: numpy.ndarray[numpy.int32], vectors_weights: numpy.ndarray[numpy.float64], sort: bool = False) -&gt; None</p></li>
</ol>
<blockquote>
<div><p>Provide all data required for interpolation to the grid at once</p>
<dl>
<dt>values_data<span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></span></dt><dd><p>The eigenvalue data to be stored in the grid. The first dimension must be
equal in size to the number of grid-vertices. If two dimensional the second
dimension is interpreted as all information for a single mode flattened
and concatenated into (scalars, vectors, matrices) – in that order.
If more than two dimensional, the second dimension indexes modes and
higher dimensions will be flattend <em>as if row ordered</em> and must flatten into
a concatenated list of (scalars, vectors, matrices).
If the provided array can be interpreted as a contiguous row-ordered two
dimensional array it will be used in place, otherwise a copy will be made.</p>
</dd>
<dt>values_elements: integer vector-like</dt><dd><p>A multi-purpose vector containing, in order,
the number of scalar-like eigenvalue elements,
the number of vector-like eigenvalue <em>elements</em> (must be <span class="math">\(3\times N\)</span>),
the number of matrix-like eigenvalue <em>elements</em> (must be <span class="math">\(9\times N\)</span>),
<em>how</em> the vector-like and matrix-like parts transform under application
of a symmetry operation,
which scalar cost function should be used,
and which vector cost function should be used.
See the note below fore the meaning of the last three values.</p>
</dd>
<dt>values_weights<span class="classifier">float, vector-like</span></dt><dd><p>The relative cost weights between scalar-, vector-, and matrix- like
eigenvalue elements stored in the grid</p>
</dd>
<dt>vectors_data<span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></span></dt><dd><p>The eigenvector data to be stored in the grid. Same shape restrictions as
<cite>values_data</cite></p>
</dd>
<dt>vectors_elements:</dt><dd><p>Like <cite>values_elements</cite> but for the eigenvectors</p>
</dd>
<dt>vectors_weights<span class="classifier">float, vector-like</span></dt><dd><p>The relative cost weights between scalar-, vector-, and matrix- like
eigenvector elements stored in the grid</p>
</dd>
<dt>sort<span class="classifier">logical (default False)</span></dt><dd><p>Whether the equivalent-mode permutations should be (re)determined following
the update to the flags and weights.</p>
</dd>
</dl>
<blockquote>
<div><p>Mapping of integers to <code class="xref py py-mod docutils literal notranslate"><span class="pre">RotatesLike</span></code> values:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 15%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><code class="xref py py-mod docutils literal notranslate"><span class="pre">RotatesLike</span></code></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>Real</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>Reciprocal</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>Axial</cite></p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p><cite>Gamma</cite></p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to scalar cost function:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(x,y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>magnitude(x-y)</p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to vector cost function:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 16%" />
<col style="width: 84%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(vec_x, vec_y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>sin(hermitian_angle(vec_x, vec_y))</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>vector_distance(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>1 - vector_product(vec_x, vec_y)</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>vector_angle(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>hermitian_angle(vec_x, vec_y)</p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 0.</p>
</div></blockquote>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt id="brille._brille.BZNestQdc.ir_interpolate_at">
<code class="sig-name descname">ir_interpolate_at</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span><span class="p">:</span> <span class="n"><a class="reference internal" href="../undoc_brille.html#brille._brille.BZNestQdc" title="brille._brille.BZNestQdc">brille._brille.BZNestQdc</a></span></em>, <em class="sig-param"><span class="n">Q</span><span class="p">:</span> <span class="n">numpy.ndarray<span class="p">[</span>numpy.float64<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">useparallel</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">threads</span><span class="p">:</span> <span class="n">int</span> <span class="o">=</span> <span class="default_value">- 1</span></em>, <em class="sig-param"><span class="n">do_not_move_points</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em><span class="sig-paren">)</span> &#x2192; Tuple<span class="p">[</span>numpy.ndarray<span class="p">[</span>numpy.float64<span class="p">]</span><span class="p">, </span>numpy.ndarray<span class="p">[</span>numpy.complex128<span class="p">]</span><span class="p">]</span><a class="headerlink" href="#brille._brille.BZNestQdc.ir_interpolate_at" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform linear interpolation of the stored data at irreducible equivalent points</p>
<p>The irreducible first Brillouin zone is the part of reciprocal space which is
invariant under application of the integer translations <em>and</em> the pointgroup
operations of a reciprocal space lattice. This method finds points equivalent
to the input within the irreducible first Brillouin zone and then interpolates
pre-stored information to provide an estimate at the found positions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Q</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>) – A two dimensional array with <cite>Q.shape[1] == 3</cite> containing the positions at
which an interpolated result is required, expressed in units of the
reciprocal lattice.</p></li>
<li><p><strong>useparallel</strong> (<em>bool, optional</em>) – Whether a serial or parallel code should be utilised</p></li>
<li><p><strong>threads</strong> (<em>int, optional</em>) – How many OpenMP workers should be utilised; if this value is less than one
the environment variable <cite>OMP_NUM_THREADS</cite> will be used.</p></li>
<li><p><strong>do_not_move_points</strong> (<em>bool, optional</em>) – If <cite>True</cite> the provided <cite>Q</cite> points must already lie within the first Brillouin
zone. No check is made to verify this requirement and if any <cite>Q</cite> lie outside
of the gridded volume out-of-bounds errors may result in bad data or runtime
errors.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The interpolated eigenvalues and eigenvectors at the equivalent
irreducible first Brillouin zone points.
The shape of each output will depend on the shape of the data provided to
the <cite>fill</cite> method. If the filled eigenvalues were of shape
<cite>[N_grid_points, N_modes, A, …, B]</cite>, the eigenvectors were of shape
<cite>[N_grid_points, N_modes, C, …, D]</cite>, and the provided points of shape
<cite>[N_Q_points, 3]</cite> then the output shapes will be
<cite>[N_Q_points, N_modes, A, …, B]</cite> and <cite>[N_Q_points, N_modes, C, …, D]</cite>
for the eigenvalues and eigenvectors, respectively.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="brille._brille.BZNestQdc.ir_interpolate_at_dw">
<code class="sig-name descname">ir_interpolate_at_dw</code><span class="sig-paren">(</span><em class="sig-param">self: brille._brille.BZNestQdc, Q: numpy.ndarray[numpy.float64], M/amu: numpy.ndarray[numpy.float64], temperature/K: float, useparallel: bool = False, threads: int = -1, do_not_move_points: bool = False</em><span class="sig-paren">)</span> &#x2192; Tuple<span class="p">[</span>numpy.ndarray<span class="p">[</span>numpy.float64<span class="p">]</span><span class="p">, </span>numpy.ndarray<span class="p">[</span>numpy.complex128<span class="p">]</span><span class="p">, </span>numpy.ndarray<span class="p">[</span>numpy.float64<span class="p">]</span><span class="p">]</span><a class="headerlink" href="#brille._brille.BZNestQdc.ir_interpolate_at_dw" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform both the linear interpolation and Debye Waller calculation</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Q</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>) – A two dimensional array with <cite>Q.shape[1] == 3</cite> containing the positions at
which an interpolated result is required, expressed in units of the
reciprocal lattice.</p></li>
<li><p><strong>M</strong> (<em>vector like</em>) – The masses of atoms in the lattice basis in Atomic Mass Units (amu)</p></li>
<li><p><strong>temperature</strong> (<em>float</em>) – The temperature at which to perform the Debye Waller calculation</p></li>
<li><p><strong>useparallel</strong> (<em>bool, optional</em>) – Whether a serial or parallel code should be utilised</p></li>
<li><p><strong>threads</strong> (<em>int, optional</em>) – How many OpenMP workers should be utilised; if this value is less than one
the environment variable <cite>OMP_NUM_THREADS</cite> will be used.</p></li>
<li><p><strong>do_not_move_points</strong> (<em>bool, optional</em>) – If <cite>True</cite> the provided <cite>Q</cite> points must already lie within the first Brillouin
zone. No check is made to verify this requirement and if any <cite>Q</cite> lie outside
of the gridded volume out-of-bounds errors may result in bad data or runtime
errors.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The interpolated eigenvalues and eigenvectors at the equivalent
irreducible first Brillouin zone points, and the result of the
Debye-Waller calculation at the input Q points.
The shape of each output will depend on the shape of the data provided to
the <cite>fill</cite> method. If the filled eigenvalues were of shape
<cite>[N_grid_points, N_modes, A, …, B]</cite>, the eigenvectors were of shape
<cite>[N_grid_points, N_modes, C, …, D]</cite>, and the provided points of shape
<cite>[N_Q_points, 3]</cite> then the output shapes will be
<cite>[N_Q_points, N_modes, A, …, B]</cite> and <cite>[N_Q_points, N_modes, C, …, D]</cite>
for the eigenvalues and eigenvectors, respectively.
The Debye Waller result is always a <cite>[N_Q_points]</cite> vector.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="brille._brille.BZNestQdc.set_flags_weights">
<code class="sig-name descname">set_flags_weights</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span><span class="p">:</span> <span class="n"><a class="reference internal" href="../undoc_brille.html#brille._brille.BZNestQdc" title="brille._brille.BZNestQdc">brille._brille.BZNestQdc</a></span></em>, <em class="sig-param"><span class="n">values_flags</span><span class="p">:</span> <span class="n">numpy.ndarray<span class="p">[</span>numpy.int32<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">values_weights</span><span class="p">:</span> <span class="n">numpy.ndarray<span class="p">[</span>numpy.float64<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">vectors_flags</span><span class="p">:</span> <span class="n">numpy.ndarray<span class="p">[</span>numpy.int32<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">vectors_weights</span><span class="p">:</span> <span class="n">numpy.ndarray<span class="p">[</span>numpy.float64<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">sort</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#brille._brille.BZNestQdc.set_flags_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Set RotatesLike and cost functions plus relative cost weights for the
values and vectors stored in the object</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>values_flags</strong> (<em>integer, vector-like</em>) – One or more values indicating the <code class="xref py py-mod docutils literal notranslate"><span class="pre">RotatesLike</span></code>
value for the eigenvalues stored in the object, plus which cost function
to use when comparing stored eigenvalues at neighbouring grid points for
scalar- and vector-like eigenvalues.</p></li>
<li><p><strong>values_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvalue elements stored in the grid</p></li>
<li><p><strong>vectors_flags</strong> (<em>integer, vector-like</em>) – One or more values indicating the <code class="xref py py-mod docutils literal notranslate"><span class="pre">RotatesLike</span></code>
value for the eigenvectors stored in the object, plus which cost function
to use when comparing stored eigenvectors at neighbouring grid points for
scalar- and vector-like eigenvectors.</p></li>
<li><p><strong>vectors_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvector elements stored in the grid</p></li>
<li><p><strong>sort</strong> (<em>bool, optional</em>) – Whether the equivalent-mode permutations should be (re)determined following
the update to the flags and weights.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Mapping of integers to <code class="xref py py-mod docutils literal notranslate"><span class="pre">RotatesLike</span></code> values:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 15%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><code class="xref py py-mod docutils literal notranslate"><span class="pre">RotatesLike</span></code></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>Real</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>Reciprocal</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>Axial</cite></p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p><cite>Gamma</cite></p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to scalar cost function:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(x,y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>magnitude(x-y)</p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to vector cost function:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 16%" />
<col style="width: 84%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(vec_x, vec_y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>sin(hermitian_angle(vec_x, vec_y))</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>vector_distance(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>1 - vector_product(vec_x, vec_y)</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>vector_angle(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>hermitian_angle(vec_x, vec_y)</p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 0.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="brille._brille.BZNestQdc.sort">
<code class="sig-name descname">sort</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span><span class="p">:</span> <span class="n"><a class="reference internal" href="../undoc_brille.html#brille._brille.BZNestQdc" title="brille._brille.BZNestQdc">brille._brille.BZNestQdc</a></span></em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#brille._brille.BZNestQdc.sort" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="brille._brille.BZNestQdc.values">
<em class="property">property </em><code class="sig-name descname">values</code><a class="headerlink" href="#brille._brille.BZNestQdc.values" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a shared view of the stored eigenvalues</p>
</dd></dl>

<dl class="py method">
<dt id="brille._brille.BZNestQdc.vectors">
<em class="property">property </em><code class="sig-name descname">vectors</code><a class="headerlink" href="#brille._brille.BZNestQdc.vectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a shared view of the stored eigenvectors</p>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="hybrid-grids">
<span id="id1"></span><h2>Hybrid grids<a class="headerlink" href="#hybrid-grids" title="Permalink to this headline">¶</a></h2>
<p>A hybrid grid employs both a regular grid of parallelpipeds and, where the regular grid
passes the Brillouin zone boundary, indvidually triangulated cells.
This enables fast location of the cell containing any interpolation point and, if it
is triangulated, subsequent fast location of the containing tetrahedron.</p>
<div class="figure">
<p><img src="../_images/tikz-a450bd1beb5d81714a5f1534187864aca2a5136d.png" alt="\begin{tikzpicture}[scale=3,%
    dot/.style = {radius=0.0133},
    cell/.style = {color=black},
  s0/.style = {color=red, fill=red!50!white},
  s1/.style = {color=blue, fill=blue!50!white},
  s2/.style = {color=green!50!black, fill=green!50!black!50!white},
  s3/.style = {color=orange, fill=orange!50!white},
  c0/.style = {color=purple, fill=purple!50!white},
  c1/.style = {color=yellow!50!green, fill=yellow!50!green!50!white},
  c2/.style = {color=teal, fill=teal!50!white},
]
\draw[step=2.8867513459mm, color=black!30!white, dashed, very thin] (0,0) grid (0.9,1.05);
\foreach \i in {0,...,3} {\foreach \j in {0,...,4} {\coordinate (g\i\j) at (0.28867513459*\i, 0.28867513459*\j);}}
% BZ boundary points
\coordinate (BZ1) at (30:1);
\coordinate (BZ0) at ($(BZ1) +(0,-0.5)$);
\coordinate (BZ2) at (90:1);
% Brillouin zone boundary
\draw[color=yellow!75!black, line width=1mm] (BZ0) -- (BZ1) -- (BZ2);
% regular cell points
\coordinate (dx) at (2.8867513459mm, 0);
\coordinate (dy) at (0, 2.8867513459mm);
% extra triangulation points
\coordinate (e0) at (BZ1);
\coordinate (e1) at ($0.54*(g32)+0.46*(g22)$);
\coordinate (e2) at ($(BZ1)+(150:0.333333)$);
\coordinate (e3) at ($(BZ1)+(150:0.666667)$);
\coordinate (e4) at ($0.80*(g13)+0.20*(g03)$);
\coordinate (e5) at (BZ2);
% 'regular' interpolation points
\coordinate (r0) at (g10);
\coordinate (r1) at (g20);
\coordinate (r2) at (g21);
\coordinate (r3) at (g11);
% 'simplex' interpolation points
\coordinate (t0) at (g12);
\coordinate (t1) at (e2);
\coordinate (t2) at (e3);
% x1
\coordinate (x1) at ($0.25*(t0)+0.33*(t1)+0.42*(t2)$);
\fill[c2] (t0) -- (t1) -- (x1) -- cycle;
\fill[c0] (t1) -- (t2) -- (x1) -- cycle;
\fill[c1] (t2) -- (t0) -- (x1) -- cycle;
% x2
\coordinate (x2) at ($0.15*(r0) + 0.39*(r1) + 0.06*(r2) + 0.4*(r3)$);
\fill[s0] (r2) rectangle (x2);
\fill[s1] (r3) rectangle (x2);
\fill[s2] (r0) rectangle (x2);
\fill[s3] (r1) rectangle (x2);
% full cells
\foreach \pt in {(g00), (g10), (g20), (g01), (g11)} { \draw[cell] \pt rectangle +(g11); }
% triangulated cells
\draw [cell] (e1) -- (e0) -- (g31) -- (e1) -- (g21);
\draw [cell] (e1) -- (g22) -- (e2) -- cycle;
\draw [cell] (e2) -- (g22) -- (g12) -- (e2) -- (e3) -- (g12) -- cycle;
\draw [cell] (g03) -- (g02) -- (e3) -- (g03) -- (e4) -- (e3);
\draw [cell] (e4) -- (g03) -- (e5) -- cycle;
% mesh/grid points
\foreach \pt in {(x1), (x2)} {\draw [fill=white] \pt circle[dot];}
\foreach \i in {0,...,2} {\draw[c\i] (t\i) circle[dot];}
\foreach \i in {0,...,3} {\draw[s\i] (r\i) circle[dot];}
\foreach \pt in {(g00), (g30), (g31), (g01), (g02), (g22), (g03), (e0), (e1), (e4), (e5)} {\draw[fill=lightgray] \pt circle[dot];}
\end{tikzpicture}" /></p>
</div><p>The three exposed hybrid grid implementations have the same set of methods and are:</p>
<dl class="py class">
<dt id="brille._brille.BZTrellisQdd">
<em class="property">class </em><code class="sig-prename descclassname">brille._brille.</code><code class="sig-name descname">BZTrellisQdd</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span><span class="p">:</span> <span class="n"><a class="reference internal" href="../undoc_brille.html#brille._brille.BZTrellisQdd" title="brille._brille.BZTrellisQdd">brille._brille.BZTrellisQdd</a></span></em>, <em class="sig-param"><span class="n">brillouinzone</span><span class="p">:</span> <span class="n"><a class="reference internal" href="../undoc_brille.html#brille._brille.BrillouinZone" title="brille._brille.BrillouinZone">brille._brille.BrillouinZone</a></span></em>, <em class="sig-param"><span class="n">node_volume_fraction</span><span class="p">:</span> <span class="n">float</span> <span class="o">=</span> <span class="default_value">0.1</span></em>, <em class="sig-param"><span class="n">always_triangulate</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#brille._brille.BZTrellisQdd" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt id="brille._brille.BZTrellisQcc">
<em class="property">class </em><code class="sig-prename descclassname">brille._brille.</code><code class="sig-name descname">BZTrellisQcc</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span><span class="p">:</span> <span class="n"><a class="reference internal" href="../undoc_brille.html#brille._brille.BZTrellisQcc" title="brille._brille.BZTrellisQcc">brille._brille.BZTrellisQcc</a></span></em>, <em class="sig-param"><span class="n">brillouinzone</span><span class="p">:</span> <span class="n"><a class="reference internal" href="../undoc_brille.html#brille._brille.BrillouinZone" title="brille._brille.BrillouinZone">brille._brille.BrillouinZone</a></span></em>, <em class="sig-param"><span class="n">node_volume_fraction</span><span class="p">:</span> <span class="n">float</span> <span class="o">=</span> <span class="default_value">0.1</span></em>, <em class="sig-param"><span class="n">always_triangulate</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#brille._brille.BZTrellisQcc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py class">
<dt id="brille._brille.BZTrellisQdc">
<em class="property">class </em><code class="sig-prename descclassname">brille._brille.</code><code class="sig-name descname">BZTrellisQdc</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span><span class="p">:</span> <span class="n"><a class="reference internal" href="../undoc_brille.html#brille._brille.BZTrellisQdc" title="brille._brille.BZTrellisQdc">brille._brille.BZTrellisQdc</a></span></em>, <em class="sig-param"><span class="n">brillouinzone</span><span class="p">:</span> <span class="n"><a class="reference internal" href="../undoc_brille.html#brille._brille.BrillouinZone" title="brille._brille.BrillouinZone">brille._brille.BrillouinZone</a></span></em>, <em class="sig-param"><span class="n">node_volume_fraction</span><span class="p">:</span> <span class="n">float</span> <span class="o">=</span> <span class="default_value">0.1</span></em>, <em class="sig-param"><span class="n">always_triangulate</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#brille._brille.BZTrellisQdc" title="Permalink to this definition">¶</a></dt>
<dd><dl class="py method">
<dt id="brille._brille.BZTrellisQdc.bytes_per_point">
<em class="property">property </em><code class="sig-name descname">bytes_per_point</code><a class="headerlink" href="#brille._brille.BZTrellisQdc.bytes_per_point" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the memory required per interpolation point <em>result</em> in bytes</p>
</dd></dl>

<dl class="py method">
<dt id="brille._brille.BZTrellisQdc.debye_waller">
<code class="sig-name descname">debye_waller</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span><span class="p">:</span> <span class="n"><a class="reference internal" href="../undoc_brille.html#brille._brille.BZTrellisQdc" title="brille._brille.BZTrellisQdc">brille._brille.BZTrellisQdc</a></span></em>, <em class="sig-param"><span class="n">Q</span><span class="p">:</span> <span class="n">numpy.ndarray<span class="p">[</span>numpy.float64<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">masses</span><span class="p">:</span> <span class="n">numpy.ndarray<span class="p">[</span>numpy.float64<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">Temperature_in_K</span><span class="p">:</span> <span class="n">float</span></em><span class="sig-paren">)</span> &#x2192; numpy.ndarray<span class="p">[</span>numpy.float64<span class="p">]</span><a class="headerlink" href="#brille._brille.BZTrellisQdc.debye_waller" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the Debye-Waller factor by integrating over the Brillouin zone grid</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pyX</strong> (<em>float, array_like</em>) – A two dimensional array with <cite>Q.shape[1] == 3</cite> containing the positions at
which to calculate the Debye-Waller factor</p></li>
<li><p><strong>pyM</strong> (<em>float, array_like</em>) – The atom masses in Atomic Mass Units, matching the atom types provided to
the <a class="reference internal" href="../undoc_brille.html#brille._brille.Direct" title="brille._brille.Direct"><code class="xref py py-class docutils literal notranslate"><span class="pre">Direct</span></code></a> constructor for the crystal basis</p></li>
<li><p><strong>temp_K</strong> (<em>float</em>) – The temperature at which to calculate the Debye-Waller factor in Kelvin</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A one-dimensional array of the Debye-Waller factor evaluated at each input</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="brille._brille.BZTrellisQdc.fill">
<code class="sig-name descname">fill</code><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille._brille.BZTrellisQdc.fill" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>fill(self: brille._brille.BZTrellisQdc, values_data: numpy.ndarray[numpy.float64], values_elements: numpy.ndarray[numpy.int32], vectors_data: numpy.ndarray[numpy.complex128], vectors_elements: numpy.ndarray[numpy.int32], sort: bool = False) -&gt; None</p></li>
</ol>
<blockquote>
<div><p>Provide data required for interpolation to the grid without cost information.</p>
<p>This method should probably be followed by <code class="xref py py-meth docutils literal notranslate"><span class="pre">set_cost_info()</span></code> prior to
any attempt to interpolate the data in the grid.</p>
<dl>
<dt>values_data<span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></span></dt><dd><p>The eigenvalue data to be stored in the grid. The first dimension must be
equal in size to the number of grid-vertices. If two dimensional the second
dimension is interpreted as all information for a single mode flattened
and concatenated into (scalars, vectors, matrices) – in that order.
If more than two dimensional, the second dimension indexes modes and
higher dimensions will be flattend <em>as if row ordered</em> and must flatten into
a concatenated list of (scalars, vectors, matrices).
If the provided array can be interpreted as a contiguous row-ordered two
dimensional array it will be used in place, otherwise a copy will be made.</p>
</dd>
<dt>values_elements: integer vector-like</dt><dd><p>A multi-purpose vector containing, in order,
the number of scalar-like eigenvalue elements,
the number of vector-like eigenvalue <em>elements</em> (must be <span class="math">\(3\times N\)</span>),
the number of matrix-like eigenvalue <em>elements</em> (must be <span class="math">\(9\times N\)</span>),
and
<em>how</em> the vector-like and matrix-like parts transform under application
of a symmetry operation,
See the note below fore the meaning of the last three value.
Any extra entries are ignored.</p>
</dd>
<dt>vectors_data<span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></span></dt><dd><p>The eigenvector data to be stored in the grid. Same shape restrictions as
<cite>values_data</cite></p>
</dd>
<dt>vectors_elements:</dt><dd><p>Like <cite>values_elements</cite> but for the eigenvectors</p>
</dd>
<dt>sort<span class="classifier">logical (default False)</span></dt><dd><p>Whether the equivalent-mode permutations should be (re)determined following
the update to the flags and weights.</p>
</dd>
</dl>
<blockquote>
<div><p>Mapping of integers to <code class="xref py py-mod docutils literal notranslate"><span class="pre">RotatesLike</span></code> values:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 15%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><code class="xref py py-mod docutils literal notranslate"><span class="pre">RotatesLike</span></code></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>Real</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>Reciprocal</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>Axial</cite></p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p><cite>Gamma</cite></p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 0.</p>
</div></blockquote>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>fill(self: brille._brille.BZTrellisQdc, values_data: numpy.ndarray[numpy.float64], values_elements: numpy.ndarray[numpy.int32], values_weights: numpy.ndarray[numpy.float64], vectors_data: numpy.ndarray[numpy.complex128], vectors_elements: numpy.ndarray[numpy.int32], vectors_weights: numpy.ndarray[numpy.float64], sort: bool = False) -&gt; None</p></li>
</ol>
<blockquote>
<div><p>Provide all data required for interpolation to the grid at once</p>
<dl>
<dt>values_data<span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></span></dt><dd><p>The eigenvalue data to be stored in the grid. The first dimension must be
equal in size to the number of grid-vertices. If two dimensional the second
dimension is interpreted as all information for a single mode flattened
and concatenated into (scalars, vectors, matrices) – in that order.
If more than two dimensional, the second dimension indexes modes and
higher dimensions will be flattend <em>as if row ordered</em> and must flatten into
a concatenated list of (scalars, vectors, matrices).
If the provided array can be interpreted as a contiguous row-ordered two
dimensional array it will be used in place, otherwise a copy will be made.</p>
</dd>
<dt>values_elements: integer vector-like</dt><dd><p>A multi-purpose vector containing, in order,
the number of scalar-like eigenvalue elements,
the number of vector-like eigenvalue <em>elements</em> (must be <span class="math">\(3\times N\)</span>),
the number of matrix-like eigenvalue <em>elements</em> (must be <span class="math">\(9\times N\)</span>),
<em>how</em> the vector-like and matrix-like parts transform under application
of a symmetry operation,
which scalar cost function should be used,
and which vector cost function should be used.
See the note below fore the meaning of the last three values.</p>
</dd>
<dt>values_weights<span class="classifier">float, vector-like</span></dt><dd><p>The relative cost weights between scalar-, vector-, and matrix- like
eigenvalue elements stored in the grid</p>
</dd>
<dt>vectors_data<span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></span></dt><dd><p>The eigenvector data to be stored in the grid. Same shape restrictions as
<cite>values_data</cite></p>
</dd>
<dt>vectors_elements:</dt><dd><p>Like <cite>values_elements</cite> but for the eigenvectors</p>
</dd>
<dt>vectors_weights<span class="classifier">float, vector-like</span></dt><dd><p>The relative cost weights between scalar-, vector-, and matrix- like
eigenvector elements stored in the grid</p>
</dd>
<dt>sort<span class="classifier">logical (default False)</span></dt><dd><p>Whether the equivalent-mode permutations should be (re)determined following
the update to the flags and weights.</p>
</dd>
</dl>
<blockquote>
<div><p>Mapping of integers to <code class="xref py py-mod docutils literal notranslate"><span class="pre">RotatesLike</span></code> values:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 15%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><code class="xref py py-mod docutils literal notranslate"><span class="pre">RotatesLike</span></code></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>Real</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>Reciprocal</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>Axial</cite></p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p><cite>Gamma</cite></p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to scalar cost function:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(x,y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>magnitude(x-y)</p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to vector cost function:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 16%" />
<col style="width: 84%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(vec_x, vec_y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>sin(hermitian_angle(vec_x, vec_y))</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>vector_distance(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>1 - vector_product(vec_x, vec_y)</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>vector_angle(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>hermitian_angle(vec_x, vec_y)</p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 0.</p>
</div></blockquote>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt id="brille._brille.BZTrellisQdc.interpolate_at">
<code class="sig-name descname">interpolate_at</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span><span class="p">:</span> <span class="n"><a class="reference internal" href="../undoc_brille.html#brille._brille.BZTrellisQdc" title="brille._brille.BZTrellisQdc">brille._brille.BZTrellisQdc</a></span></em>, <em class="sig-param"><span class="n">Q</span><span class="p">:</span> <span class="n">numpy.ndarray<span class="p">[</span>numpy.float64<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">useparallel</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">threads</span><span class="p">:</span> <span class="n">int</span> <span class="o">=</span> <span class="default_value">- 1</span></em>, <em class="sig-param"><span class="n">do_not_move_points</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em><span class="sig-paren">)</span> &#x2192; Tuple<span class="p">[</span>numpy.ndarray<span class="p">[</span>numpy.float64<span class="p">]</span><span class="p">, </span>numpy.ndarray<span class="p">[</span>numpy.complex128<span class="p">]</span><span class="p">]</span><a class="headerlink" href="#brille._brille.BZTrellisQdc.interpolate_at" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform linear interpolation of the stored data at equivalent points</p>
<p>The first Brillouin zone is the part of reciprocal space which is invariant
under application of the integer translations of a reciprocal space lattice.
This method finds points equivalent to the input within the first Brillouin
zone and then interpolates pre-stored information to provide an estimate at
the found positions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Q</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>) – A two dimensional array with <cite>Q.shape[1] == 3</cite> containing the positions at
which an interpolated result is required, expressed in units of the
reciprocal lattice.</p></li>
<li><p><strong>useparallel</strong> (<em>bool, optional</em>) – Whether a serial or parallel code should be utilised</p></li>
<li><p><strong>threads</strong> (<em>int, optional</em>) – How many OpenMP workers should be utilised; if this value is less than one
the environment variable <cite>OMP_NUM_THREADS</cite> will be used.</p></li>
<li><p><strong>do_not_move_points</strong> (<em>bool, optional</em>) – If <cite>True</cite> the provided <cite>Q</cite> points must already lie within the first Brillouin
zone. No check is made to verify this requirement and if any <cite>Q</cite> lie outside
of the gridded volume out-of-bounds errors may result in bad data or runtime
errors.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The interpolated eigenvalues and eigenvectors at the equivalent
first Brillouin zone points.
The shape of each output will depend on the shape of the data provided to
the <cite>fill</cite> method. If the filled eigenvalues were of shape
<cite>[N_grid_points, N_modes, A, …, B]</cite>, the eigenvectors were of shape
<cite>[N_grid_points, N_modes, C, …, D]</cite>, and the provided points of shape
<cite>[N_Q_points, 3]</cite> then the output shapes will be
<cite>[N_Q_points, N_modes, A, …, B]</cite> and <cite>[N_Q_points, N_modes, C, …, D]</cite>
for the eigenvalues and eigenvectors, respectively.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="brille._brille.BZTrellisQdc.ir_interpolate_at">
<code class="sig-name descname">ir_interpolate_at</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span><span class="p">:</span> <span class="n"><a class="reference internal" href="../undoc_brille.html#brille._brille.BZTrellisQdc" title="brille._brille.BZTrellisQdc">brille._brille.BZTrellisQdc</a></span></em>, <em class="sig-param"><span class="n">Q</span><span class="p">:</span> <span class="n">numpy.ndarray<span class="p">[</span>numpy.float64<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">useparallel</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em>, <em class="sig-param"><span class="n">threads</span><span class="p">:</span> <span class="n">int</span> <span class="o">=</span> <span class="default_value">- 1</span></em>, <em class="sig-param"><span class="n">do_not_move_points</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em><span class="sig-paren">)</span> &#x2192; Tuple<span class="p">[</span>numpy.ndarray<span class="p">[</span>numpy.float64<span class="p">]</span><span class="p">, </span>numpy.ndarray<span class="p">[</span>numpy.complex128<span class="p">]</span><span class="p">]</span><a class="headerlink" href="#brille._brille.BZTrellisQdc.ir_interpolate_at" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform linear interpolation of the stored data at irreducible equivalent points</p>
<p>The irreducible first Brillouin zone is the part of reciprocal space which is
invariant under application of the integer translations <em>and</em> the pointgroup
operations of a reciprocal space lattice. This method finds points equivalent
to the input within the irreducible first Brillouin zone and then interpolates
pre-stored information to provide an estimate at the found positions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Q</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>) – A two dimensional array with <cite>Q.shape[1] == 3</cite> containing the positions at
which an interpolated result is required, expressed in units of the
reciprocal lattice.</p></li>
<li><p><strong>useparallel</strong> (<em>bool, optional</em>) – Whether a serial or parallel code should be utilised</p></li>
<li><p><strong>threads</strong> (<em>int, optional</em>) – How many OpenMP workers should be utilised; if this value is less than one
the environment variable <cite>OMP_NUM_THREADS</cite> will be used.</p></li>
<li><p><strong>do_not_move_points</strong> (<em>bool, optional</em>) – If <cite>True</cite> the provided <cite>Q</cite> points must already lie within the first Brillouin
zone. No check is made to verify this requirement and if any <cite>Q</cite> lie outside
of the gridded volume out-of-bounds errors may result in bad data or runtime
errors.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The interpolated eigenvalues and eigenvectors at the equivalent
irreducible first Brillouin zone points.
The shape of each output will depend on the shape of the data provided to
the <cite>fill</cite> method. If the filled eigenvalues were of shape
<cite>[N_grid_points, N_modes, A, …, B]</cite>, the eigenvectors were of shape
<cite>[N_grid_points, N_modes, C, …, D]</cite>, and the provided points of shape
<cite>[N_Q_points, 3]</cite> then the output shapes will be
<cite>[N_Q_points, N_modes, A, …, B]</cite> and <cite>[N_Q_points, N_modes, C, …, D]</cite>
for the eigenvalues and eigenvectors, respectively.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="brille._brille.BZTrellisQdc.ir_interpolate_at_dw">
<code class="sig-name descname">ir_interpolate_at_dw</code><span class="sig-paren">(</span><em class="sig-param">self: brille._brille.BZTrellisQdc, Q: numpy.ndarray[numpy.float64], M/amu: numpy.ndarray[numpy.float64], temperature/K: float, useparallel: bool = False, threads: int = -1, do_not_move_points: bool = False</em><span class="sig-paren">)</span> &#x2192; Tuple<span class="p">[</span>numpy.ndarray<span class="p">[</span>numpy.float64<span class="p">]</span><span class="p">, </span>numpy.ndarray<span class="p">[</span>numpy.complex128<span class="p">]</span><span class="p">, </span>numpy.ndarray<span class="p">[</span>numpy.float64<span class="p">]</span><span class="p">]</span><a class="headerlink" href="#brille._brille.BZTrellisQdc.ir_interpolate_at_dw" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform both the linear interpolation and Debye Waller calculation</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Q</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>) – A two dimensional array with <cite>Q.shape[1] == 3</cite> containing the positions at
which an interpolated result is required, expressed in units of the
reciprocal lattice.</p></li>
<li><p><strong>M</strong> (<em>vector like</em>) – The masses of atoms in the lattice basis in Atomic Mass Units (amu)</p></li>
<li><p><strong>temperature</strong> (<em>float</em>) – The temperature at which to perform the Debye Waller calculation</p></li>
<li><p><strong>useparallel</strong> (<em>bool, optional</em>) – Whether a serial or parallel code should be utilised</p></li>
<li><p><strong>threads</strong> (<em>int, optional</em>) – How many OpenMP workers should be utilised; if this value is less than one
the environment variable <cite>OMP_NUM_THREADS</cite> will be used.</p></li>
<li><p><strong>do_not_move_points</strong> (<em>bool, optional</em>) – If <cite>True</cite> the provided <cite>Q</cite> points must already lie within the first Brillouin
zone. No check is made to verify this requirement and if any <cite>Q</cite> lie outside
of the gridded volume out-of-bounds errors may result in bad data or runtime
errors.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The interpolated eigenvalues and eigenvectors at the equivalent
irreducible first Brillouin zone points, and the result of the
Debye-Waller calculation at the input Q points.
The shape of each output will depend on the shape of the data provided to
the <cite>fill</cite> method. If the filled eigenvalues were of shape
<cite>[N_grid_points, N_modes, A, …, B]</cite>, the eigenvectors were of shape
<cite>[N_grid_points, N_modes, C, …, D]</cite>, and the provided points of shape
<cite>[N_Q_points, 3]</cite> then the output shapes will be
<cite>[N_Q_points, N_modes, A, …, B]</cite> and <cite>[N_Q_points, N_modes, C, …, D]</cite>
for the eigenvalues and eigenvectors, respectively.
The Debye Waller result is always a <cite>[N_Q_points]</cite> vector.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt id="brille._brille.BZTrellisQdc.set_flags_weights">
<code class="sig-name descname">set_flags_weights</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span><span class="p">:</span> <span class="n"><a class="reference internal" href="../undoc_brille.html#brille._brille.BZTrellisQdc" title="brille._brille.BZTrellisQdc">brille._brille.BZTrellisQdc</a></span></em>, <em class="sig-param"><span class="n">values_flags</span><span class="p">:</span> <span class="n">numpy.ndarray<span class="p">[</span>numpy.int32<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">values_weights</span><span class="p">:</span> <span class="n">numpy.ndarray<span class="p">[</span>numpy.float64<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">vectors_flags</span><span class="p">:</span> <span class="n">numpy.ndarray<span class="p">[</span>numpy.int32<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">vectors_weights</span><span class="p">:</span> <span class="n">numpy.ndarray<span class="p">[</span>numpy.float64<span class="p">]</span></span></em>, <em class="sig-param"><span class="n">sort</span><span class="p">:</span> <span class="n">bool</span> <span class="o">=</span> <span class="default_value">False</span></em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#brille._brille.BZTrellisQdc.set_flags_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Set RotatesLike and cost functions plus relative cost weights for the
values and vectors stored in the object</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>values_flags</strong> (<em>integer, vector-like</em>) – One or more values indicating the <code class="xref py py-mod docutils literal notranslate"><span class="pre">RotatesLike</span></code>
value for the eigenvalues stored in the object, plus which cost function
to use when comparing stored eigenvalues at neighbouring grid points for
scalar- and vector-like eigenvalues.</p></li>
<li><p><strong>values_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvalue elements stored in the grid</p></li>
<li><p><strong>vectors_flags</strong> (<em>integer, vector-like</em>) – One or more values indicating the <code class="xref py py-mod docutils literal notranslate"><span class="pre">RotatesLike</span></code>
value for the eigenvectors stored in the object, plus which cost function
to use when comparing stored eigenvectors at neighbouring grid points for
scalar- and vector-like eigenvectors.</p></li>
<li><p><strong>vectors_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvector elements stored in the grid</p></li>
<li><p><strong>sort</strong> (<em>bool, optional</em>) – Whether the equivalent-mode permutations should be (re)determined following
the update to the flags and weights.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Mapping of integers to <code class="xref py py-mod docutils literal notranslate"><span class="pre">RotatesLike</span></code> values:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 15%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><code class="xref py py-mod docutils literal notranslate"><span class="pre">RotatesLike</span></code></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>Real</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>Reciprocal</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>Axial</cite></p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p><cite>Gamma</cite></p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to scalar cost function:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(x,y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>magnitude(x-y)</p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to vector cost function:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 16%" />
<col style="width: 84%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(vec_x, vec_y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>sin(hermitian_angle(vec_x, vec_y))</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>vector_distance(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>1 - vector_product(vec_x, vec_y)</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>vector_angle(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>hermitian_angle(vec_x, vec_y)</p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 0.</p>
</div>
</dd></dl>

<dl class="py method">
<dt id="brille._brille.BZTrellisQdc.sort">
<code class="sig-name descname">sort</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span><span class="p">:</span> <span class="n"><a class="reference internal" href="../undoc_brille.html#brille._brille.BZTrellisQdc" title="brille._brille.BZTrellisQdc">brille._brille.BZTrellisQdc</a></span></em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#brille._brille.BZTrellisQdc.sort" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt id="brille._brille.BZTrellisQdc.values">
<em class="property">property </em><code class="sig-name descname">values</code><a class="headerlink" href="#brille._brille.BZTrellisQdc.values" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a shared view of the stored eigenvalues</p>
</dd></dl>

<dl class="py method">
<dt id="brille._brille.BZTrellisQdc.vectors">
<em class="property">property </em><code class="sig-name descname">vectors</code><a class="headerlink" href="#brille._brille.BZTrellisQdc.vectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a shared view of the stored eigenvectors</p>
</dd></dl>

</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="symmetry.html" class="btn btn-neutral float-right" title="Symmetry" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="bz.html" class="btn btn-neutral float-left" title="Brillouin Zone" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020, Gregory Tucker

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
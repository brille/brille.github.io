<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Python module brille &mdash; brille 0.7.1.dev5+g02a0234 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css" />
      <link rel="stylesheet" type="text/css" href="_static/katex-math.css?v=91adb8b6" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=2846aff7"></script>
        <script src="_static/doctools.js?v=9a2dae69"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="_static/katex.min.js?v=be8ff15f"></script>
        <script src="_static/auto-render.min.js?v=ad136472"></script>
        <script src="_static/katex_autorenderer.js?v=bebc588a"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Lattices" href="module/lattice.html" />
    <link rel="prev" title="Specifying a lattice Spacegroup" href="tutorials/tutorial_01.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            brille
              <img src="_static/brille.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.7.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">User documents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="install_guide.html">Installation Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="motivation.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="memory_usage.html">Memory Use</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">User Guide</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API documents</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Python module <code class="xref py py-mod docutils literal notranslate"><span class="pre">brille</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="#brille.AngleUnit"><code class="docutils literal notranslate"><span class="pre">AngleUnit</span></code></a><ul>
<li class="toctree-l2"><a class="reference internal" href="#brille.AngleUnit.degree"><code class="docutils literal notranslate"><span class="pre">AngleUnit.degree</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.AngleUnit.name"><code class="docutils literal notranslate"><span class="pre">AngleUnit.name</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.AngleUnit.not_provided"><code class="docutils literal notranslate"><span class="pre">AngleUnit.not_provided</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.AngleUnit.pi"><code class="docutils literal notranslate"><span class="pre">AngleUnit.pi</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.AngleUnit.radian"><code class="docutils literal notranslate"><span class="pre">AngleUnit.radian</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.AngleUnit.value"><code class="docutils literal notranslate"><span class="pre">AngleUnit.value</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#brille.ApproxConfig"><code class="docutils literal notranslate"><span class="pre">ApproxConfig</span></code></a><ul>
<li class="toctree-l2"><a class="reference internal" href="#brille.ApproxConfig.digits"><code class="docutils literal notranslate"><span class="pre">ApproxConfig.digits</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.ApproxConfig.real_space_tolerance"><code class="docutils literal notranslate"><span class="pre">ApproxConfig.real_space_tolerance</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.ApproxConfig.reciprocal_space_tolerance"><code class="docutils literal notranslate"><span class="pre">ApproxConfig.reciprocal_space_tolerance</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#brille.BZMeshQcc"><code class="docutils literal notranslate"><span class="pre">BZMeshQcc</span></code></a><ul>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZMeshQcc.BrillouinZone"><code class="docutils literal notranslate"><span class="pre">BZMeshQcc.BrillouinZone</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZMeshQcc.bytes_per_point"><code class="docutils literal notranslate"><span class="pre">BZMeshQcc.bytes_per_point</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZMeshQcc.fill"><code class="docutils literal notranslate"><span class="pre">BZMeshQcc.fill()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZMeshQcc.from_file"><code class="docutils literal notranslate"><span class="pre">BZMeshQcc.from_file()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZMeshQcc.invA"><code class="docutils literal notranslate"><span class="pre">BZMeshQcc.invA</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZMeshQcc.ir_interpolate_at"><code class="docutils literal notranslate"><span class="pre">BZMeshQcc.ir_interpolate_at()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZMeshQcc.rlu"><code class="docutils literal notranslate"><span class="pre">BZMeshQcc.rlu</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZMeshQcc.set_flags_weights"><code class="docutils literal notranslate"><span class="pre">BZMeshQcc.set_flags_weights()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZMeshQcc.sort"><code class="docutils literal notranslate"><span class="pre">BZMeshQcc.sort()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZMeshQcc.tetrahedra"><code class="docutils literal notranslate"><span class="pre">BZMeshQcc.tetrahedra</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZMeshQcc.to_file"><code class="docutils literal notranslate"><span class="pre">BZMeshQcc.to_file()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZMeshQcc.values"><code class="docutils literal notranslate"><span class="pre">BZMeshQcc.values</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZMeshQcc.vectors"><code class="docutils literal notranslate"><span class="pre">BZMeshQcc.vectors</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#brille.BZMeshQdc"><code class="docutils literal notranslate"><span class="pre">BZMeshQdc</span></code></a><ul>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZMeshQdc.BrillouinZone"><code class="docutils literal notranslate"><span class="pre">BZMeshQdc.BrillouinZone</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZMeshQdc.bytes_per_point"><code class="docutils literal notranslate"><span class="pre">BZMeshQdc.bytes_per_point</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZMeshQdc.fill"><code class="docutils literal notranslate"><span class="pre">BZMeshQdc.fill()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZMeshQdc.from_file"><code class="docutils literal notranslate"><span class="pre">BZMeshQdc.from_file()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZMeshQdc.invA"><code class="docutils literal notranslate"><span class="pre">BZMeshQdc.invA</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZMeshQdc.ir_interpolate_at"><code class="docutils literal notranslate"><span class="pre">BZMeshQdc.ir_interpolate_at()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZMeshQdc.rlu"><code class="docutils literal notranslate"><span class="pre">BZMeshQdc.rlu</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZMeshQdc.set_flags_weights"><code class="docutils literal notranslate"><span class="pre">BZMeshQdc.set_flags_weights()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZMeshQdc.sort"><code class="docutils literal notranslate"><span class="pre">BZMeshQdc.sort()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZMeshQdc.tetrahedra"><code class="docutils literal notranslate"><span class="pre">BZMeshQdc.tetrahedra</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZMeshQdc.to_file"><code class="docutils literal notranslate"><span class="pre">BZMeshQdc.to_file()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZMeshQdc.values"><code class="docutils literal notranslate"><span class="pre">BZMeshQdc.values</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZMeshQdc.vectors"><code class="docutils literal notranslate"><span class="pre">BZMeshQdc.vectors</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#brille.BZMeshQdd"><code class="docutils literal notranslate"><span class="pre">BZMeshQdd</span></code></a><ul>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZMeshQdd.BrillouinZone"><code class="docutils literal notranslate"><span class="pre">BZMeshQdd.BrillouinZone</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZMeshQdd.bytes_per_point"><code class="docutils literal notranslate"><span class="pre">BZMeshQdd.bytes_per_point</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZMeshQdd.fill"><code class="docutils literal notranslate"><span class="pre">BZMeshQdd.fill()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZMeshQdd.from_file"><code class="docutils literal notranslate"><span class="pre">BZMeshQdd.from_file()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZMeshQdd.invA"><code class="docutils literal notranslate"><span class="pre">BZMeshQdd.invA</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZMeshQdd.ir_interpolate_at"><code class="docutils literal notranslate"><span class="pre">BZMeshQdd.ir_interpolate_at()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZMeshQdd.rlu"><code class="docutils literal notranslate"><span class="pre">BZMeshQdd.rlu</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZMeshQdd.set_flags_weights"><code class="docutils literal notranslate"><span class="pre">BZMeshQdd.set_flags_weights()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZMeshQdd.sort"><code class="docutils literal notranslate"><span class="pre">BZMeshQdd.sort()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZMeshQdd.tetrahedra"><code class="docutils literal notranslate"><span class="pre">BZMeshQdd.tetrahedra</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZMeshQdd.to_file"><code class="docutils literal notranslate"><span class="pre">BZMeshQdd.to_file()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZMeshQdd.values"><code class="docutils literal notranslate"><span class="pre">BZMeshQdd.values</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZMeshQdd.vectors"><code class="docutils literal notranslate"><span class="pre">BZMeshQdd.vectors</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#brille.BZNestQcc"><code class="docutils literal notranslate"><span class="pre">BZNestQcc</span></code></a><ul>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZNestQcc.BrillouinZone"><code class="docutils literal notranslate"><span class="pre">BZNestQcc.BrillouinZone</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZNestQcc.all_invA"><code class="docutils literal notranslate"><span class="pre">BZNestQcc.all_invA</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZNestQcc.all_rlu"><code class="docutils literal notranslate"><span class="pre">BZNestQcc.all_rlu</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZNestQcc.bytes_per_point"><code class="docutils literal notranslate"><span class="pre">BZNestQcc.bytes_per_point</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZNestQcc.fill"><code class="docutils literal notranslate"><span class="pre">BZNestQcc.fill()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZNestQcc.from_file"><code class="docutils literal notranslate"><span class="pre">BZNestQcc.from_file()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZNestQcc.invA"><code class="docutils literal notranslate"><span class="pre">BZNestQcc.invA</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZNestQcc.ir_interpolate_at"><code class="docutils literal notranslate"><span class="pre">BZNestQcc.ir_interpolate_at()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZNestQcc.rlu"><code class="docutils literal notranslate"><span class="pre">BZNestQcc.rlu</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZNestQcc.set_flags_weights"><code class="docutils literal notranslate"><span class="pre">BZNestQcc.set_flags_weights()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZNestQcc.sort"><code class="docutils literal notranslate"><span class="pre">BZNestQcc.sort()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZNestQcc.tetrahedra"><code class="docutils literal notranslate"><span class="pre">BZNestQcc.tetrahedra</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZNestQcc.to_file"><code class="docutils literal notranslate"><span class="pre">BZNestQcc.to_file()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZNestQcc.values"><code class="docutils literal notranslate"><span class="pre">BZNestQcc.values</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZNestQcc.vectors"><code class="docutils literal notranslate"><span class="pre">BZNestQcc.vectors</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#brille.BZNestQdc"><code class="docutils literal notranslate"><span class="pre">BZNestQdc</span></code></a><ul>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZNestQdc.BrillouinZone"><code class="docutils literal notranslate"><span class="pre">BZNestQdc.BrillouinZone</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZNestQdc.all_invA"><code class="docutils literal notranslate"><span class="pre">BZNestQdc.all_invA</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZNestQdc.all_rlu"><code class="docutils literal notranslate"><span class="pre">BZNestQdc.all_rlu</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZNestQdc.bytes_per_point"><code class="docutils literal notranslate"><span class="pre">BZNestQdc.bytes_per_point</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZNestQdc.fill"><code class="docutils literal notranslate"><span class="pre">BZNestQdc.fill()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZNestQdc.from_file"><code class="docutils literal notranslate"><span class="pre">BZNestQdc.from_file()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZNestQdc.invA"><code class="docutils literal notranslate"><span class="pre">BZNestQdc.invA</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZNestQdc.ir_interpolate_at"><code class="docutils literal notranslate"><span class="pre">BZNestQdc.ir_interpolate_at()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZNestQdc.rlu"><code class="docutils literal notranslate"><span class="pre">BZNestQdc.rlu</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZNestQdc.set_flags_weights"><code class="docutils literal notranslate"><span class="pre">BZNestQdc.set_flags_weights()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZNestQdc.sort"><code class="docutils literal notranslate"><span class="pre">BZNestQdc.sort()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZNestQdc.tetrahedra"><code class="docutils literal notranslate"><span class="pre">BZNestQdc.tetrahedra</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZNestQdc.to_file"><code class="docutils literal notranslate"><span class="pre">BZNestQdc.to_file()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZNestQdc.values"><code class="docutils literal notranslate"><span class="pre">BZNestQdc.values</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZNestQdc.vectors"><code class="docutils literal notranslate"><span class="pre">BZNestQdc.vectors</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#brille.BZNestQdd"><code class="docutils literal notranslate"><span class="pre">BZNestQdd</span></code></a><ul>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZNestQdd.BrillouinZone"><code class="docutils literal notranslate"><span class="pre">BZNestQdd.BrillouinZone</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZNestQdd.all_invA"><code class="docutils literal notranslate"><span class="pre">BZNestQdd.all_invA</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZNestQdd.all_rlu"><code class="docutils literal notranslate"><span class="pre">BZNestQdd.all_rlu</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZNestQdd.bytes_per_point"><code class="docutils literal notranslate"><span class="pre">BZNestQdd.bytes_per_point</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZNestQdd.fill"><code class="docutils literal notranslate"><span class="pre">BZNestQdd.fill()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZNestQdd.from_file"><code class="docutils literal notranslate"><span class="pre">BZNestQdd.from_file()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZNestQdd.invA"><code class="docutils literal notranslate"><span class="pre">BZNestQdd.invA</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZNestQdd.ir_interpolate_at"><code class="docutils literal notranslate"><span class="pre">BZNestQdd.ir_interpolate_at()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZNestQdd.rlu"><code class="docutils literal notranslate"><span class="pre">BZNestQdd.rlu</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZNestQdd.set_flags_weights"><code class="docutils literal notranslate"><span class="pre">BZNestQdd.set_flags_weights()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZNestQdd.sort"><code class="docutils literal notranslate"><span class="pre">BZNestQdd.sort()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZNestQdd.tetrahedra"><code class="docutils literal notranslate"><span class="pre">BZNestQdd.tetrahedra</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZNestQdd.to_file"><code class="docutils literal notranslate"><span class="pre">BZNestQdd.to_file()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZNestQdd.values"><code class="docutils literal notranslate"><span class="pre">BZNestQdd.values</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZNestQdd.vectors"><code class="docutils literal notranslate"><span class="pre">BZNestQdd.vectors</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#brille.BZTrellisQcc"><code class="docutils literal notranslate"><span class="pre">BZTrellisQcc</span></code></a><ul>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQcc.BrillouinZone"><code class="docutils literal notranslate"><span class="pre">BZTrellisQcc.BrillouinZone</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQcc.all_node_types"><code class="docutils literal notranslate"><span class="pre">BZTrellisQcc.all_node_types()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQcc.bytes_per_point"><code class="docutils literal notranslate"><span class="pre">BZTrellisQcc.bytes_per_point</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQcc.fill"><code class="docutils literal notranslate"><span class="pre">BZTrellisQcc.fill()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQcc.from_file"><code class="docutils literal notranslate"><span class="pre">BZTrellisQcc.from_file()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQcc.inner_invA"><code class="docutils literal notranslate"><span class="pre">BZTrellisQcc.inner_invA</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQcc.inner_rlu"><code class="docutils literal notranslate"><span class="pre">BZTrellisQcc.inner_rlu</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQcc.interpolate_at"><code class="docutils literal notranslate"><span class="pre">BZTrellisQcc.interpolate_at()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQcc.invA"><code class="docutils literal notranslate"><span class="pre">BZTrellisQcc.invA</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQcc.ir_interpolate_at"><code class="docutils literal notranslate"><span class="pre">BZTrellisQcc.ir_interpolate_at()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQcc.node_at"><code class="docutils literal notranslate"><span class="pre">BZTrellisQcc.node_at()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQcc.node_at_type"><code class="docutils literal notranslate"><span class="pre">BZTrellisQcc.node_at_type()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQcc.node_containing"><code class="docutils literal notranslate"><span class="pre">BZTrellisQcc.node_containing()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQcc.node_containing_type"><code class="docutils literal notranslate"><span class="pre">BZTrellisQcc.node_containing_type()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQcc.outer_invA"><code class="docutils literal notranslate"><span class="pre">BZTrellisQcc.outer_invA</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQcc.outer_rlu"><code class="docutils literal notranslate"><span class="pre">BZTrellisQcc.outer_rlu</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQcc.rlu"><code class="docutils literal notranslate"><span class="pre">BZTrellisQcc.rlu</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQcc.set_flags_weights"><code class="docutils literal notranslate"><span class="pre">BZTrellisQcc.set_flags_weights()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQcc.sort"><code class="docutils literal notranslate"><span class="pre">BZTrellisQcc.sort()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQcc.tetrahedra"><code class="docutils literal notranslate"><span class="pre">BZTrellisQcc.tetrahedra</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQcc.to_file"><code class="docutils literal notranslate"><span class="pre">BZTrellisQcc.to_file()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQcc.values"><code class="docutils literal notranslate"><span class="pre">BZTrellisQcc.values</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQcc.vectors"><code class="docutils literal notranslate"><span class="pre">BZTrellisQcc.vectors</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#brille.BZTrellisQdc"><code class="docutils literal notranslate"><span class="pre">BZTrellisQdc</span></code></a><ul>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQdc.BrillouinZone"><code class="docutils literal notranslate"><span class="pre">BZTrellisQdc.BrillouinZone</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQdc.all_node_types"><code class="docutils literal notranslate"><span class="pre">BZTrellisQdc.all_node_types()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQdc.bytes_per_point"><code class="docutils literal notranslate"><span class="pre">BZTrellisQdc.bytes_per_point</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQdc.fill"><code class="docutils literal notranslate"><span class="pre">BZTrellisQdc.fill()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQdc.from_file"><code class="docutils literal notranslate"><span class="pre">BZTrellisQdc.from_file()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQdc.inner_invA"><code class="docutils literal notranslate"><span class="pre">BZTrellisQdc.inner_invA</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQdc.inner_rlu"><code class="docutils literal notranslate"><span class="pre">BZTrellisQdc.inner_rlu</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQdc.interpolate_at"><code class="docutils literal notranslate"><span class="pre">BZTrellisQdc.interpolate_at()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQdc.invA"><code class="docutils literal notranslate"><span class="pre">BZTrellisQdc.invA</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQdc.ir_interpolate_at"><code class="docutils literal notranslate"><span class="pre">BZTrellisQdc.ir_interpolate_at()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQdc.node_at"><code class="docutils literal notranslate"><span class="pre">BZTrellisQdc.node_at()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQdc.node_at_type"><code class="docutils literal notranslate"><span class="pre">BZTrellisQdc.node_at_type()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQdc.node_containing"><code class="docutils literal notranslate"><span class="pre">BZTrellisQdc.node_containing()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQdc.node_containing_type"><code class="docutils literal notranslate"><span class="pre">BZTrellisQdc.node_containing_type()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQdc.outer_invA"><code class="docutils literal notranslate"><span class="pre">BZTrellisQdc.outer_invA</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQdc.outer_rlu"><code class="docutils literal notranslate"><span class="pre">BZTrellisQdc.outer_rlu</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQdc.rlu"><code class="docutils literal notranslate"><span class="pre">BZTrellisQdc.rlu</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQdc.set_flags_weights"><code class="docutils literal notranslate"><span class="pre">BZTrellisQdc.set_flags_weights()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQdc.sort"><code class="docutils literal notranslate"><span class="pre">BZTrellisQdc.sort()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQdc.tetrahedra"><code class="docutils literal notranslate"><span class="pre">BZTrellisQdc.tetrahedra</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQdc.to_file"><code class="docutils literal notranslate"><span class="pre">BZTrellisQdc.to_file()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQdc.values"><code class="docutils literal notranslate"><span class="pre">BZTrellisQdc.values</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQdc.vectors"><code class="docutils literal notranslate"><span class="pre">BZTrellisQdc.vectors</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#brille.BZTrellisQdd"><code class="docutils literal notranslate"><span class="pre">BZTrellisQdd</span></code></a><ul>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQdd.BrillouinZone"><code class="docutils literal notranslate"><span class="pre">BZTrellisQdd.BrillouinZone</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQdd.all_node_types"><code class="docutils literal notranslate"><span class="pre">BZTrellisQdd.all_node_types()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQdd.bytes_per_point"><code class="docutils literal notranslate"><span class="pre">BZTrellisQdd.bytes_per_point</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQdd.fill"><code class="docutils literal notranslate"><span class="pre">BZTrellisQdd.fill()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQdd.from_file"><code class="docutils literal notranslate"><span class="pre">BZTrellisQdd.from_file()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQdd.inner_invA"><code class="docutils literal notranslate"><span class="pre">BZTrellisQdd.inner_invA</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQdd.inner_rlu"><code class="docutils literal notranslate"><span class="pre">BZTrellisQdd.inner_rlu</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQdd.interpolate_at"><code class="docutils literal notranslate"><span class="pre">BZTrellisQdd.interpolate_at()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQdd.invA"><code class="docutils literal notranslate"><span class="pre">BZTrellisQdd.invA</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQdd.ir_interpolate_at"><code class="docutils literal notranslate"><span class="pre">BZTrellisQdd.ir_interpolate_at()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQdd.node_at"><code class="docutils literal notranslate"><span class="pre">BZTrellisQdd.node_at()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQdd.node_at_type"><code class="docutils literal notranslate"><span class="pre">BZTrellisQdd.node_at_type()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQdd.node_containing"><code class="docutils literal notranslate"><span class="pre">BZTrellisQdd.node_containing()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQdd.node_containing_type"><code class="docutils literal notranslate"><span class="pre">BZTrellisQdd.node_containing_type()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQdd.outer_invA"><code class="docutils literal notranslate"><span class="pre">BZTrellisQdd.outer_invA</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQdd.outer_rlu"><code class="docutils literal notranslate"><span class="pre">BZTrellisQdd.outer_rlu</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQdd.rlu"><code class="docutils literal notranslate"><span class="pre">BZTrellisQdd.rlu</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQdd.set_flags_weights"><code class="docutils literal notranslate"><span class="pre">BZTrellisQdd.set_flags_weights()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQdd.sort"><code class="docutils literal notranslate"><span class="pre">BZTrellisQdd.sort()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQdd.tetrahedra"><code class="docutils literal notranslate"><span class="pre">BZTrellisQdd.tetrahedra</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQdd.to_file"><code class="docutils literal notranslate"><span class="pre">BZTrellisQdd.to_file()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQdd.values"><code class="docutils literal notranslate"><span class="pre">BZTrellisQdd.values</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BZTrellisQdd.vectors"><code class="docutils literal notranslate"><span class="pre">BZTrellisQdd.vectors</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#brille.Basis"><code class="docutils literal notranslate"><span class="pre">Basis</span></code></a><ul>
<li class="toctree-l2"><a class="reference internal" href="#brille.Basis.positions"><code class="docutils literal notranslate"><span class="pre">Basis.positions</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.Basis.size"><code class="docutils literal notranslate"><span class="pre">Basis.size</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.Basis.types"><code class="docutils literal notranslate"><span class="pre">Basis.types</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#brille.Bravais"><code class="docutils literal notranslate"><span class="pre">Bravais</span></code></a><ul>
<li class="toctree-l2"><a class="reference internal" href="#brille.Bravais.A"><code class="docutils literal notranslate"><span class="pre">Bravais.A</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.Bravais.B"><code class="docutils literal notranslate"><span class="pre">Bravais.B</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.Bravais.C"><code class="docutils literal notranslate"><span class="pre">Bravais.C</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.Bravais.F"><code class="docutils literal notranslate"><span class="pre">Bravais.F</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.Bravais.I"><code class="docutils literal notranslate"><span class="pre">Bravais.I</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.Bravais.P"><code class="docutils literal notranslate"><span class="pre">Bravais.P</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.Bravais.R"><code class="docutils literal notranslate"><span class="pre">Bravais.R</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.Bravais.invalid"><code class="docutils literal notranslate"><span class="pre">Bravais.invalid</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.Bravais.name"><code class="docutils literal notranslate"><span class="pre">Bravais.name</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.Bravais.value"><code class="docutils literal notranslate"><span class="pre">Bravais.value</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#brille.BrillouinZone"><code class="docutils literal notranslate"><span class="pre">BrillouinZone</span></code></a><ul>
<li class="toctree-l2"><a class="reference internal" href="#brille.BrillouinZone.faces_per_vertex"><code class="docutils literal notranslate"><span class="pre">BrillouinZone.faces_per_vertex</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BrillouinZone.from_file"><code class="docutils literal notranslate"><span class="pre">BrillouinZone.from_file()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BrillouinZone.half_edge_points"><code class="docutils literal notranslate"><span class="pre">BrillouinZone.half_edge_points</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BrillouinZone.half_edge_points_invA"><code class="docutils literal notranslate"><span class="pre">BrillouinZone.half_edge_points_invA</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BrillouinZone.ir_faces_per_vertex"><code class="docutils literal notranslate"><span class="pre">BrillouinZone.ir_faces_per_vertex</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BrillouinZone.ir_moveinto"><code class="docutils literal notranslate"><span class="pre">BrillouinZone.ir_moveinto()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BrillouinZone.ir_moveinto_wedge"><code class="docutils literal notranslate"><span class="pre">BrillouinZone.ir_moveinto_wedge()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BrillouinZone.ir_normals"><code class="docutils literal notranslate"><span class="pre">BrillouinZone.ir_normals</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BrillouinZone.ir_normals_invA"><code class="docutils literal notranslate"><span class="pre">BrillouinZone.ir_normals_invA</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BrillouinZone.ir_normals_primitive"><code class="docutils literal notranslate"><span class="pre">BrillouinZone.ir_normals_primitive</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BrillouinZone.ir_points"><code class="docutils literal notranslate"><span class="pre">BrillouinZone.ir_points</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BrillouinZone.ir_points_invA"><code class="docutils literal notranslate"><span class="pre">BrillouinZone.ir_points_invA</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BrillouinZone.ir_points_primitive"><code class="docutils literal notranslate"><span class="pre">BrillouinZone.ir_points_primitive</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BrillouinZone.ir_polyhedron"><code class="docutils literal notranslate"><span class="pre">BrillouinZone.ir_polyhedron</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BrillouinZone.ir_polyhedron_generated"><code class="docutils literal notranslate"><span class="pre">BrillouinZone.ir_polyhedron_generated</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BrillouinZone.ir_vertices"><code class="docutils literal notranslate"><span class="pre">BrillouinZone.ir_vertices</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BrillouinZone.ir_vertices_invA"><code class="docutils literal notranslate"><span class="pre">BrillouinZone.ir_vertices_invA</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BrillouinZone.ir_vertices_per_face"><code class="docutils literal notranslate"><span class="pre">BrillouinZone.ir_vertices_per_face</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BrillouinZone.ir_vertices_primitive"><code class="docutils literal notranslate"><span class="pre">BrillouinZone.ir_vertices_primitive</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BrillouinZone.isinside"><code class="docutils literal notranslate"><span class="pre">BrillouinZone.isinside()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BrillouinZone.lattice"><code class="docutils literal notranslate"><span class="pre">BrillouinZone.lattice</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BrillouinZone.moveinto"><code class="docutils literal notranslate"><span class="pre">BrillouinZone.moveinto()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BrillouinZone.normals"><code class="docutils literal notranslate"><span class="pre">BrillouinZone.normals</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BrillouinZone.normals_invA"><code class="docutils literal notranslate"><span class="pre">BrillouinZone.normals_invA</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BrillouinZone.normals_primitive"><code class="docutils literal notranslate"><span class="pre">BrillouinZone.normals_primitive</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BrillouinZone.points"><code class="docutils literal notranslate"><span class="pre">BrillouinZone.points</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BrillouinZone.points_invA"><code class="docutils literal notranslate"><span class="pre">BrillouinZone.points_invA</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BrillouinZone.points_primitive"><code class="docutils literal notranslate"><span class="pre">BrillouinZone.points_primitive</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BrillouinZone.polyhedron"><code class="docutils literal notranslate"><span class="pre">BrillouinZone.polyhedron</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BrillouinZone.to_file"><code class="docutils literal notranslate"><span class="pre">BrillouinZone.to_file()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BrillouinZone.vertices"><code class="docutils literal notranslate"><span class="pre">BrillouinZone.vertices</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BrillouinZone.vertices_invA"><code class="docutils literal notranslate"><span class="pre">BrillouinZone.vertices_invA</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BrillouinZone.vertices_per_face"><code class="docutils literal notranslate"><span class="pre">BrillouinZone.vertices_per_face</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BrillouinZone.vertices_primitive"><code class="docutils literal notranslate"><span class="pre">BrillouinZone.vertices_primitive</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BrillouinZone.wedge_normals"><code class="docutils literal notranslate"><span class="pre">BrillouinZone.wedge_normals</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BrillouinZone.wedge_normals_invA"><code class="docutils literal notranslate"><span class="pre">BrillouinZone.wedge_normals_invA</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.BrillouinZone.wedge_normals_primitive"><code class="docutils literal notranslate"><span class="pre">BrillouinZone.wedge_normals_primitive</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#brille.HallSymbol"><code class="docutils literal notranslate"><span class="pre">HallSymbol</span></code></a><ul>
<li class="toctree-l2"><a class="reference internal" href="#brille.HallSymbol.generators"><code class="docutils literal notranslate"><span class="pre">HallSymbol.generators</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#brille.LPolyhedron"><code class="docutils literal notranslate"><span class="pre">LPolyhedron</span></code></a><ul>
<li class="toctree-l2"><a class="reference internal" href="#brille.LPolyhedron.centre"><code class="docutils literal notranslate"><span class="pre">LPolyhedron.centre</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.LPolyhedron.faces"><code class="docutils literal notranslate"><span class="pre">LPolyhedron.faces</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.LPolyhedron.intersection"><code class="docutils literal notranslate"><span class="pre">LPolyhedron.intersection()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.LPolyhedron.mirror"><code class="docutils literal notranslate"><span class="pre">LPolyhedron.mirror</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.LPolyhedron.normals"><code class="docutils literal notranslate"><span class="pre">LPolyhedron.normals</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.LPolyhedron.points"><code class="docutils literal notranslate"><span class="pre">LPolyhedron.points</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.LPolyhedron.rotate"><code class="docutils literal notranslate"><span class="pre">LPolyhedron.rotate()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.LPolyhedron.to_Cartesian"><code class="docutils literal notranslate"><span class="pre">LPolyhedron.to_Cartesian()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.LPolyhedron.vertices"><code class="docutils literal notranslate"><span class="pre">LPolyhedron.vertices</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.LPolyhedron.volume"><code class="docutils literal notranslate"><span class="pre">LPolyhedron.volume</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#brille.Lattice"><code class="docutils literal notranslate"><span class="pre">Lattice()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="#brille.LengthUnit"><code class="docutils literal notranslate"><span class="pre">LengthUnit</span></code></a><ul>
<li class="toctree-l2"><a class="reference internal" href="#brille.LengthUnit.angstrom"><code class="docutils literal notranslate"><span class="pre">LengthUnit.angstrom</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.LengthUnit.inverse_angstrom"><code class="docutils literal notranslate"><span class="pre">LengthUnit.inverse_angstrom</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.LengthUnit.name"><code class="docutils literal notranslate"><span class="pre">LengthUnit.name</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.LengthUnit.none"><code class="docutils literal notranslate"><span class="pre">LengthUnit.none</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.LengthUnit.real_lattice"><code class="docutils literal notranslate"><span class="pre">LengthUnit.real_lattice</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.LengthUnit.reciprocal_lattice"><code class="docutils literal notranslate"><span class="pre">LengthUnit.reciprocal_lattice</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.LengthUnit.value"><code class="docutils literal notranslate"><span class="pre">LengthUnit.value</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#brille.NodeType"><code class="docutils literal notranslate"><span class="pre">NodeType</span></code></a><ul>
<li class="toctree-l2"><a class="reference internal" href="#brille.NodeType.assumed_null"><code class="docutils literal notranslate"><span class="pre">NodeType.assumed_null</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.NodeType.cube"><code class="docutils literal notranslate"><span class="pre">NodeType.cube</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.NodeType.found_null"><code class="docutils literal notranslate"><span class="pre">NodeType.found_null</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.NodeType.name"><code class="docutils literal notranslate"><span class="pre">NodeType.name</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.NodeType.null"><code class="docutils literal notranslate"><span class="pre">NodeType.null</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.NodeType.polygon"><code class="docutils literal notranslate"><span class="pre">NodeType.polygon</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.NodeType.value"><code class="docutils literal notranslate"><span class="pre">NodeType.value</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#brille.PointSymmetry"><code class="docutils literal notranslate"><span class="pre">PointSymmetry</span></code></a><ul>
<li class="toctree-l2"><a class="reference internal" href="#brille.PointSymmetry.W"><code class="docutils literal notranslate"><span class="pre">PointSymmetry.W</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.PointSymmetry.axis"><code class="docutils literal notranslate"><span class="pre">PointSymmetry.axis</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.PointSymmetry.generate"><code class="docutils literal notranslate"><span class="pre">PointSymmetry.generate</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.PointSymmetry.generators"><code class="docutils literal notranslate"><span class="pre">PointSymmetry.generators</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.PointSymmetry.isometry"><code class="docutils literal notranslate"><span class="pre">PointSymmetry.isometry</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.PointSymmetry.nfolds"><code class="docutils literal notranslate"><span class="pre">PointSymmetry.nfolds()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.PointSymmetry.order"><code class="docutils literal notranslate"><span class="pre">PointSymmetry.order</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.PointSymmetry.size"><code class="docutils literal notranslate"><span class="pre">PointSymmetry.size</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#brille.Pointgroup"><code class="docutils literal notranslate"><span class="pre">Pointgroup</span></code></a><ul>
<li class="toctree-l2"><a class="reference internal" href="#brille.Pointgroup.holohedry"><code class="docutils literal notranslate"><span class="pre">Pointgroup.holohedry</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.Pointgroup.laue"><code class="docutils literal notranslate"><span class="pre">Pointgroup.laue</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.Pointgroup.number"><code class="docutils literal notranslate"><span class="pre">Pointgroup.number</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.Pointgroup.symbol"><code class="docutils literal notranslate"><span class="pre">Pointgroup.symbol</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#brille.Polyhedron"><code class="docutils literal notranslate"><span class="pre">Polyhedron</span></code></a><ul>
<li class="toctree-l2"><a class="reference internal" href="#brille.Polyhedron.centre"><code class="docutils literal notranslate"><span class="pre">Polyhedron.centre</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.Polyhedron.faces"><code class="docutils literal notranslate"><span class="pre">Polyhedron.faces</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.Polyhedron.intersection"><code class="docutils literal notranslate"><span class="pre">Polyhedron.intersection()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.Polyhedron.mirror"><code class="docutils literal notranslate"><span class="pre">Polyhedron.mirror</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.Polyhedron.normals"><code class="docutils literal notranslate"><span class="pre">Polyhedron.normals</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.Polyhedron.points"><code class="docutils literal notranslate"><span class="pre">Polyhedron.points</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.Polyhedron.vertices"><code class="docutils literal notranslate"><span class="pre">Polyhedron.vertices</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.Polyhedron.volume"><code class="docutils literal notranslate"><span class="pre">Polyhedron.volume</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#brille.PrimitiveTransform"><code class="docutils literal notranslate"><span class="pre">PrimitiveTransform</span></code></a><ul>
<li class="toctree-l2"><a class="reference internal" href="#brille.PrimitiveTransform.P"><code class="docutils literal notranslate"><span class="pre">PrimitiveTransform.P</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.PrimitiveTransform.Pt"><code class="docutils literal notranslate"><span class="pre">PrimitiveTransform.Pt</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.PrimitiveTransform.does_anything"><code class="docutils literal notranslate"><span class="pre">PrimitiveTransform.does_anything</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.PrimitiveTransform.invP"><code class="docutils literal notranslate"><span class="pre">PrimitiveTransform.invP</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.PrimitiveTransform.invPt"><code class="docutils literal notranslate"><span class="pre">PrimitiveTransform.invPt</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.PrimitiveTransform.is_primitive"><code class="docutils literal notranslate"><span class="pre">PrimitiveTransform.is_primitive</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#brille.RotatesLike"><code class="docutils literal notranslate"><span class="pre">RotatesLike</span></code></a><ul>
<li class="toctree-l2"><a class="reference internal" href="#brille.RotatesLike.Gamma"><code class="docutils literal notranslate"><span class="pre">RotatesLike.Gamma</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.RotatesLike.name"><code class="docutils literal notranslate"><span class="pre">RotatesLike.name</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.RotatesLike.pseudovector"><code class="docutils literal notranslate"><span class="pre">RotatesLike.pseudovector</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.RotatesLike.value"><code class="docutils literal notranslate"><span class="pre">RotatesLike.value</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.RotatesLike.vector"><code class="docutils literal notranslate"><span class="pre">RotatesLike.vector</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#brille.SortingStatus"><code class="docutils literal notranslate"><span class="pre">SortingStatus</span></code></a><ul>
<li class="toctree-l2"><a class="reference internal" href="#brille.SortingStatus.locked"><code class="docutils literal notranslate"><span class="pre">SortingStatus.locked</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.SortingStatus.sorted"><code class="docutils literal notranslate"><span class="pre">SortingStatus.sorted</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.SortingStatus.visits"><code class="docutils literal notranslate"><span class="pre">SortingStatus.visits</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#brille.Spacegroup"><code class="docutils literal notranslate"><span class="pre">Spacegroup</span></code></a><ul>
<li class="toctree-l2"><a class="reference internal" href="#brille.Spacegroup.choice"><code class="docutils literal notranslate"><span class="pre">Spacegroup.choice</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.Spacegroup.hall_number"><code class="docutils literal notranslate"><span class="pre">Spacegroup.hall_number</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.Spacegroup.hall_symbol"><code class="docutils literal notranslate"><span class="pre">Spacegroup.hall_symbol</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.Spacegroup.international_table_full"><code class="docutils literal notranslate"><span class="pre">Spacegroup.international_table_full</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.Spacegroup.international_table_number"><code class="docutils literal notranslate"><span class="pre">Spacegroup.international_table_number</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.Spacegroup.international_table_short"><code class="docutils literal notranslate"><span class="pre">Spacegroup.international_table_short</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.Spacegroup.international_table_symbol"><code class="docutils literal notranslate"><span class="pre">Spacegroup.international_table_symbol</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.Spacegroup.pointgroup_number"><code class="docutils literal notranslate"><span class="pre">Spacegroup.pointgroup_number</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.Spacegroup.schoenflies_symbol"><code class="docutils literal notranslate"><span class="pre">Spacegroup.schoenflies_symbol</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#brille.Symmetry"><code class="docutils literal notranslate"><span class="pre">Symmetry</span></code></a><ul>
<li class="toctree-l2"><a class="reference internal" href="#brille.Symmetry.W"><code class="docutils literal notranslate"><span class="pre">Symmetry.W</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.Symmetry.centring"><code class="docutils literal notranslate"><span class="pre">Symmetry.centring</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.Symmetry.generate"><code class="docutils literal notranslate"><span class="pre">Symmetry.generate()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.Symmetry.generators"><code class="docutils literal notranslate"><span class="pre">Symmetry.generators()</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.Symmetry.size"><code class="docutils literal notranslate"><span class="pre">Symmetry.size</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#brille.Symmetry.w"><code class="docutils literal notranslate"><span class="pre">Symmetry.w</span></code></a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#brille.real_space_tolerance"><code class="docutils literal notranslate"><span class="pre">real_space_tolerance()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="#brille.reciprocal_space_tolerance"><code class="docutils literal notranslate"><span class="pre">reciprocal_space_tolerance()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="#documented-thus-far">Documented thus far:</a><ul>
<li class="toctree-l2"><a class="reference internal" href="module/lattice.html">Lattices</a></li>
<li class="toctree-l2"><a class="reference internal" href="module/debug.html">Debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="module/bz.html">Brillouin Zone</a></li>
<li class="toctree-l2"><a class="reference internal" href="module/grids.html">Grids</a></li>
<li class="toctree-l2"><a class="reference internal" href="module/symmetry.html">Symmetry</a></li>
<li class="toctree-l2"><a class="reference internal" href="module/everything.html">Remainder</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="plotting.html">Plotting utilities for <code class="docutils literal notranslate"><span class="pre">brille</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="plotting.html#brille.plotting.plot"><code class="docutils literal notranslate"><span class="pre">plot()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="plotting.html#brille.plotting.plot_bz"><code class="docutils literal notranslate"><span class="pre">plot_bz()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="plotting.html#brille.plotting.plot_points"><code class="docutils literal notranslate"><span class="pre">plot_points()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="plotting.html#brille.plotting.plot_points_with_lines"><code class="docutils literal notranslate"><span class="pre">plot_points_with_lines()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="plotting.html#brille.plotting.plot_polyhedron"><code class="docutils literal notranslate"><span class="pre">plot_polyhedron()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="plotting.html#brille.plotting.plot_tetrahedra"><code class="docutils literal notranslate"><span class="pre">plot_tetrahedra()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="plotting.html#brille.plotting.plot_tetrahedron"><code class="docutils literal notranslate"><span class="pre">plot_tetrahedron()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="utils.html">Utilities for <code class="docutils literal notranslate"><span class="pre">brille</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="utils.html#brille.utils.create_bz"><code class="docutils literal notranslate"><span class="pre">create_bz()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="utils.html#brille.utils.create_grid"><code class="docutils literal notranslate"><span class="pre">create_grid()</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="doxygen.html">Doxygen documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="undoc_brille.html">Undocumented C++ Classes</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">brille</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Python module <code class="xref py py-mod docutils literal notranslate"><span class="pre">brille</span></code></li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/brille.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="python-module-brille">
<span id="module-brille"></span><h1>Python module <a class="reference internal" href="#module-brille" title="brille"><code class="xref py py-mod docutils literal notranslate"><span class="pre">brille</span></code></a><a class="headerlink" href="#python-module-brille" title="Link to this heading"></a></h1>
<p>This module provides access to the C++ brille library which can be used to
interact with spacegroup and pointgroup symmetry operations, to determine the
first Brillouin zone for a given real space crystallographic lattice, to
find <em>an</em> irreducible polyhedron from the first Brillouin zone and the
pointgroup operations of a spacegroup, to construct polyhedron-filling connected
point networks, and to perform linear-interpolation of user-provided data for
any reciprocal space point at a symmetry-equivalent position within the
connected point network.</p>
<table class="autosummary longtable docutils align-default">
<tbody>
</tbody>
</table>
</section>
<dl class="py class">
<dt class="sig sig-object py" id="brille.AngleUnit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">brille.</span></span><span class="sig-name descname"><span class="pre">AngleUnit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#brille.AngleUnit" title="brille._brille.AngleUnit"><span class="pre">brille._brille.AngleUnit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille.AngleUnit" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<blockquote>
<div><p>The units of a number representing an angle</p>
</div></blockquote>
<p>Members:</p>
<blockquote>
<div><p>not_provided : unknown, will be inferred</p>
<p>radian : radian</p>
<p>degree : degree</p>
<p>pi : radian divided by pi</p>
</div></blockquote>
<dl class="py attribute">
<dt class="sig sig-object py" id="brille.AngleUnit.degree">
<span class="sig-name descname"><span class="pre">degree</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;AngleUnit.degree:</span> <span class="pre">2&gt;</span></em><a class="headerlink" href="#brille.AngleUnit.degree" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.AngleUnit.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#brille.AngleUnit.name" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="brille.AngleUnit.not_provided">
<span class="sig-name descname"><span class="pre">not_provided</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;AngleUnit.not_provided:</span> <span class="pre">0&gt;</span></em><a class="headerlink" href="#brille.AngleUnit.not_provided" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="brille.AngleUnit.pi">
<span class="sig-name descname"><span class="pre">pi</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;AngleUnit.pi:</span> <span class="pre">3&gt;</span></em><a class="headerlink" href="#brille.AngleUnit.pi" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="brille.AngleUnit.radian">
<span class="sig-name descname"><span class="pre">radian</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;AngleUnit.radian:</span> <span class="pre">1&gt;</span></em><a class="headerlink" href="#brille.AngleUnit.radian" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.AngleUnit.value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#brille.AngleUnit.value" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="brille.ApproxConfig">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">brille.</span></span><span class="sig-name descname"><span class="pre">ApproxConfig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#brille.ApproxConfig" title="brille._brille.ApproxConfig"><span class="pre">brille._brille.ApproxConfig</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">digits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">real_space_tolerance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reciprocal_space_tolerance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-10</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille.ApproxConfig" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<dl class="py property">
<dt class="sig sig-object py" id="brille.ApproxConfig.digits">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">digits</span></span><a class="headerlink" href="#brille.ApproxConfig.digits" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.ApproxConfig.real_space_tolerance">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">real_space_tolerance</span></span><a class="headerlink" href="#brille.ApproxConfig.real_space_tolerance" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.ApproxConfig.reciprocal_space_tolerance">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">reciprocal_space_tolerance</span></span><a class="headerlink" href="#brille.ApproxConfig.reciprocal_space_tolerance" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="brille.BZMeshQcc">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">brille.</span></span><span class="sig-name descname"><span class="pre">BZMeshQcc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZMeshQcc" title="brille._brille.BZMeshQcc"><span class="pre">brille._brille.BZMeshQcc</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">brillouin_zone</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/bz.html#brille._brille.BrillouinZone" title="brille._brille.BrillouinZone"><span class="pre">brille._brille.BrillouinZone</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_levels</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_points</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille.BZMeshQcc" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<dl class="py property">
<dt class="sig sig-object py" id="brille.BZMeshQcc.BrillouinZone">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">BrillouinZone</span></span><a class="headerlink" href="#brille.BZMeshQcc.BrillouinZone" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZMeshQcc.bytes_per_point">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bytes_per_point</span></span><a class="headerlink" href="#brille.BZMeshQcc.bytes_per_point" title="Link to this definition"></a></dt>
<dd><p>Return the memory required per interpolation point <em>result</em> in bytes</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZMeshQcc.fill">
<span class="sig-name descname"><span class="pre">fill</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille.BZMeshQcc.fill" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>fill(self: brille._brille.BZMeshQcc, values_data: numpy.ndarray[numpy.complex128], values_elements: numpy.ndarray[numpy.int32], vectors_data: numpy.ndarray[numpy.complex128], vectors_elements: numpy.ndarray[numpy.int32], sort: bool = False) -&gt; None</p></li>
</ol>
<p>Provide data required for interpolation to the grid without cost information.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>values_data</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – The eigenvalue data to be stored in the grid. The first dimension must be
equal in size to the number of grid-vertices. If two dimensional the second
dimension is interpreted as all information for a single mode flattened
and concatenated into (scalars, vectors, matrices) – in that order.
If more than two dimensional, the second dimension indexes modes and
higher dimensions will be flattened <em>as if row ordered</em> and must flatten into
a concatenated list of (scalars, vectors, matrices).
If the provided array can be interpreted as a contiguous row-ordered two
dimensional array it will be used in place, otherwise a copy will be made.</p></li>
<li><p><strong>values_elements</strong> (<em>integer vector-like</em>) – A multi-purpose vector containing, in order:</p>
<ul>
<li><p>the number of scalar-like eigenvalue elements,</p></li>
<li><p>the number of vector-like eigenvalue <em>elements</em> (must be <span class="math">\(3\times N\)</span>),</p></li>
<li><p>the number of matrix-like eigenvalue <em>elements</em> (must be <span class="math">\(9\times N\)</span>),</p></li>
<li><p>an integer <a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> value denoting
<em>how</em> the vector-like and matrix-like parts transform under application
of a symmetry operation (see note below).</p></li>
<li><p>an integer <a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a> value denoting what units
the vector-like and matrix-like parts are in (see note below).</p></li>
</ul>
</li>
<li><p><strong>vectors_data</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – The eigenvector data to be stored in the grid. Same shape restrictions as
<code class="docutils literal notranslate"><span class="pre">values_data</span></code></p></li>
<li><p><strong>vectors_elements</strong> – Like <code class="docutils literal notranslate"><span class="pre">values_elements</span></code> but for the eigenvectors</p></li>
<li><p><strong>sort</strong> (logical (default <code class="docutils literal notranslate"><span class="pre">False</span></code>)) – Whether the equivalent-mode permutations should be (re)determined following
the update to the flags and weights.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Mapping of integers to <a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>vector</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>pseudovector</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>Gamma</cite></p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 0.</p>
<p>Mapping of integers to <a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>none</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>angstrom</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>inverse_angstrom</cite></p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p><cite>real_lattice</cite></p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p><cite>reciprocal_lattice</cite></p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 3.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>fill(self: brille._brille.BZMeshQcc, values_data: numpy.ndarray[numpy.complex128], values_elements: numpy.ndarray[numpy.int32], values_weights: numpy.ndarray[numpy.float64], vectors_data: numpy.ndarray[numpy.complex128], vectors_elements: numpy.ndarray[numpy.int32], vectors_weights: numpy.ndarray[numpy.float64], sort: bool = False) -&gt; None</p></li>
</ol>
<p>Provide all data required for interpolation to the grid at once</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>values_data</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – The eigenvalue data to be stored in the grid. The first dimension must be
equal in size to the number of grid-vertices. If two dimensional the second
dimension is interpreted as all information for a single mode flattened
and concatenated into (scalars, vectors, matrices) – in that order.
If more than two dimensional, the second dimension indexes modes and
higher dimensions will be flattened <em>as if row ordered</em> and must flatten into
a concatenated list of (scalars, vectors, matrices).
If the provided array can be interpreted as a contiguous row-ordered two
dimensional array it will be used in place, otherwise a copy will be made.</p></li>
<li><p><strong>values_elements</strong> (<em>integer vector-like</em>) – A multi-purpose vector containing, in order:</p>
<ul class="simple">
<li><p>the number of scalar-like eigenvalue elements,</p></li>
<li><p>the number of vector-like eigenvalue <em>elements</em> (must be <span class="math">\(3\times N\)</span>),</p></li>
<li><p>the number of matrix-like eigenvalue <em>elements</em> (must be <span class="math">\(9\times N\)</span>),</p></li>
<li><p>an integer <a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> value denoting
<em>how</em> the vector-like and matrix-like parts transform under application
of a symmetry operation (see note below),</p></li>
<li><p>an integer <a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a> value denoting what units
the vector-like and matrix-like parts are in (see note below)</p></li>
<li><p>which scalar cost function should be used (see below),</p></li>
<li><p>which vector cost function should be used (see below).</p></li>
</ul>
<p>See the note below for the meaning of the last three values.</p>
</li>
<li><p><strong>values_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvalue elements stored in the grid</p></li>
<li><p><strong>vectors_data</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – The eigenvector data to be stored in the grid. Same shape restrictions as
<strong>values_data</strong></p></li>
<li><p><strong>vectors_elements</strong> – Like <strong>values_elements</strong> but for the eigenvectors</p></li>
<li><p><strong>vectors_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvector elements stored in the grid</p></li>
<li><p><strong>sort</strong> (logical (default <code class="docutils literal notranslate"><span class="pre">False</span></code>)) – Whether the equivalent-mode permutations should be (re)determined following
the update to the flags and weights.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Mapping of integers to <a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>vector</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>pseudovector</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>Gamma</cite></p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to <a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>none</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>angstrom</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>inverse_angstrom</cite></p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p><cite>real_lattice</cite></p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p><cite>reciprocal_lattice</cite></p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 3.</p>
<p>Mapping of integers to scalar cost function:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(x,y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>magnitude(x-y)</p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to vector cost function:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(vec_x, vec_y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>sin(hermitian_angle(vec_x, vec_y))</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>vector_distance(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>1 - vector_product(vec_x, vec_y)</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>vector_angle(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>hermitian_angle(vec_x, vec_y)</p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 0.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZMeshQcc.from_file">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">entry</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'BZMeshQcc'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="module/grids.html#brille._brille.BZMeshQcc" title="brille._brille.BZMeshQcc"><span class="pre">brille._brille.BZMeshQcc</span></a></span></span><a class="headerlink" href="#brille.BZMeshQcc.from_file" title="Link to this definition"></a></dt>
<dd><p>Save the object to an HDF5 file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> (<em>str</em>) – The full path specification for the file to read from</p></li>
<li><p><strong>entry</strong> (<em>str</em>) – The group path, e.g., “my/cool/grid”, where to read from inside the file,
with a default equal to the object Class name</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>clsObj</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZMeshQcc.invA">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">invA</span></span><a class="headerlink" href="#brille.BZMeshQcc.invA" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZMeshQcc.ir_interpolate_at">
<span class="sig-name descname"><span class="pre">ir_interpolate_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZMeshQcc" title="brille._brille.BZMeshQcc"><span class="pre">brille._brille.BZMeshQcc</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">useparallel</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threads</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">do_not_move_points</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.complex128</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.complex128</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#brille.BZMeshQcc.ir_interpolate_at" title="Link to this definition"></a></dt>
<dd><p>Perform linear interpolation of the stored data at irreducible equivalent points</p>
<p>The irreducible first Brillouin zone is the part of reciprocal space which is
invariant under application of the integer translations <em>and</em> the pointgroup
operations of a reciprocal space lattice. This method finds points equivalent
to the input within the irreducible first Brillouin zone and then interpolates
pre-stored information to provide an estimate at the found positions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Q</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – A two dimensional array with <code class="docutils literal notranslate"><span class="pre">Q.shape[1]</span> <span class="pre">==</span> <span class="pre">3</span></code> containing the positions at
which an interpolated result is required, expressed in units of the
reciprocal lattice.</p></li>
<li><p><strong>useparallel</strong> (<em>bool, optional</em>) – Whether a serial or parallel code should be utilised</p></li>
<li><p><strong>threads</strong> (<em>int, optional</em>) – How many OpenMP workers should be utilised; if this value is less than one
the environment variable <code class="docutils literal notranslate"><span class="pre">OMP_NUM_THREADS</span></code> will be used.</p></li>
<li><p><strong>do_not_move_points</strong> (<em>bool, optional</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code> the provided <strong>Q</strong> points must already lie within the first Brillouin
zone. No check is made to verify this requirement and if any <strong>Q</strong> lie outside
of the gridded volume out-of-bounds errors may result in bad data or runtime
errors.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The interpolated eigenvalues and eigenvectors at the equivalent
irreducible first Brillouin zone points.
The shape of each output will depend on the shape of the data provided to
the <a class="reference internal" href="module/grids.html#brille._brille.BZTrellisQdc.fill" title="brille._brille.BZTrellisQdc.fill"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fill()</span></code></a> method. i
If the filled eigenvalues were of shape
<code class="docutils literal notranslate"><span class="pre">[N_grid_points,</span> <span class="pre">N_modes,</span> <span class="pre">A,</span> <span class="pre">...,</span> <span class="pre">B]</span></code>, the eigenvectors were of shape
<code class="docutils literal notranslate"><span class="pre">[N_grid_points,</span> <span class="pre">N_modes,</span> <span class="pre">C,</span> <span class="pre">...,</span> <span class="pre">D]</span></code>, and the provided points of shape
<code class="docutils literal notranslate"><span class="pre">[N_Q_points,</span> <span class="pre">3]</span></code> then the output shapes will be
<code class="docutils literal notranslate"><span class="pre">[N_Q_points,</span> <span class="pre">N_modes,</span> <span class="pre">A,</span> <span class="pre">...,</span> <span class="pre">B]</span></code> and <code class="docutils literal notranslate"><span class="pre">[N_Q_points,</span> <span class="pre">N_modes,</span> <span class="pre">C,</span> <span class="pre">...,</span> <span class="pre">D]</span></code>
for the eigenvalues and eigenvectors, respectively.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZMeshQcc.rlu">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">rlu</span></span><a class="headerlink" href="#brille.BZMeshQcc.rlu" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZMeshQcc.set_flags_weights">
<span class="sig-name descname"><span class="pre">set_flags_weights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZMeshQcc" title="brille._brille.BZMeshQcc"><span class="pre">brille._brille.BZMeshQcc</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">values_flags</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">values_weights</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vectors_flags</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vectors_weights</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#brille.BZMeshQcc.set_flags_weights" title="Link to this definition"></a></dt>
<dd><p>Set <a class="reference internal" href="module/grids.html#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a>, <cite>~brille._brille.LengthUnit</cite>
and cost functions plus relative cost weights for the values and vectors
stored in the object</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>values_flags</strong> (<em>integer, vector-like</em>) – One or more values indicating the <a class="reference internal" href="module/grids.html#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a>
value for the eigenvalues stored in the object, the <cite>~brille._brille.LengthUnit</cite>
value, plus which cost function to use when comparing stored eigenvalues at
neighbouring grid points for scalar- and vector-like eigenvalues.</p></li>
<li><p><strong>values_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvalue elements stored in the grid</p></li>
<li><p><strong>vectors_flags</strong> (<em>integer, vector-like</em>) – One or more values indicating the <a class="reference internal" href="module/grids.html#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a>
value for the eigenvalues stored in the object, the <cite>~brille._brille.LengthUnit</cite>
value, plus which cost function to use when comparing stored eigenvectors at
neighbouring grid points for scalar- and vector-like eigenvectors.</p></li>
<li><p><strong>vectors_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvector elements stored in the grid</p></li>
<li><p><strong>sort</strong> (<em>bool, optional</em>) – Whether the equivalent-mode permutations should be (re)determined following
the update to the flags and weights.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Mapping of integers to <a class="reference internal" href="module/grids.html#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>vector</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>pseudovector</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>Gamma</cite></p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to <a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>none</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>angstrom</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>inverse_angstrom</cite></p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p><cite>real_lattice</cite></p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p><cite>reciprocal_lattice</cite></p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to scalar cost function:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(x,y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>magnitude(x-y)</p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to vector cost function:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(vec_x, vec_y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>sin(hermitian_angle(vec_x, vec_y))</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>vector_distance(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>1 - vector_product(vec_x, vec_y)</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>vector_angle(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>hermitian_angle(vec_x, vec_y)</p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 0.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZMeshQcc.sort">
<span class="sig-name descname"><span class="pre">sort</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZMeshQcc" title="brille._brille.BZMeshQcc"><span class="pre">brille._brille.BZMeshQcc</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#brille.BZMeshQcc.sort" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZMeshQcc.tetrahedra">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">tetrahedra</span></span><a class="headerlink" href="#brille.BZMeshQcc.tetrahedra" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZMeshQcc.to_file">
<span class="sig-name descname"><span class="pre">to_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZMeshQcc" title="brille._brille.BZMeshQcc"><span class="pre">brille._brille.BZMeshQcc</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">entry</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'BZMeshQcc'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'ac'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#brille.BZMeshQcc.to_file" title="Link to this definition"></a></dt>
<dd><p>Save the object to an HDF5 file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> (<em>str</em>) – The full path specification for the file to write into</p></li>
<li><p><strong>entry</strong> (<em>str</em>) – The group path, e.g., “my/cool/grid”, where to write inside the file,
with a default equal to the object Class name</p></li>
<li><p><strong>flags</strong> (<em>str</em>) – The HDF5 permissions to use when opening the file. Default ‘a’ writes to an
existing file – if <cite>entry</cite> exists in the file it is overwritten.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Possible <cite>flags</cite> are:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><cite>flags</cite></p></th>
<th class="head"><p>meaning</p></th>
<th class="head"><p>HDF equivalent</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>‘r’</p></td>
<td><p>read</p></td>
<td><p>H5F_ACC_RDONLY</p></td>
</tr>
<tr class="row-odd"><td><p>‘x’</p></td>
<td><p>write, error if exists</p></td>
<td><p>H5F_ACC_EXCL</p></td>
</tr>
<tr class="row-even"><td><p>‘a’</p></td>
<td><p>write, append to file</p></td>
<td><p>H5F_ACC_RDWR</p></td>
</tr>
<tr class="row-odd"><td><p>‘c’</p></td>
<td><p>write, error if exists</p></td>
<td><p>H5F_ACC_CREAT</p></td>
</tr>
<tr class="row-even"><td><p>‘t’</p></td>
<td><p>write, replace existing</p></td>
<td><p>H5F_ACC_TRUNC</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Indication of writing success.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZMeshQcc.values">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">values</span></span><a class="headerlink" href="#brille.BZMeshQcc.values" title="Link to this definition"></a></dt>
<dd><p>Return a shared view of the stored eigenvalues</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZMeshQcc.vectors">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">vectors</span></span><a class="headerlink" href="#brille.BZMeshQcc.vectors" title="Link to this definition"></a></dt>
<dd><p>Return a shared view of the stored eigenvectors</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="brille.BZMeshQdc">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">brille.</span></span><span class="sig-name descname"><span class="pre">BZMeshQdc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZMeshQdc" title="brille._brille.BZMeshQdc"><span class="pre">brille._brille.BZMeshQdc</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">brillouin_zone</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/bz.html#brille._brille.BrillouinZone" title="brille._brille.BrillouinZone"><span class="pre">brille._brille.BrillouinZone</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_levels</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_points</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille.BZMeshQdc" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<dl class="py property">
<dt class="sig sig-object py" id="brille.BZMeshQdc.BrillouinZone">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">BrillouinZone</span></span><a class="headerlink" href="#brille.BZMeshQdc.BrillouinZone" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZMeshQdc.bytes_per_point">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bytes_per_point</span></span><a class="headerlink" href="#brille.BZMeshQdc.bytes_per_point" title="Link to this definition"></a></dt>
<dd><p>Return the memory required per interpolation point <em>result</em> in bytes</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZMeshQdc.fill">
<span class="sig-name descname"><span class="pre">fill</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille.BZMeshQdc.fill" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>fill(self: brille._brille.BZMeshQdc, values_data: numpy.ndarray[numpy.float64], values_elements: numpy.ndarray[numpy.int32], vectors_data: numpy.ndarray[numpy.complex128], vectors_elements: numpy.ndarray[numpy.int32], sort: bool = False) -&gt; None</p></li>
</ol>
<p>Provide data required for interpolation to the grid without cost information.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>values_data</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – The eigenvalue data to be stored in the grid. The first dimension must be
equal in size to the number of grid-vertices. If two dimensional the second
dimension is interpreted as all information for a single mode flattened
and concatenated into (scalars, vectors, matrices) – in that order.
If more than two dimensional, the second dimension indexes modes and
higher dimensions will be flattened <em>as if row ordered</em> and must flatten into
a concatenated list of (scalars, vectors, matrices).
If the provided array can be interpreted as a contiguous row-ordered two
dimensional array it will be used in place, otherwise a copy will be made.</p></li>
<li><p><strong>values_elements</strong> (<em>integer vector-like</em>) – A multi-purpose vector containing, in order:</p>
<ul>
<li><p>the number of scalar-like eigenvalue elements,</p></li>
<li><p>the number of vector-like eigenvalue <em>elements</em> (must be <span class="math">\(3\times N\)</span>),</p></li>
<li><p>the number of matrix-like eigenvalue <em>elements</em> (must be <span class="math">\(9\times N\)</span>),</p></li>
<li><p>an integer <a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> value denoting
<em>how</em> the vector-like and matrix-like parts transform under application
of a symmetry operation (see note below).</p></li>
<li><p>an integer <a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a> value denoting what units
the vector-like and matrix-like parts are in (see note below).</p></li>
</ul>
</li>
<li><p><strong>vectors_data</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – The eigenvector data to be stored in the grid. Same shape restrictions as
<code class="docutils literal notranslate"><span class="pre">values_data</span></code></p></li>
<li><p><strong>vectors_elements</strong> – Like <code class="docutils literal notranslate"><span class="pre">values_elements</span></code> but for the eigenvectors</p></li>
<li><p><strong>sort</strong> (logical (default <code class="docutils literal notranslate"><span class="pre">False</span></code>)) – Whether the equivalent-mode permutations should be (re)determined following
the update to the flags and weights.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Mapping of integers to <a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>vector</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>pseudovector</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>Gamma</cite></p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 0.</p>
<p>Mapping of integers to <a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>none</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>angstrom</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>inverse_angstrom</cite></p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p><cite>real_lattice</cite></p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p><cite>reciprocal_lattice</cite></p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 3.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>fill(self: brille._brille.BZMeshQdc, values_data: numpy.ndarray[numpy.float64], values_elements: numpy.ndarray[numpy.int32], values_weights: numpy.ndarray[numpy.float64], vectors_data: numpy.ndarray[numpy.complex128], vectors_elements: numpy.ndarray[numpy.int32], vectors_weights: numpy.ndarray[numpy.float64], sort: bool = False) -&gt; None</p></li>
</ol>
<p>Provide all data required for interpolation to the grid at once</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>values_data</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – The eigenvalue data to be stored in the grid. The first dimension must be
equal in size to the number of grid-vertices. If two dimensional the second
dimension is interpreted as all information for a single mode flattened
and concatenated into (scalars, vectors, matrices) – in that order.
If more than two dimensional, the second dimension indexes modes and
higher dimensions will be flattened <em>as if row ordered</em> and must flatten into
a concatenated list of (scalars, vectors, matrices).
If the provided array can be interpreted as a contiguous row-ordered two
dimensional array it will be used in place, otherwise a copy will be made.</p></li>
<li><p><strong>values_elements</strong> (<em>integer vector-like</em>) – A multi-purpose vector containing, in order:</p>
<ul class="simple">
<li><p>the number of scalar-like eigenvalue elements,</p></li>
<li><p>the number of vector-like eigenvalue <em>elements</em> (must be <span class="math">\(3\times N\)</span>),</p></li>
<li><p>the number of matrix-like eigenvalue <em>elements</em> (must be <span class="math">\(9\times N\)</span>),</p></li>
<li><p>an integer <a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> value denoting
<em>how</em> the vector-like and matrix-like parts transform under application
of a symmetry operation (see note below),</p></li>
<li><p>an integer <a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a> value denoting what units
the vector-like and matrix-like parts are in (see note below)</p></li>
<li><p>which scalar cost function should be used (see below),</p></li>
<li><p>which vector cost function should be used (see below).</p></li>
</ul>
<p>See the note below for the meaning of the last three values.</p>
</li>
<li><p><strong>values_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvalue elements stored in the grid</p></li>
<li><p><strong>vectors_data</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – The eigenvector data to be stored in the grid. Same shape restrictions as
<strong>values_data</strong></p></li>
<li><p><strong>vectors_elements</strong> – Like <strong>values_elements</strong> but for the eigenvectors</p></li>
<li><p><strong>vectors_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvector elements stored in the grid</p></li>
<li><p><strong>sort</strong> (logical (default <code class="docutils literal notranslate"><span class="pre">False</span></code>)) – Whether the equivalent-mode permutations should be (re)determined following
the update to the flags and weights.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Mapping of integers to <a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>vector</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>pseudovector</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>Gamma</cite></p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to <a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>none</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>angstrom</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>inverse_angstrom</cite></p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p><cite>real_lattice</cite></p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p><cite>reciprocal_lattice</cite></p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 3.</p>
<p>Mapping of integers to scalar cost function:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(x,y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>magnitude(x-y)</p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to vector cost function:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(vec_x, vec_y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>sin(hermitian_angle(vec_x, vec_y))</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>vector_distance(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>1 - vector_product(vec_x, vec_y)</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>vector_angle(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>hermitian_angle(vec_x, vec_y)</p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 0.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZMeshQdc.from_file">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">entry</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'BZMeshQdc'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="module/grids.html#brille._brille.BZMeshQdc" title="brille._brille.BZMeshQdc"><span class="pre">brille._brille.BZMeshQdc</span></a></span></span><a class="headerlink" href="#brille.BZMeshQdc.from_file" title="Link to this definition"></a></dt>
<dd><p>Save the object to an HDF5 file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> (<em>str</em>) – The full path specification for the file to read from</p></li>
<li><p><strong>entry</strong> (<em>str</em>) – The group path, e.g., “my/cool/grid”, where to read from inside the file,
with a default equal to the object Class name</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>clsObj</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZMeshQdc.invA">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">invA</span></span><a class="headerlink" href="#brille.BZMeshQdc.invA" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZMeshQdc.ir_interpolate_at">
<span class="sig-name descname"><span class="pre">ir_interpolate_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZMeshQdc" title="brille._brille.BZMeshQdc"><span class="pre">brille._brille.BZMeshQdc</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">useparallel</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threads</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">do_not_move_points</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.complex128</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#brille.BZMeshQdc.ir_interpolate_at" title="Link to this definition"></a></dt>
<dd><p>Perform linear interpolation of the stored data at irreducible equivalent points</p>
<p>The irreducible first Brillouin zone is the part of reciprocal space which is
invariant under application of the integer translations <em>and</em> the pointgroup
operations of a reciprocal space lattice. This method finds points equivalent
to the input within the irreducible first Brillouin zone and then interpolates
pre-stored information to provide an estimate at the found positions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Q</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – A two dimensional array with <code class="docutils literal notranslate"><span class="pre">Q.shape[1]</span> <span class="pre">==</span> <span class="pre">3</span></code> containing the positions at
which an interpolated result is required, expressed in units of the
reciprocal lattice.</p></li>
<li><p><strong>useparallel</strong> (<em>bool, optional</em>) – Whether a serial or parallel code should be utilised</p></li>
<li><p><strong>threads</strong> (<em>int, optional</em>) – How many OpenMP workers should be utilised; if this value is less than one
the environment variable <code class="docutils literal notranslate"><span class="pre">OMP_NUM_THREADS</span></code> will be used.</p></li>
<li><p><strong>do_not_move_points</strong> (<em>bool, optional</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code> the provided <strong>Q</strong> points must already lie within the first Brillouin
zone. No check is made to verify this requirement and if any <strong>Q</strong> lie outside
of the gridded volume out-of-bounds errors may result in bad data or runtime
errors.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The interpolated eigenvalues and eigenvectors at the equivalent
irreducible first Brillouin zone points.
The shape of each output will depend on the shape of the data provided to
the <a class="reference internal" href="module/grids.html#brille._brille.BZTrellisQdc.fill" title="brille._brille.BZTrellisQdc.fill"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fill()</span></code></a> method. i
If the filled eigenvalues were of shape
<code class="docutils literal notranslate"><span class="pre">[N_grid_points,</span> <span class="pre">N_modes,</span> <span class="pre">A,</span> <span class="pre">...,</span> <span class="pre">B]</span></code>, the eigenvectors were of shape
<code class="docutils literal notranslate"><span class="pre">[N_grid_points,</span> <span class="pre">N_modes,</span> <span class="pre">C,</span> <span class="pre">...,</span> <span class="pre">D]</span></code>, and the provided points of shape
<code class="docutils literal notranslate"><span class="pre">[N_Q_points,</span> <span class="pre">3]</span></code> then the output shapes will be
<code class="docutils literal notranslate"><span class="pre">[N_Q_points,</span> <span class="pre">N_modes,</span> <span class="pre">A,</span> <span class="pre">...,</span> <span class="pre">B]</span></code> and <code class="docutils literal notranslate"><span class="pre">[N_Q_points,</span> <span class="pre">N_modes,</span> <span class="pre">C,</span> <span class="pre">...,</span> <span class="pre">D]</span></code>
for the eigenvalues and eigenvectors, respectively.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZMeshQdc.rlu">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">rlu</span></span><a class="headerlink" href="#brille.BZMeshQdc.rlu" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZMeshQdc.set_flags_weights">
<span class="sig-name descname"><span class="pre">set_flags_weights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZMeshQdc" title="brille._brille.BZMeshQdc"><span class="pre">brille._brille.BZMeshQdc</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">values_flags</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">values_weights</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vectors_flags</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vectors_weights</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#brille.BZMeshQdc.set_flags_weights" title="Link to this definition"></a></dt>
<dd><p>Set <a class="reference internal" href="module/grids.html#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a>, <cite>~brille._brille.LengthUnit</cite>
and cost functions plus relative cost weights for the values and vectors
stored in the object</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>values_flags</strong> (<em>integer, vector-like</em>) – One or more values indicating the <a class="reference internal" href="module/grids.html#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a>
value for the eigenvalues stored in the object, the <cite>~brille._brille.LengthUnit</cite>
value, plus which cost function to use when comparing stored eigenvalues at
neighbouring grid points for scalar- and vector-like eigenvalues.</p></li>
<li><p><strong>values_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvalue elements stored in the grid</p></li>
<li><p><strong>vectors_flags</strong> (<em>integer, vector-like</em>) – One or more values indicating the <a class="reference internal" href="module/grids.html#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a>
value for the eigenvalues stored in the object, the <cite>~brille._brille.LengthUnit</cite>
value, plus which cost function to use when comparing stored eigenvectors at
neighbouring grid points for scalar- and vector-like eigenvectors.</p></li>
<li><p><strong>vectors_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvector elements stored in the grid</p></li>
<li><p><strong>sort</strong> (<em>bool, optional</em>) – Whether the equivalent-mode permutations should be (re)determined following
the update to the flags and weights.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Mapping of integers to <a class="reference internal" href="module/grids.html#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>vector</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>pseudovector</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>Gamma</cite></p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to <a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>none</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>angstrom</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>inverse_angstrom</cite></p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p><cite>real_lattice</cite></p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p><cite>reciprocal_lattice</cite></p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to scalar cost function:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(x,y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>magnitude(x-y)</p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to vector cost function:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(vec_x, vec_y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>sin(hermitian_angle(vec_x, vec_y))</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>vector_distance(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>1 - vector_product(vec_x, vec_y)</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>vector_angle(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>hermitian_angle(vec_x, vec_y)</p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 0.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZMeshQdc.sort">
<span class="sig-name descname"><span class="pre">sort</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZMeshQdc" title="brille._brille.BZMeshQdc"><span class="pre">brille._brille.BZMeshQdc</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#brille.BZMeshQdc.sort" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZMeshQdc.tetrahedra">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">tetrahedra</span></span><a class="headerlink" href="#brille.BZMeshQdc.tetrahedra" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZMeshQdc.to_file">
<span class="sig-name descname"><span class="pre">to_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZMeshQdc" title="brille._brille.BZMeshQdc"><span class="pre">brille._brille.BZMeshQdc</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">entry</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'BZMeshQdc'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'ac'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#brille.BZMeshQdc.to_file" title="Link to this definition"></a></dt>
<dd><p>Save the object to an HDF5 file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> (<em>str</em>) – The full path specification for the file to write into</p></li>
<li><p><strong>entry</strong> (<em>str</em>) – The group path, e.g., “my/cool/grid”, where to write inside the file,
with a default equal to the object Class name</p></li>
<li><p><strong>flags</strong> (<em>str</em>) – The HDF5 permissions to use when opening the file. Default ‘a’ writes to an
existing file – if <cite>entry</cite> exists in the file it is overwritten.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Possible <cite>flags</cite> are:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><cite>flags</cite></p></th>
<th class="head"><p>meaning</p></th>
<th class="head"><p>HDF equivalent</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>‘r’</p></td>
<td><p>read</p></td>
<td><p>H5F_ACC_RDONLY</p></td>
</tr>
<tr class="row-odd"><td><p>‘x’</p></td>
<td><p>write, error if exists</p></td>
<td><p>H5F_ACC_EXCL</p></td>
</tr>
<tr class="row-even"><td><p>‘a’</p></td>
<td><p>write, append to file</p></td>
<td><p>H5F_ACC_RDWR</p></td>
</tr>
<tr class="row-odd"><td><p>‘c’</p></td>
<td><p>write, error if exists</p></td>
<td><p>H5F_ACC_CREAT</p></td>
</tr>
<tr class="row-even"><td><p>‘t’</p></td>
<td><p>write, replace existing</p></td>
<td><p>H5F_ACC_TRUNC</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Indication of writing success.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZMeshQdc.values">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">values</span></span><a class="headerlink" href="#brille.BZMeshQdc.values" title="Link to this definition"></a></dt>
<dd><p>Return a shared view of the stored eigenvalues</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZMeshQdc.vectors">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">vectors</span></span><a class="headerlink" href="#brille.BZMeshQdc.vectors" title="Link to this definition"></a></dt>
<dd><p>Return a shared view of the stored eigenvectors</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="brille.BZMeshQdd">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">brille.</span></span><span class="sig-name descname"><span class="pre">BZMeshQdd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZMeshQdd" title="brille._brille.BZMeshQdd"><span class="pre">brille._brille.BZMeshQdd</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">brillouin_zone</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/bz.html#brille._brille.BrillouinZone" title="brille._brille.BrillouinZone"><span class="pre">brille._brille.BrillouinZone</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_levels</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_points</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille.BZMeshQdd" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<dl class="py property">
<dt class="sig sig-object py" id="brille.BZMeshQdd.BrillouinZone">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">BrillouinZone</span></span><a class="headerlink" href="#brille.BZMeshQdd.BrillouinZone" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZMeshQdd.bytes_per_point">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bytes_per_point</span></span><a class="headerlink" href="#brille.BZMeshQdd.bytes_per_point" title="Link to this definition"></a></dt>
<dd><p>Return the memory required per interpolation point <em>result</em> in bytes</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZMeshQdd.fill">
<span class="sig-name descname"><span class="pre">fill</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille.BZMeshQdd.fill" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>fill(self: brille._brille.BZMeshQdd, values_data: numpy.ndarray[numpy.float64], values_elements: numpy.ndarray[numpy.int32], vectors_data: numpy.ndarray[numpy.float64], vectors_elements: numpy.ndarray[numpy.int32], sort: bool = False) -&gt; None</p></li>
</ol>
<p>Provide data required for interpolation to the grid without cost information.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>values_data</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – The eigenvalue data to be stored in the grid. The first dimension must be
equal in size to the number of grid-vertices. If two dimensional the second
dimension is interpreted as all information for a single mode flattened
and concatenated into (scalars, vectors, matrices) – in that order.
If more than two dimensional, the second dimension indexes modes and
higher dimensions will be flattened <em>as if row ordered</em> and must flatten into
a concatenated list of (scalars, vectors, matrices).
If the provided array can be interpreted as a contiguous row-ordered two
dimensional array it will be used in place, otherwise a copy will be made.</p></li>
<li><p><strong>values_elements</strong> (<em>integer vector-like</em>) – A multi-purpose vector containing, in order:</p>
<ul>
<li><p>the number of scalar-like eigenvalue elements,</p></li>
<li><p>the number of vector-like eigenvalue <em>elements</em> (must be <span class="math">\(3\times N\)</span>),</p></li>
<li><p>the number of matrix-like eigenvalue <em>elements</em> (must be <span class="math">\(9\times N\)</span>),</p></li>
<li><p>an integer <a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> value denoting
<em>how</em> the vector-like and matrix-like parts transform under application
of a symmetry operation (see note below).</p></li>
<li><p>an integer <a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a> value denoting what units
the vector-like and matrix-like parts are in (see note below).</p></li>
</ul>
</li>
<li><p><strong>vectors_data</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – The eigenvector data to be stored in the grid. Same shape restrictions as
<code class="docutils literal notranslate"><span class="pre">values_data</span></code></p></li>
<li><p><strong>vectors_elements</strong> – Like <code class="docutils literal notranslate"><span class="pre">values_elements</span></code> but for the eigenvectors</p></li>
<li><p><strong>sort</strong> (logical (default <code class="docutils literal notranslate"><span class="pre">False</span></code>)) – Whether the equivalent-mode permutations should be (re)determined following
the update to the flags and weights.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Mapping of integers to <a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>vector</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>pseudovector</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>Gamma</cite></p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 0.</p>
<p>Mapping of integers to <a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>none</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>angstrom</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>inverse_angstrom</cite></p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p><cite>real_lattice</cite></p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p><cite>reciprocal_lattice</cite></p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 3.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>fill(self: brille._brille.BZMeshQdd, values_data: numpy.ndarray[numpy.float64], values_elements: numpy.ndarray[numpy.int32], values_weights: numpy.ndarray[numpy.float64], vectors_data: numpy.ndarray[numpy.float64], vectors_elements: numpy.ndarray[numpy.int32], vectors_weights: numpy.ndarray[numpy.float64], sort: bool = False) -&gt; None</p></li>
</ol>
<p>Provide all data required for interpolation to the grid at once</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>values_data</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – The eigenvalue data to be stored in the grid. The first dimension must be
equal in size to the number of grid-vertices. If two dimensional the second
dimension is interpreted as all information for a single mode flattened
and concatenated into (scalars, vectors, matrices) – in that order.
If more than two dimensional, the second dimension indexes modes and
higher dimensions will be flattened <em>as if row ordered</em> and must flatten into
a concatenated list of (scalars, vectors, matrices).
If the provided array can be interpreted as a contiguous row-ordered two
dimensional array it will be used in place, otherwise a copy will be made.</p></li>
<li><p><strong>values_elements</strong> (<em>integer vector-like</em>) – A multi-purpose vector containing, in order:</p>
<ul class="simple">
<li><p>the number of scalar-like eigenvalue elements,</p></li>
<li><p>the number of vector-like eigenvalue <em>elements</em> (must be <span class="math">\(3\times N\)</span>),</p></li>
<li><p>the number of matrix-like eigenvalue <em>elements</em> (must be <span class="math">\(9\times N\)</span>),</p></li>
<li><p>an integer <a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> value denoting
<em>how</em> the vector-like and matrix-like parts transform under application
of a symmetry operation (see note below),</p></li>
<li><p>an integer <a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a> value denoting what units
the vector-like and matrix-like parts are in (see note below)</p></li>
<li><p>which scalar cost function should be used (see below),</p></li>
<li><p>which vector cost function should be used (see below).</p></li>
</ul>
<p>See the note below for the meaning of the last three values.</p>
</li>
<li><p><strong>values_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvalue elements stored in the grid</p></li>
<li><p><strong>vectors_data</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – The eigenvector data to be stored in the grid. Same shape restrictions as
<strong>values_data</strong></p></li>
<li><p><strong>vectors_elements</strong> – Like <strong>values_elements</strong> but for the eigenvectors</p></li>
<li><p><strong>vectors_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvector elements stored in the grid</p></li>
<li><p><strong>sort</strong> (logical (default <code class="docutils literal notranslate"><span class="pre">False</span></code>)) – Whether the equivalent-mode permutations should be (re)determined following
the update to the flags and weights.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Mapping of integers to <a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>vector</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>pseudovector</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>Gamma</cite></p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to <a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>none</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>angstrom</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>inverse_angstrom</cite></p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p><cite>real_lattice</cite></p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p><cite>reciprocal_lattice</cite></p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 3.</p>
<p>Mapping of integers to scalar cost function:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(x,y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>magnitude(x-y)</p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to vector cost function:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(vec_x, vec_y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>sin(hermitian_angle(vec_x, vec_y))</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>vector_distance(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>1 - vector_product(vec_x, vec_y)</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>vector_angle(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>hermitian_angle(vec_x, vec_y)</p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 0.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZMeshQdd.from_file">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">entry</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'BZMeshQdd'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="module/grids.html#brille._brille.BZMeshQdd" title="brille._brille.BZMeshQdd"><span class="pre">brille._brille.BZMeshQdd</span></a></span></span><a class="headerlink" href="#brille.BZMeshQdd.from_file" title="Link to this definition"></a></dt>
<dd><p>Save the object to an HDF5 file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> (<em>str</em>) – The full path specification for the file to read from</p></li>
<li><p><strong>entry</strong> (<em>str</em>) – The group path, e.g., “my/cool/grid”, where to read from inside the file,
with a default equal to the object Class name</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>clsObj</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZMeshQdd.invA">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">invA</span></span><a class="headerlink" href="#brille.BZMeshQdd.invA" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZMeshQdd.ir_interpolate_at">
<span class="sig-name descname"><span class="pre">ir_interpolate_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZMeshQdd" title="brille._brille.BZMeshQdd"><span class="pre">brille._brille.BZMeshQdd</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">useparallel</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threads</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">do_not_move_points</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#brille.BZMeshQdd.ir_interpolate_at" title="Link to this definition"></a></dt>
<dd><p>Perform linear interpolation of the stored data at irreducible equivalent points</p>
<p>The irreducible first Brillouin zone is the part of reciprocal space which is
invariant under application of the integer translations <em>and</em> the pointgroup
operations of a reciprocal space lattice. This method finds points equivalent
to the input within the irreducible first Brillouin zone and then interpolates
pre-stored information to provide an estimate at the found positions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Q</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – A two dimensional array with <code class="docutils literal notranslate"><span class="pre">Q.shape[1]</span> <span class="pre">==</span> <span class="pre">3</span></code> containing the positions at
which an interpolated result is required, expressed in units of the
reciprocal lattice.</p></li>
<li><p><strong>useparallel</strong> (<em>bool, optional</em>) – Whether a serial or parallel code should be utilised</p></li>
<li><p><strong>threads</strong> (<em>int, optional</em>) – How many OpenMP workers should be utilised; if this value is less than one
the environment variable <code class="docutils literal notranslate"><span class="pre">OMP_NUM_THREADS</span></code> will be used.</p></li>
<li><p><strong>do_not_move_points</strong> (<em>bool, optional</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code> the provided <strong>Q</strong> points must already lie within the first Brillouin
zone. No check is made to verify this requirement and if any <strong>Q</strong> lie outside
of the gridded volume out-of-bounds errors may result in bad data or runtime
errors.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The interpolated eigenvalues and eigenvectors at the equivalent
irreducible first Brillouin zone points.
The shape of each output will depend on the shape of the data provided to
the <a class="reference internal" href="module/grids.html#brille._brille.BZTrellisQdc.fill" title="brille._brille.BZTrellisQdc.fill"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fill()</span></code></a> method. i
If the filled eigenvalues were of shape
<code class="docutils literal notranslate"><span class="pre">[N_grid_points,</span> <span class="pre">N_modes,</span> <span class="pre">A,</span> <span class="pre">...,</span> <span class="pre">B]</span></code>, the eigenvectors were of shape
<code class="docutils literal notranslate"><span class="pre">[N_grid_points,</span> <span class="pre">N_modes,</span> <span class="pre">C,</span> <span class="pre">...,</span> <span class="pre">D]</span></code>, and the provided points of shape
<code class="docutils literal notranslate"><span class="pre">[N_Q_points,</span> <span class="pre">3]</span></code> then the output shapes will be
<code class="docutils literal notranslate"><span class="pre">[N_Q_points,</span> <span class="pre">N_modes,</span> <span class="pre">A,</span> <span class="pre">...,</span> <span class="pre">B]</span></code> and <code class="docutils literal notranslate"><span class="pre">[N_Q_points,</span> <span class="pre">N_modes,</span> <span class="pre">C,</span> <span class="pre">...,</span> <span class="pre">D]</span></code>
for the eigenvalues and eigenvectors, respectively.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZMeshQdd.rlu">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">rlu</span></span><a class="headerlink" href="#brille.BZMeshQdd.rlu" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZMeshQdd.set_flags_weights">
<span class="sig-name descname"><span class="pre">set_flags_weights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZMeshQdd" title="brille._brille.BZMeshQdd"><span class="pre">brille._brille.BZMeshQdd</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">values_flags</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">values_weights</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vectors_flags</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vectors_weights</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#brille.BZMeshQdd.set_flags_weights" title="Link to this definition"></a></dt>
<dd><p>Set <a class="reference internal" href="module/grids.html#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a>, <cite>~brille._brille.LengthUnit</cite>
and cost functions plus relative cost weights for the values and vectors
stored in the object</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>values_flags</strong> (<em>integer, vector-like</em>) – One or more values indicating the <a class="reference internal" href="module/grids.html#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a>
value for the eigenvalues stored in the object, the <cite>~brille._brille.LengthUnit</cite>
value, plus which cost function to use when comparing stored eigenvalues at
neighbouring grid points for scalar- and vector-like eigenvalues.</p></li>
<li><p><strong>values_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvalue elements stored in the grid</p></li>
<li><p><strong>vectors_flags</strong> (<em>integer, vector-like</em>) – One or more values indicating the <a class="reference internal" href="module/grids.html#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a>
value for the eigenvalues stored in the object, the <cite>~brille._brille.LengthUnit</cite>
value, plus which cost function to use when comparing stored eigenvectors at
neighbouring grid points for scalar- and vector-like eigenvectors.</p></li>
<li><p><strong>vectors_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvector elements stored in the grid</p></li>
<li><p><strong>sort</strong> (<em>bool, optional</em>) – Whether the equivalent-mode permutations should be (re)determined following
the update to the flags and weights.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Mapping of integers to <a class="reference internal" href="module/grids.html#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>vector</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>pseudovector</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>Gamma</cite></p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to <a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>none</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>angstrom</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>inverse_angstrom</cite></p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p><cite>real_lattice</cite></p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p><cite>reciprocal_lattice</cite></p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to scalar cost function:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(x,y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>magnitude(x-y)</p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to vector cost function:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(vec_x, vec_y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>sin(hermitian_angle(vec_x, vec_y))</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>vector_distance(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>1 - vector_product(vec_x, vec_y)</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>vector_angle(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>hermitian_angle(vec_x, vec_y)</p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 0.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZMeshQdd.sort">
<span class="sig-name descname"><span class="pre">sort</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZMeshQdd" title="brille._brille.BZMeshQdd"><span class="pre">brille._brille.BZMeshQdd</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#brille.BZMeshQdd.sort" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZMeshQdd.tetrahedra">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">tetrahedra</span></span><a class="headerlink" href="#brille.BZMeshQdd.tetrahedra" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZMeshQdd.to_file">
<span class="sig-name descname"><span class="pre">to_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZMeshQdd" title="brille._brille.BZMeshQdd"><span class="pre">brille._brille.BZMeshQdd</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">entry</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'BZMeshQdd'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'ac'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#brille.BZMeshQdd.to_file" title="Link to this definition"></a></dt>
<dd><p>Save the object to an HDF5 file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> (<em>str</em>) – The full path specification for the file to write into</p></li>
<li><p><strong>entry</strong> (<em>str</em>) – The group path, e.g., “my/cool/grid”, where to write inside the file,
with a default equal to the object Class name</p></li>
<li><p><strong>flags</strong> (<em>str</em>) – The HDF5 permissions to use when opening the file. Default ‘a’ writes to an
existing file – if <cite>entry</cite> exists in the file it is overwritten.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Possible <cite>flags</cite> are:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><cite>flags</cite></p></th>
<th class="head"><p>meaning</p></th>
<th class="head"><p>HDF equivalent</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>‘r’</p></td>
<td><p>read</p></td>
<td><p>H5F_ACC_RDONLY</p></td>
</tr>
<tr class="row-odd"><td><p>‘x’</p></td>
<td><p>write, error if exists</p></td>
<td><p>H5F_ACC_EXCL</p></td>
</tr>
<tr class="row-even"><td><p>‘a’</p></td>
<td><p>write, append to file</p></td>
<td><p>H5F_ACC_RDWR</p></td>
</tr>
<tr class="row-odd"><td><p>‘c’</p></td>
<td><p>write, error if exists</p></td>
<td><p>H5F_ACC_CREAT</p></td>
</tr>
<tr class="row-even"><td><p>‘t’</p></td>
<td><p>write, replace existing</p></td>
<td><p>H5F_ACC_TRUNC</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Indication of writing success.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZMeshQdd.values">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">values</span></span><a class="headerlink" href="#brille.BZMeshQdd.values" title="Link to this definition"></a></dt>
<dd><p>Return a shared view of the stored eigenvalues</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZMeshQdd.vectors">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">vectors</span></span><a class="headerlink" href="#brille.BZMeshQdd.vectors" title="Link to this definition"></a></dt>
<dd><p>Return a shared view of the stored eigenvectors</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="brille.BZNestQcc">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">brille.</span></span><span class="sig-name descname"><span class="pre">BZNestQcc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille.BZNestQcc" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: brille._brille.BZNestQcc, brillouin_zone: brille._brille.BrillouinZone, max_volume: float, max_branchings: int = 5) -&gt; None</p></li>
<li><p>__init__(self: brille._brille.BZNestQcc, brillouin_zone: brille._brille.BrillouinZone, number_density: int, max_branchings: int = 5) -&gt; None</p></li>
</ol>
<dl class="py property">
<dt class="sig sig-object py" id="brille.BZNestQcc.BrillouinZone">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">BrillouinZone</span></span><a class="headerlink" href="#brille.BZNestQcc.BrillouinZone" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZNestQcc.all_invA">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">all_invA</span></span><a class="headerlink" href="#brille.BZNestQcc.all_invA" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZNestQcc.all_rlu">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">all_rlu</span></span><a class="headerlink" href="#brille.BZNestQcc.all_rlu" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZNestQcc.bytes_per_point">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bytes_per_point</span></span><a class="headerlink" href="#brille.BZNestQcc.bytes_per_point" title="Link to this definition"></a></dt>
<dd><p>Return the memory required per interpolation point <em>result</em> in bytes</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZNestQcc.fill">
<span class="sig-name descname"><span class="pre">fill</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille.BZNestQcc.fill" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>fill(self: brille._brille.BZNestQcc, values_data: numpy.ndarray[numpy.complex128], values_elements: numpy.ndarray[numpy.int32], vectors_data: numpy.ndarray[numpy.complex128], vectors_elements: numpy.ndarray[numpy.int32], sort: bool = False) -&gt; None</p></li>
</ol>
<p>Provide data required for interpolation to the grid without cost information.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>values_data</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – The eigenvalue data to be stored in the grid. The first dimension must be
equal in size to the number of grid-vertices. If two dimensional the second
dimension is interpreted as all information for a single mode flattened
and concatenated into (scalars, vectors, matrices) – in that order.
If more than two dimensional, the second dimension indexes modes and
higher dimensions will be flattened <em>as if row ordered</em> and must flatten into
a concatenated list of (scalars, vectors, matrices).
If the provided array can be interpreted as a contiguous row-ordered two
dimensional array it will be used in place, otherwise a copy will be made.</p></li>
<li><p><strong>values_elements</strong> (<em>integer vector-like</em>) – A multi-purpose vector containing, in order:</p>
<ul>
<li><p>the number of scalar-like eigenvalue elements,</p></li>
<li><p>the number of vector-like eigenvalue <em>elements</em> (must be <span class="math">\(3\times N\)</span>),</p></li>
<li><p>the number of matrix-like eigenvalue <em>elements</em> (must be <span class="math">\(9\times N\)</span>),</p></li>
<li><p>an integer <a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> value denoting
<em>how</em> the vector-like and matrix-like parts transform under application
of a symmetry operation (see note below).</p></li>
<li><p>an integer <a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a> value denoting what units
the vector-like and matrix-like parts are in (see note below).</p></li>
</ul>
</li>
<li><p><strong>vectors_data</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – The eigenvector data to be stored in the grid. Same shape restrictions as
<code class="docutils literal notranslate"><span class="pre">values_data</span></code></p></li>
<li><p><strong>vectors_elements</strong> – Like <code class="docutils literal notranslate"><span class="pre">values_elements</span></code> but for the eigenvectors</p></li>
<li><p><strong>sort</strong> (logical (default <code class="docutils literal notranslate"><span class="pre">False</span></code>)) – Whether the equivalent-mode permutations should be (re)determined following
the update to the flags and weights.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Mapping of integers to <a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>vector</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>pseudovector</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>Gamma</cite></p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 0.</p>
<p>Mapping of integers to <a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>none</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>angstrom</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>inverse_angstrom</cite></p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p><cite>real_lattice</cite></p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p><cite>reciprocal_lattice</cite></p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 3.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>fill(self: brille._brille.BZNestQcc, values_data: numpy.ndarray[numpy.complex128], values_elements: numpy.ndarray[numpy.int32], values_weights: numpy.ndarray[numpy.float64], vectors_data: numpy.ndarray[numpy.complex128], vectors_elements: numpy.ndarray[numpy.int32], vectors_weights: numpy.ndarray[numpy.float64], sort: bool = False) -&gt; None</p></li>
</ol>
<p>Provide all data required for interpolation to the grid at once</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>values_data</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – The eigenvalue data to be stored in the grid. The first dimension must be
equal in size to the number of grid-vertices. If two dimensional the second
dimension is interpreted as all information for a single mode flattened
and concatenated into (scalars, vectors, matrices) – in that order.
If more than two dimensional, the second dimension indexes modes and
higher dimensions will be flattened <em>as if row ordered</em> and must flatten into
a concatenated list of (scalars, vectors, matrices).
If the provided array can be interpreted as a contiguous row-ordered two
dimensional array it will be used in place, otherwise a copy will be made.</p></li>
<li><p><strong>values_elements</strong> (<em>integer vector-like</em>) – A multi-purpose vector containing, in order:</p>
<ul class="simple">
<li><p>the number of scalar-like eigenvalue elements,</p></li>
<li><p>the number of vector-like eigenvalue <em>elements</em> (must be <span class="math">\(3\times N\)</span>),</p></li>
<li><p>the number of matrix-like eigenvalue <em>elements</em> (must be <span class="math">\(9\times N\)</span>),</p></li>
<li><p>an integer <a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> value denoting
<em>how</em> the vector-like and matrix-like parts transform under application
of a symmetry operation (see note below),</p></li>
<li><p>an integer <a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a> value denoting what units
the vector-like and matrix-like parts are in (see note below)</p></li>
<li><p>which scalar cost function should be used (see below),</p></li>
<li><p>which vector cost function should be used (see below).</p></li>
</ul>
<p>See the note below for the meaning of the last three values.</p>
</li>
<li><p><strong>values_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvalue elements stored in the grid</p></li>
<li><p><strong>vectors_data</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – The eigenvector data to be stored in the grid. Same shape restrictions as
<strong>values_data</strong></p></li>
<li><p><strong>vectors_elements</strong> – Like <strong>values_elements</strong> but for the eigenvectors</p></li>
<li><p><strong>vectors_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvector elements stored in the grid</p></li>
<li><p><strong>sort</strong> (logical (default <code class="docutils literal notranslate"><span class="pre">False</span></code>)) – Whether the equivalent-mode permutations should be (re)determined following
the update to the flags and weights.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Mapping of integers to <a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>vector</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>pseudovector</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>Gamma</cite></p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to <a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>none</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>angstrom</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>inverse_angstrom</cite></p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p><cite>real_lattice</cite></p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p><cite>reciprocal_lattice</cite></p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 3.</p>
<p>Mapping of integers to scalar cost function:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(x,y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>magnitude(x-y)</p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to vector cost function:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(vec_x, vec_y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>sin(hermitian_angle(vec_x, vec_y))</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>vector_distance(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>1 - vector_product(vec_x, vec_y)</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>vector_angle(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>hermitian_angle(vec_x, vec_y)</p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 0.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZNestQcc.from_file">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">entry</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'BZNestQcc'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="module/grids.html#brille._brille.BZNestQcc" title="brille._brille.BZNestQcc"><span class="pre">brille._brille.BZNestQcc</span></a></span></span><a class="headerlink" href="#brille.BZNestQcc.from_file" title="Link to this definition"></a></dt>
<dd><p>Save the object to an HDF5 file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> (<em>str</em>) – The full path specification for the file to read from</p></li>
<li><p><strong>entry</strong> (<em>str</em>) – The group path, e.g., “my/cool/grid”, where to read from inside the file,
with a default equal to the object Class name</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>clsObj</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZNestQcc.invA">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">invA</span></span><a class="headerlink" href="#brille.BZNestQcc.invA" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZNestQcc.ir_interpolate_at">
<span class="sig-name descname"><span class="pre">ir_interpolate_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZNestQcc" title="brille._brille.BZNestQcc"><span class="pre">brille._brille.BZNestQcc</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">useparallel</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threads</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">do_not_move_points</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.complex128</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.complex128</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#brille.BZNestQcc.ir_interpolate_at" title="Link to this definition"></a></dt>
<dd><p>Perform linear interpolation of the stored data at irreducible equivalent points</p>
<p>The irreducible first Brillouin zone is the part of reciprocal space which is
invariant under application of the integer translations <em>and</em> the pointgroup
operations of a reciprocal space lattice. This method finds points equivalent
to the input within the irreducible first Brillouin zone and then interpolates
pre-stored information to provide an estimate at the found positions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Q</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – A two dimensional array with <code class="docutils literal notranslate"><span class="pre">Q.shape[1]</span> <span class="pre">==</span> <span class="pre">3</span></code> containing the positions at
which an interpolated result is required, expressed in units of the
reciprocal lattice.</p></li>
<li><p><strong>useparallel</strong> (<em>bool, optional</em>) – Whether a serial or parallel code should be utilised</p></li>
<li><p><strong>threads</strong> (<em>int, optional</em>) – How many OpenMP workers should be utilised; if this value is less than one
the environment variable <code class="docutils literal notranslate"><span class="pre">OMP_NUM_THREADS</span></code> will be used.</p></li>
<li><p><strong>do_not_move_points</strong> (<em>bool, optional</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code> the provided <strong>Q</strong> points must already lie within the first Brillouin
zone. No check is made to verify this requirement and if any <strong>Q</strong> lie outside
of the gridded volume out-of-bounds errors may result in bad data or runtime
errors.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The interpolated eigenvalues and eigenvectors at the equivalent
irreducible first Brillouin zone points.
The shape of each output will depend on the shape of the data provided to
the <a class="reference internal" href="module/grids.html#brille._brille.BZTrellisQdc.fill" title="brille._brille.BZTrellisQdc.fill"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fill()</span></code></a> method. i
If the filled eigenvalues were of shape
<code class="docutils literal notranslate"><span class="pre">[N_grid_points,</span> <span class="pre">N_modes,</span> <span class="pre">A,</span> <span class="pre">...,</span> <span class="pre">B]</span></code>, the eigenvectors were of shape
<code class="docutils literal notranslate"><span class="pre">[N_grid_points,</span> <span class="pre">N_modes,</span> <span class="pre">C,</span> <span class="pre">...,</span> <span class="pre">D]</span></code>, and the provided points of shape
<code class="docutils literal notranslate"><span class="pre">[N_Q_points,</span> <span class="pre">3]</span></code> then the output shapes will be
<code class="docutils literal notranslate"><span class="pre">[N_Q_points,</span> <span class="pre">N_modes,</span> <span class="pre">A,</span> <span class="pre">...,</span> <span class="pre">B]</span></code> and <code class="docutils literal notranslate"><span class="pre">[N_Q_points,</span> <span class="pre">N_modes,</span> <span class="pre">C,</span> <span class="pre">...,</span> <span class="pre">D]</span></code>
for the eigenvalues and eigenvectors, respectively.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZNestQcc.rlu">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">rlu</span></span><a class="headerlink" href="#brille.BZNestQcc.rlu" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZNestQcc.set_flags_weights">
<span class="sig-name descname"><span class="pre">set_flags_weights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZNestQcc" title="brille._brille.BZNestQcc"><span class="pre">brille._brille.BZNestQcc</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">values_flags</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">values_weights</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vectors_flags</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vectors_weights</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#brille.BZNestQcc.set_flags_weights" title="Link to this definition"></a></dt>
<dd><p>Set <a class="reference internal" href="module/grids.html#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a>, <cite>~brille._brille.LengthUnit</cite>
and cost functions plus relative cost weights for the values and vectors
stored in the object</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>values_flags</strong> (<em>integer, vector-like</em>) – One or more values indicating the <a class="reference internal" href="module/grids.html#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a>
value for the eigenvalues stored in the object, the <cite>~brille._brille.LengthUnit</cite>
value, plus which cost function to use when comparing stored eigenvalues at
neighbouring grid points for scalar- and vector-like eigenvalues.</p></li>
<li><p><strong>values_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvalue elements stored in the grid</p></li>
<li><p><strong>vectors_flags</strong> (<em>integer, vector-like</em>) – One or more values indicating the <a class="reference internal" href="module/grids.html#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a>
value for the eigenvalues stored in the object, the <cite>~brille._brille.LengthUnit</cite>
value, plus which cost function to use when comparing stored eigenvectors at
neighbouring grid points for scalar- and vector-like eigenvectors.</p></li>
<li><p><strong>vectors_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvector elements stored in the grid</p></li>
<li><p><strong>sort</strong> (<em>bool, optional</em>) – Whether the equivalent-mode permutations should be (re)determined following
the update to the flags and weights.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Mapping of integers to <a class="reference internal" href="module/grids.html#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>vector</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>pseudovector</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>Gamma</cite></p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to <a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>none</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>angstrom</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>inverse_angstrom</cite></p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p><cite>real_lattice</cite></p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p><cite>reciprocal_lattice</cite></p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to scalar cost function:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(x,y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>magnitude(x-y)</p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to vector cost function:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(vec_x, vec_y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>sin(hermitian_angle(vec_x, vec_y))</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>vector_distance(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>1 - vector_product(vec_x, vec_y)</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>vector_angle(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>hermitian_angle(vec_x, vec_y)</p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 0.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZNestQcc.sort">
<span class="sig-name descname"><span class="pre">sort</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZNestQcc" title="brille._brille.BZNestQcc"><span class="pre">brille._brille.BZNestQcc</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#brille.BZNestQcc.sort" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZNestQcc.tetrahedra">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">tetrahedra</span></span><a class="headerlink" href="#brille.BZNestQcc.tetrahedra" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZNestQcc.to_file">
<span class="sig-name descname"><span class="pre">to_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZNestQcc" title="brille._brille.BZNestQcc"><span class="pre">brille._brille.BZNestQcc</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">entry</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'BZNestQcc'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'ac'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#brille.BZNestQcc.to_file" title="Link to this definition"></a></dt>
<dd><p>Save the object to an HDF5 file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> (<em>str</em>) – The full path specification for the file to write into</p></li>
<li><p><strong>entry</strong> (<em>str</em>) – The group path, e.g., “my/cool/grid”, where to write inside the file,
with a default equal to the object Class name</p></li>
<li><p><strong>flags</strong> (<em>str</em>) – The HDF5 permissions to use when opening the file. Default ‘a’ writes to an
existing file – if <cite>entry</cite> exists in the file it is overwritten.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Possible <cite>flags</cite> are:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><cite>flags</cite></p></th>
<th class="head"><p>meaning</p></th>
<th class="head"><p>HDF equivalent</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>‘r’</p></td>
<td><p>read</p></td>
<td><p>H5F_ACC_RDONLY</p></td>
</tr>
<tr class="row-odd"><td><p>‘x’</p></td>
<td><p>write, error if exists</p></td>
<td><p>H5F_ACC_EXCL</p></td>
</tr>
<tr class="row-even"><td><p>‘a’</p></td>
<td><p>write, append to file</p></td>
<td><p>H5F_ACC_RDWR</p></td>
</tr>
<tr class="row-odd"><td><p>‘c’</p></td>
<td><p>write, error if exists</p></td>
<td><p>H5F_ACC_CREAT</p></td>
</tr>
<tr class="row-even"><td><p>‘t’</p></td>
<td><p>write, replace existing</p></td>
<td><p>H5F_ACC_TRUNC</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Indication of writing success.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZNestQcc.values">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">values</span></span><a class="headerlink" href="#brille.BZNestQcc.values" title="Link to this definition"></a></dt>
<dd><p>Return a shared view of the stored eigenvalues</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZNestQcc.vectors">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">vectors</span></span><a class="headerlink" href="#brille.BZNestQcc.vectors" title="Link to this definition"></a></dt>
<dd><p>Return a shared view of the stored eigenvectors</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="brille.BZNestQdc">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">brille.</span></span><span class="sig-name descname"><span class="pre">BZNestQdc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille.BZNestQdc" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: brille._brille.BZNestQdc, brillouin_zone: brille._brille.BrillouinZone, max_volume: float, max_branchings: int = 5) -&gt; None</p></li>
<li><p>__init__(self: brille._brille.BZNestQdc, brillouin_zone: brille._brille.BrillouinZone, number_density: int, max_branchings: int = 5) -&gt; None</p></li>
</ol>
<dl class="py property">
<dt class="sig sig-object py" id="brille.BZNestQdc.BrillouinZone">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">BrillouinZone</span></span><a class="headerlink" href="#brille.BZNestQdc.BrillouinZone" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZNestQdc.all_invA">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">all_invA</span></span><a class="headerlink" href="#brille.BZNestQdc.all_invA" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZNestQdc.all_rlu">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">all_rlu</span></span><a class="headerlink" href="#brille.BZNestQdc.all_rlu" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZNestQdc.bytes_per_point">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bytes_per_point</span></span><a class="headerlink" href="#brille.BZNestQdc.bytes_per_point" title="Link to this definition"></a></dt>
<dd><p>Return the memory required per interpolation point <em>result</em> in bytes</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZNestQdc.fill">
<span class="sig-name descname"><span class="pre">fill</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille.BZNestQdc.fill" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>fill(self: brille._brille.BZNestQdc, values_data: numpy.ndarray[numpy.float64], values_elements: numpy.ndarray[numpy.int32], vectors_data: numpy.ndarray[numpy.complex128], vectors_elements: numpy.ndarray[numpy.int32], sort: bool = False) -&gt; None</p></li>
</ol>
<p>Provide data required for interpolation to the grid without cost information.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>values_data</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – The eigenvalue data to be stored in the grid. The first dimension must be
equal in size to the number of grid-vertices. If two dimensional the second
dimension is interpreted as all information for a single mode flattened
and concatenated into (scalars, vectors, matrices) – in that order.
If more than two dimensional, the second dimension indexes modes and
higher dimensions will be flattened <em>as if row ordered</em> and must flatten into
a concatenated list of (scalars, vectors, matrices).
If the provided array can be interpreted as a contiguous row-ordered two
dimensional array it will be used in place, otherwise a copy will be made.</p></li>
<li><p><strong>values_elements</strong> (<em>integer vector-like</em>) – A multi-purpose vector containing, in order:</p>
<ul>
<li><p>the number of scalar-like eigenvalue elements,</p></li>
<li><p>the number of vector-like eigenvalue <em>elements</em> (must be <span class="math">\(3\times N\)</span>),</p></li>
<li><p>the number of matrix-like eigenvalue <em>elements</em> (must be <span class="math">\(9\times N\)</span>),</p></li>
<li><p>an integer <a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> value denoting
<em>how</em> the vector-like and matrix-like parts transform under application
of a symmetry operation (see note below).</p></li>
<li><p>an integer <a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a> value denoting what units
the vector-like and matrix-like parts are in (see note below).</p></li>
</ul>
</li>
<li><p><strong>vectors_data</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – The eigenvector data to be stored in the grid. Same shape restrictions as
<code class="docutils literal notranslate"><span class="pre">values_data</span></code></p></li>
<li><p><strong>vectors_elements</strong> – Like <code class="docutils literal notranslate"><span class="pre">values_elements</span></code> but for the eigenvectors</p></li>
<li><p><strong>sort</strong> (logical (default <code class="docutils literal notranslate"><span class="pre">False</span></code>)) – Whether the equivalent-mode permutations should be (re)determined following
the update to the flags and weights.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Mapping of integers to <a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>vector</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>pseudovector</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>Gamma</cite></p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 0.</p>
<p>Mapping of integers to <a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>none</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>angstrom</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>inverse_angstrom</cite></p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p><cite>real_lattice</cite></p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p><cite>reciprocal_lattice</cite></p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 3.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>fill(self: brille._brille.BZNestQdc, values_data: numpy.ndarray[numpy.float64], values_elements: numpy.ndarray[numpy.int32], values_weights: numpy.ndarray[numpy.float64], vectors_data: numpy.ndarray[numpy.complex128], vectors_elements: numpy.ndarray[numpy.int32], vectors_weights: numpy.ndarray[numpy.float64], sort: bool = False) -&gt; None</p></li>
</ol>
<p>Provide all data required for interpolation to the grid at once</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>values_data</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – The eigenvalue data to be stored in the grid. The first dimension must be
equal in size to the number of grid-vertices. If two dimensional the second
dimension is interpreted as all information for a single mode flattened
and concatenated into (scalars, vectors, matrices) – in that order.
If more than two dimensional, the second dimension indexes modes and
higher dimensions will be flattened <em>as if row ordered</em> and must flatten into
a concatenated list of (scalars, vectors, matrices).
If the provided array can be interpreted as a contiguous row-ordered two
dimensional array it will be used in place, otherwise a copy will be made.</p></li>
<li><p><strong>values_elements</strong> (<em>integer vector-like</em>) – A multi-purpose vector containing, in order:</p>
<ul class="simple">
<li><p>the number of scalar-like eigenvalue elements,</p></li>
<li><p>the number of vector-like eigenvalue <em>elements</em> (must be <span class="math">\(3\times N\)</span>),</p></li>
<li><p>the number of matrix-like eigenvalue <em>elements</em> (must be <span class="math">\(9\times N\)</span>),</p></li>
<li><p>an integer <a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> value denoting
<em>how</em> the vector-like and matrix-like parts transform under application
of a symmetry operation (see note below),</p></li>
<li><p>an integer <a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a> value denoting what units
the vector-like and matrix-like parts are in (see note below)</p></li>
<li><p>which scalar cost function should be used (see below),</p></li>
<li><p>which vector cost function should be used (see below).</p></li>
</ul>
<p>See the note below for the meaning of the last three values.</p>
</li>
<li><p><strong>values_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvalue elements stored in the grid</p></li>
<li><p><strong>vectors_data</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – The eigenvector data to be stored in the grid. Same shape restrictions as
<strong>values_data</strong></p></li>
<li><p><strong>vectors_elements</strong> – Like <strong>values_elements</strong> but for the eigenvectors</p></li>
<li><p><strong>vectors_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvector elements stored in the grid</p></li>
<li><p><strong>sort</strong> (logical (default <code class="docutils literal notranslate"><span class="pre">False</span></code>)) – Whether the equivalent-mode permutations should be (re)determined following
the update to the flags and weights.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Mapping of integers to <a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>vector</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>pseudovector</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>Gamma</cite></p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to <a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>none</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>angstrom</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>inverse_angstrom</cite></p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p><cite>real_lattice</cite></p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p><cite>reciprocal_lattice</cite></p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 3.</p>
<p>Mapping of integers to scalar cost function:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(x,y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>magnitude(x-y)</p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to vector cost function:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(vec_x, vec_y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>sin(hermitian_angle(vec_x, vec_y))</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>vector_distance(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>1 - vector_product(vec_x, vec_y)</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>vector_angle(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>hermitian_angle(vec_x, vec_y)</p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 0.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZNestQdc.from_file">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">entry</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'BZNestQdc'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="module/grids.html#brille._brille.BZNestQdc" title="brille._brille.BZNestQdc"><span class="pre">brille._brille.BZNestQdc</span></a></span></span><a class="headerlink" href="#brille.BZNestQdc.from_file" title="Link to this definition"></a></dt>
<dd><p>Save the object to an HDF5 file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> (<em>str</em>) – The full path specification for the file to read from</p></li>
<li><p><strong>entry</strong> (<em>str</em>) – The group path, e.g., “my/cool/grid”, where to read from inside the file,
with a default equal to the object Class name</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>clsObj</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZNestQdc.invA">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">invA</span></span><a class="headerlink" href="#brille.BZNestQdc.invA" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZNestQdc.ir_interpolate_at">
<span class="sig-name descname"><span class="pre">ir_interpolate_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZNestQdc" title="brille._brille.BZNestQdc"><span class="pre">brille._brille.BZNestQdc</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">useparallel</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threads</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">do_not_move_points</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.complex128</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#brille.BZNestQdc.ir_interpolate_at" title="Link to this definition"></a></dt>
<dd><p>Perform linear interpolation of the stored data at irreducible equivalent points</p>
<p>The irreducible first Brillouin zone is the part of reciprocal space which is
invariant under application of the integer translations <em>and</em> the pointgroup
operations of a reciprocal space lattice. This method finds points equivalent
to the input within the irreducible first Brillouin zone and then interpolates
pre-stored information to provide an estimate at the found positions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Q</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – A two dimensional array with <code class="docutils literal notranslate"><span class="pre">Q.shape[1]</span> <span class="pre">==</span> <span class="pre">3</span></code> containing the positions at
which an interpolated result is required, expressed in units of the
reciprocal lattice.</p></li>
<li><p><strong>useparallel</strong> (<em>bool, optional</em>) – Whether a serial or parallel code should be utilised</p></li>
<li><p><strong>threads</strong> (<em>int, optional</em>) – How many OpenMP workers should be utilised; if this value is less than one
the environment variable <code class="docutils literal notranslate"><span class="pre">OMP_NUM_THREADS</span></code> will be used.</p></li>
<li><p><strong>do_not_move_points</strong> (<em>bool, optional</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code> the provided <strong>Q</strong> points must already lie within the first Brillouin
zone. No check is made to verify this requirement and if any <strong>Q</strong> lie outside
of the gridded volume out-of-bounds errors may result in bad data or runtime
errors.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The interpolated eigenvalues and eigenvectors at the equivalent
irreducible first Brillouin zone points.
The shape of each output will depend on the shape of the data provided to
the <a class="reference internal" href="module/grids.html#brille._brille.BZTrellisQdc.fill" title="brille._brille.BZTrellisQdc.fill"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fill()</span></code></a> method. i
If the filled eigenvalues were of shape
<code class="docutils literal notranslate"><span class="pre">[N_grid_points,</span> <span class="pre">N_modes,</span> <span class="pre">A,</span> <span class="pre">...,</span> <span class="pre">B]</span></code>, the eigenvectors were of shape
<code class="docutils literal notranslate"><span class="pre">[N_grid_points,</span> <span class="pre">N_modes,</span> <span class="pre">C,</span> <span class="pre">...,</span> <span class="pre">D]</span></code>, and the provided points of shape
<code class="docutils literal notranslate"><span class="pre">[N_Q_points,</span> <span class="pre">3]</span></code> then the output shapes will be
<code class="docutils literal notranslate"><span class="pre">[N_Q_points,</span> <span class="pre">N_modes,</span> <span class="pre">A,</span> <span class="pre">...,</span> <span class="pre">B]</span></code> and <code class="docutils literal notranslate"><span class="pre">[N_Q_points,</span> <span class="pre">N_modes,</span> <span class="pre">C,</span> <span class="pre">...,</span> <span class="pre">D]</span></code>
for the eigenvalues and eigenvectors, respectively.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZNestQdc.rlu">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">rlu</span></span><a class="headerlink" href="#brille.BZNestQdc.rlu" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZNestQdc.set_flags_weights">
<span class="sig-name descname"><span class="pre">set_flags_weights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZNestQdc" title="brille._brille.BZNestQdc"><span class="pre">brille._brille.BZNestQdc</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">values_flags</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">values_weights</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vectors_flags</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vectors_weights</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#brille.BZNestQdc.set_flags_weights" title="Link to this definition"></a></dt>
<dd><p>Set <a class="reference internal" href="module/grids.html#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a>, <cite>~brille._brille.LengthUnit</cite>
and cost functions plus relative cost weights for the values and vectors
stored in the object</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>values_flags</strong> (<em>integer, vector-like</em>) – One or more values indicating the <a class="reference internal" href="module/grids.html#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a>
value for the eigenvalues stored in the object, the <cite>~brille._brille.LengthUnit</cite>
value, plus which cost function to use when comparing stored eigenvalues at
neighbouring grid points for scalar- and vector-like eigenvalues.</p></li>
<li><p><strong>values_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvalue elements stored in the grid</p></li>
<li><p><strong>vectors_flags</strong> (<em>integer, vector-like</em>) – One or more values indicating the <a class="reference internal" href="module/grids.html#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a>
value for the eigenvalues stored in the object, the <cite>~brille._brille.LengthUnit</cite>
value, plus which cost function to use when comparing stored eigenvectors at
neighbouring grid points for scalar- and vector-like eigenvectors.</p></li>
<li><p><strong>vectors_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvector elements stored in the grid</p></li>
<li><p><strong>sort</strong> (<em>bool, optional</em>) – Whether the equivalent-mode permutations should be (re)determined following
the update to the flags and weights.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Mapping of integers to <a class="reference internal" href="module/grids.html#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>vector</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>pseudovector</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>Gamma</cite></p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to <a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>none</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>angstrom</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>inverse_angstrom</cite></p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p><cite>real_lattice</cite></p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p><cite>reciprocal_lattice</cite></p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to scalar cost function:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(x,y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>magnitude(x-y)</p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to vector cost function:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(vec_x, vec_y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>sin(hermitian_angle(vec_x, vec_y))</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>vector_distance(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>1 - vector_product(vec_x, vec_y)</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>vector_angle(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>hermitian_angle(vec_x, vec_y)</p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 0.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZNestQdc.sort">
<span class="sig-name descname"><span class="pre">sort</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZNestQdc" title="brille._brille.BZNestQdc"><span class="pre">brille._brille.BZNestQdc</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#brille.BZNestQdc.sort" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZNestQdc.tetrahedra">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">tetrahedra</span></span><a class="headerlink" href="#brille.BZNestQdc.tetrahedra" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZNestQdc.to_file">
<span class="sig-name descname"><span class="pre">to_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZNestQdc" title="brille._brille.BZNestQdc"><span class="pre">brille._brille.BZNestQdc</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">entry</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'BZNestQdc'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'ac'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#brille.BZNestQdc.to_file" title="Link to this definition"></a></dt>
<dd><p>Save the object to an HDF5 file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> (<em>str</em>) – The full path specification for the file to write into</p></li>
<li><p><strong>entry</strong> (<em>str</em>) – The group path, e.g., “my/cool/grid”, where to write inside the file,
with a default equal to the object Class name</p></li>
<li><p><strong>flags</strong> (<em>str</em>) – The HDF5 permissions to use when opening the file. Default ‘a’ writes to an
existing file – if <cite>entry</cite> exists in the file it is overwritten.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Possible <cite>flags</cite> are:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><cite>flags</cite></p></th>
<th class="head"><p>meaning</p></th>
<th class="head"><p>HDF equivalent</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>‘r’</p></td>
<td><p>read</p></td>
<td><p>H5F_ACC_RDONLY</p></td>
</tr>
<tr class="row-odd"><td><p>‘x’</p></td>
<td><p>write, error if exists</p></td>
<td><p>H5F_ACC_EXCL</p></td>
</tr>
<tr class="row-even"><td><p>‘a’</p></td>
<td><p>write, append to file</p></td>
<td><p>H5F_ACC_RDWR</p></td>
</tr>
<tr class="row-odd"><td><p>‘c’</p></td>
<td><p>write, error if exists</p></td>
<td><p>H5F_ACC_CREAT</p></td>
</tr>
<tr class="row-even"><td><p>‘t’</p></td>
<td><p>write, replace existing</p></td>
<td><p>H5F_ACC_TRUNC</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Indication of writing success.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZNestQdc.values">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">values</span></span><a class="headerlink" href="#brille.BZNestQdc.values" title="Link to this definition"></a></dt>
<dd><p>Return a shared view of the stored eigenvalues</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZNestQdc.vectors">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">vectors</span></span><a class="headerlink" href="#brille.BZNestQdc.vectors" title="Link to this definition"></a></dt>
<dd><p>Return a shared view of the stored eigenvectors</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="brille.BZNestQdd">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">brille.</span></span><span class="sig-name descname"><span class="pre">BZNestQdd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille.BZNestQdd" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: brille._brille.BZNestQdd, brillouin_zone: brille._brille.BrillouinZone, max_volume: float, max_branchings: int = 5) -&gt; None</p></li>
<li><p>__init__(self: brille._brille.BZNestQdd, brillouin_zone: brille._brille.BrillouinZone, number_density: int, max_branchings: int = 5) -&gt; None</p></li>
</ol>
<dl class="py property">
<dt class="sig sig-object py" id="brille.BZNestQdd.BrillouinZone">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">BrillouinZone</span></span><a class="headerlink" href="#brille.BZNestQdd.BrillouinZone" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZNestQdd.all_invA">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">all_invA</span></span><a class="headerlink" href="#brille.BZNestQdd.all_invA" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZNestQdd.all_rlu">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">all_rlu</span></span><a class="headerlink" href="#brille.BZNestQdd.all_rlu" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZNestQdd.bytes_per_point">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bytes_per_point</span></span><a class="headerlink" href="#brille.BZNestQdd.bytes_per_point" title="Link to this definition"></a></dt>
<dd><p>Return the memory required per interpolation point <em>result</em> in bytes</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZNestQdd.fill">
<span class="sig-name descname"><span class="pre">fill</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille.BZNestQdd.fill" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>fill(self: brille._brille.BZNestQdd, values_data: numpy.ndarray[numpy.float64], values_elements: numpy.ndarray[numpy.int32], vectors_data: numpy.ndarray[numpy.float64], vectors_elements: numpy.ndarray[numpy.int32], sort: bool = False) -&gt; None</p></li>
</ol>
<p>Provide data required for interpolation to the grid without cost information.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>values_data</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – The eigenvalue data to be stored in the grid. The first dimension must be
equal in size to the number of grid-vertices. If two dimensional the second
dimension is interpreted as all information for a single mode flattened
and concatenated into (scalars, vectors, matrices) – in that order.
If more than two dimensional, the second dimension indexes modes and
higher dimensions will be flattened <em>as if row ordered</em> and must flatten into
a concatenated list of (scalars, vectors, matrices).
If the provided array can be interpreted as a contiguous row-ordered two
dimensional array it will be used in place, otherwise a copy will be made.</p></li>
<li><p><strong>values_elements</strong> (<em>integer vector-like</em>) – A multi-purpose vector containing, in order:</p>
<ul>
<li><p>the number of scalar-like eigenvalue elements,</p></li>
<li><p>the number of vector-like eigenvalue <em>elements</em> (must be <span class="math">\(3\times N\)</span>),</p></li>
<li><p>the number of matrix-like eigenvalue <em>elements</em> (must be <span class="math">\(9\times N\)</span>),</p></li>
<li><p>an integer <a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> value denoting
<em>how</em> the vector-like and matrix-like parts transform under application
of a symmetry operation (see note below).</p></li>
<li><p>an integer <a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a> value denoting what units
the vector-like and matrix-like parts are in (see note below).</p></li>
</ul>
</li>
<li><p><strong>vectors_data</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – The eigenvector data to be stored in the grid. Same shape restrictions as
<code class="docutils literal notranslate"><span class="pre">values_data</span></code></p></li>
<li><p><strong>vectors_elements</strong> – Like <code class="docutils literal notranslate"><span class="pre">values_elements</span></code> but for the eigenvectors</p></li>
<li><p><strong>sort</strong> (logical (default <code class="docutils literal notranslate"><span class="pre">False</span></code>)) – Whether the equivalent-mode permutations should be (re)determined following
the update to the flags and weights.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Mapping of integers to <a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>vector</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>pseudovector</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>Gamma</cite></p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 0.</p>
<p>Mapping of integers to <a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>none</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>angstrom</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>inverse_angstrom</cite></p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p><cite>real_lattice</cite></p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p><cite>reciprocal_lattice</cite></p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 3.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>fill(self: brille._brille.BZNestQdd, values_data: numpy.ndarray[numpy.float64], values_elements: numpy.ndarray[numpy.int32], values_weights: numpy.ndarray[numpy.float64], vectors_data: numpy.ndarray[numpy.float64], vectors_elements: numpy.ndarray[numpy.int32], vectors_weights: numpy.ndarray[numpy.float64], sort: bool = False) -&gt; None</p></li>
</ol>
<p>Provide all data required for interpolation to the grid at once</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>values_data</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – The eigenvalue data to be stored in the grid. The first dimension must be
equal in size to the number of grid-vertices. If two dimensional the second
dimension is interpreted as all information for a single mode flattened
and concatenated into (scalars, vectors, matrices) – in that order.
If more than two dimensional, the second dimension indexes modes and
higher dimensions will be flattened <em>as if row ordered</em> and must flatten into
a concatenated list of (scalars, vectors, matrices).
If the provided array can be interpreted as a contiguous row-ordered two
dimensional array it will be used in place, otherwise a copy will be made.</p></li>
<li><p><strong>values_elements</strong> (<em>integer vector-like</em>) – A multi-purpose vector containing, in order:</p>
<ul class="simple">
<li><p>the number of scalar-like eigenvalue elements,</p></li>
<li><p>the number of vector-like eigenvalue <em>elements</em> (must be <span class="math">\(3\times N\)</span>),</p></li>
<li><p>the number of matrix-like eigenvalue <em>elements</em> (must be <span class="math">\(9\times N\)</span>),</p></li>
<li><p>an integer <a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> value denoting
<em>how</em> the vector-like and matrix-like parts transform under application
of a symmetry operation (see note below),</p></li>
<li><p>an integer <a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a> value denoting what units
the vector-like and matrix-like parts are in (see note below)</p></li>
<li><p>which scalar cost function should be used (see below),</p></li>
<li><p>which vector cost function should be used (see below).</p></li>
</ul>
<p>See the note below for the meaning of the last three values.</p>
</li>
<li><p><strong>values_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvalue elements stored in the grid</p></li>
<li><p><strong>vectors_data</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – The eigenvector data to be stored in the grid. Same shape restrictions as
<strong>values_data</strong></p></li>
<li><p><strong>vectors_elements</strong> – Like <strong>values_elements</strong> but for the eigenvectors</p></li>
<li><p><strong>vectors_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvector elements stored in the grid</p></li>
<li><p><strong>sort</strong> (logical (default <code class="docutils literal notranslate"><span class="pre">False</span></code>)) – Whether the equivalent-mode permutations should be (re)determined following
the update to the flags and weights.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Mapping of integers to <a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>vector</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>pseudovector</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>Gamma</cite></p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to <a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>none</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>angstrom</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>inverse_angstrom</cite></p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p><cite>real_lattice</cite></p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p><cite>reciprocal_lattice</cite></p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 3.</p>
<p>Mapping of integers to scalar cost function:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(x,y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>magnitude(x-y)</p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to vector cost function:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(vec_x, vec_y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>sin(hermitian_angle(vec_x, vec_y))</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>vector_distance(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>1 - vector_product(vec_x, vec_y)</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>vector_angle(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>hermitian_angle(vec_x, vec_y)</p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 0.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZNestQdd.from_file">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">entry</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'BZNestQdd'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="module/grids.html#brille._brille.BZNestQdd" title="brille._brille.BZNestQdd"><span class="pre">brille._brille.BZNestQdd</span></a></span></span><a class="headerlink" href="#brille.BZNestQdd.from_file" title="Link to this definition"></a></dt>
<dd><p>Save the object to an HDF5 file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> (<em>str</em>) – The full path specification for the file to read from</p></li>
<li><p><strong>entry</strong> (<em>str</em>) – The group path, e.g., “my/cool/grid”, where to read from inside the file,
with a default equal to the object Class name</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>clsObj</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZNestQdd.invA">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">invA</span></span><a class="headerlink" href="#brille.BZNestQdd.invA" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZNestQdd.ir_interpolate_at">
<span class="sig-name descname"><span class="pre">ir_interpolate_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZNestQdd" title="brille._brille.BZNestQdd"><span class="pre">brille._brille.BZNestQdd</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">useparallel</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threads</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">do_not_move_points</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#brille.BZNestQdd.ir_interpolate_at" title="Link to this definition"></a></dt>
<dd><p>Perform linear interpolation of the stored data at irreducible equivalent points</p>
<p>The irreducible first Brillouin zone is the part of reciprocal space which is
invariant under application of the integer translations <em>and</em> the pointgroup
operations of a reciprocal space lattice. This method finds points equivalent
to the input within the irreducible first Brillouin zone and then interpolates
pre-stored information to provide an estimate at the found positions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Q</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – A two dimensional array with <code class="docutils literal notranslate"><span class="pre">Q.shape[1]</span> <span class="pre">==</span> <span class="pre">3</span></code> containing the positions at
which an interpolated result is required, expressed in units of the
reciprocal lattice.</p></li>
<li><p><strong>useparallel</strong> (<em>bool, optional</em>) – Whether a serial or parallel code should be utilised</p></li>
<li><p><strong>threads</strong> (<em>int, optional</em>) – How many OpenMP workers should be utilised; if this value is less than one
the environment variable <code class="docutils literal notranslate"><span class="pre">OMP_NUM_THREADS</span></code> will be used.</p></li>
<li><p><strong>do_not_move_points</strong> (<em>bool, optional</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code> the provided <strong>Q</strong> points must already lie within the first Brillouin
zone. No check is made to verify this requirement and if any <strong>Q</strong> lie outside
of the gridded volume out-of-bounds errors may result in bad data or runtime
errors.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The interpolated eigenvalues and eigenvectors at the equivalent
irreducible first Brillouin zone points.
The shape of each output will depend on the shape of the data provided to
the <a class="reference internal" href="module/grids.html#brille._brille.BZTrellisQdc.fill" title="brille._brille.BZTrellisQdc.fill"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fill()</span></code></a> method. i
If the filled eigenvalues were of shape
<code class="docutils literal notranslate"><span class="pre">[N_grid_points,</span> <span class="pre">N_modes,</span> <span class="pre">A,</span> <span class="pre">...,</span> <span class="pre">B]</span></code>, the eigenvectors were of shape
<code class="docutils literal notranslate"><span class="pre">[N_grid_points,</span> <span class="pre">N_modes,</span> <span class="pre">C,</span> <span class="pre">...,</span> <span class="pre">D]</span></code>, and the provided points of shape
<code class="docutils literal notranslate"><span class="pre">[N_Q_points,</span> <span class="pre">3]</span></code> then the output shapes will be
<code class="docutils literal notranslate"><span class="pre">[N_Q_points,</span> <span class="pre">N_modes,</span> <span class="pre">A,</span> <span class="pre">...,</span> <span class="pre">B]</span></code> and <code class="docutils literal notranslate"><span class="pre">[N_Q_points,</span> <span class="pre">N_modes,</span> <span class="pre">C,</span> <span class="pre">...,</span> <span class="pre">D]</span></code>
for the eigenvalues and eigenvectors, respectively.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZNestQdd.rlu">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">rlu</span></span><a class="headerlink" href="#brille.BZNestQdd.rlu" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZNestQdd.set_flags_weights">
<span class="sig-name descname"><span class="pre">set_flags_weights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZNestQdd" title="brille._brille.BZNestQdd"><span class="pre">brille._brille.BZNestQdd</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">values_flags</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">values_weights</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vectors_flags</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vectors_weights</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#brille.BZNestQdd.set_flags_weights" title="Link to this definition"></a></dt>
<dd><p>Set <a class="reference internal" href="module/grids.html#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a>, <cite>~brille._brille.LengthUnit</cite>
and cost functions plus relative cost weights for the values and vectors
stored in the object</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>values_flags</strong> (<em>integer, vector-like</em>) – One or more values indicating the <a class="reference internal" href="module/grids.html#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a>
value for the eigenvalues stored in the object, the <cite>~brille._brille.LengthUnit</cite>
value, plus which cost function to use when comparing stored eigenvalues at
neighbouring grid points for scalar- and vector-like eigenvalues.</p></li>
<li><p><strong>values_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvalue elements stored in the grid</p></li>
<li><p><strong>vectors_flags</strong> (<em>integer, vector-like</em>) – One or more values indicating the <a class="reference internal" href="module/grids.html#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a>
value for the eigenvalues stored in the object, the <cite>~brille._brille.LengthUnit</cite>
value, plus which cost function to use when comparing stored eigenvectors at
neighbouring grid points for scalar- and vector-like eigenvectors.</p></li>
<li><p><strong>vectors_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvector elements stored in the grid</p></li>
<li><p><strong>sort</strong> (<em>bool, optional</em>) – Whether the equivalent-mode permutations should be (re)determined following
the update to the flags and weights.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Mapping of integers to <a class="reference internal" href="module/grids.html#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>vector</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>pseudovector</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>Gamma</cite></p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to <a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>none</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>angstrom</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>inverse_angstrom</cite></p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p><cite>real_lattice</cite></p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p><cite>reciprocal_lattice</cite></p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to scalar cost function:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(x,y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>magnitude(x-y)</p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to vector cost function:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(vec_x, vec_y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>sin(hermitian_angle(vec_x, vec_y))</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>vector_distance(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>1 - vector_product(vec_x, vec_y)</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>vector_angle(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>hermitian_angle(vec_x, vec_y)</p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 0.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZNestQdd.sort">
<span class="sig-name descname"><span class="pre">sort</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZNestQdd" title="brille._brille.BZNestQdd"><span class="pre">brille._brille.BZNestQdd</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#brille.BZNestQdd.sort" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZNestQdd.tetrahedra">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">tetrahedra</span></span><a class="headerlink" href="#brille.BZNestQdd.tetrahedra" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZNestQdd.to_file">
<span class="sig-name descname"><span class="pre">to_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZNestQdd" title="brille._brille.BZNestQdd"><span class="pre">brille._brille.BZNestQdd</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">entry</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'BZNestQdd'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'ac'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#brille.BZNestQdd.to_file" title="Link to this definition"></a></dt>
<dd><p>Save the object to an HDF5 file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> (<em>str</em>) – The full path specification for the file to write into</p></li>
<li><p><strong>entry</strong> (<em>str</em>) – The group path, e.g., “my/cool/grid”, where to write inside the file,
with a default equal to the object Class name</p></li>
<li><p><strong>flags</strong> (<em>str</em>) – The HDF5 permissions to use when opening the file. Default ‘a’ writes to an
existing file – if <cite>entry</cite> exists in the file it is overwritten.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Possible <cite>flags</cite> are:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><cite>flags</cite></p></th>
<th class="head"><p>meaning</p></th>
<th class="head"><p>HDF equivalent</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>‘r’</p></td>
<td><p>read</p></td>
<td><p>H5F_ACC_RDONLY</p></td>
</tr>
<tr class="row-odd"><td><p>‘x’</p></td>
<td><p>write, error if exists</p></td>
<td><p>H5F_ACC_EXCL</p></td>
</tr>
<tr class="row-even"><td><p>‘a’</p></td>
<td><p>write, append to file</p></td>
<td><p>H5F_ACC_RDWR</p></td>
</tr>
<tr class="row-odd"><td><p>‘c’</p></td>
<td><p>write, error if exists</p></td>
<td><p>H5F_ACC_CREAT</p></td>
</tr>
<tr class="row-even"><td><p>‘t’</p></td>
<td><p>write, replace existing</p></td>
<td><p>H5F_ACC_TRUNC</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Indication of writing success.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZNestQdd.values">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">values</span></span><a class="headerlink" href="#brille.BZNestQdd.values" title="Link to this definition"></a></dt>
<dd><p>Return a shared view of the stored eigenvalues</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZNestQdd.vectors">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">vectors</span></span><a class="headerlink" href="#brille.BZNestQdd.vectors" title="Link to this definition"></a></dt>
<dd><p>Return a shared view of the stored eigenvectors</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="brille.BZTrellisQcc">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">brille.</span></span><span class="sig-name descname"><span class="pre">BZTrellisQcc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille.BZTrellisQcc" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: brille._brille.BZTrellisQcc, brillouin_zone: brille._brille.BrillouinZone, node_volume_fraction: float = 0.1, always_triangulate: bool = False) -&gt; None</p></li>
<li><p>__init__(self: brille._brille.BZTrellisQcc, brillouin_zone: brille._brille.BrillouinZone, node_volume_fraction: float, always_triangulate: bool, approx_config: brille::approx_float::Config) -&gt; None</p></li>
</ol>
<dl class="py property">
<dt class="sig sig-object py" id="brille.BZTrellisQcc.BrillouinZone">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">BrillouinZone</span></span><a class="headerlink" href="#brille.BZTrellisQcc.BrillouinZone" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZTrellisQcc.all_node_types">
<span class="sig-name descname"><span class="pre">all_node_types</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZTrellisQcc" title="brille._brille.BZTrellisQcc"><span class="pre">brille._brille.BZTrellisQcc</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list[brille::NodeType]</span></span></span><a class="headerlink" href="#brille.BZTrellisQcc.all_node_types" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZTrellisQcc.bytes_per_point">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bytes_per_point</span></span><a class="headerlink" href="#brille.BZTrellisQcc.bytes_per_point" title="Link to this definition"></a></dt>
<dd><p>Return the memory required per interpolation point <em>result</em> in bytes</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZTrellisQcc.fill">
<span class="sig-name descname"><span class="pre">fill</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille.BZTrellisQcc.fill" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>fill(self: brille._brille.BZTrellisQcc, values_data: numpy.ndarray[numpy.complex128], values_elements: numpy.ndarray[numpy.int32], vectors_data: numpy.ndarray[numpy.complex128], vectors_elements: numpy.ndarray[numpy.int32], sort: bool = False) -&gt; None</p></li>
</ol>
<p>Provide data required for interpolation to the grid without cost information.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>values_data</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – The eigenvalue data to be stored in the grid. The first dimension must be
equal in size to the number of grid-vertices. If two dimensional the second
dimension is interpreted as all information for a single mode flattened
and concatenated into (scalars, vectors, matrices) – in that order.
If more than two dimensional, the second dimension indexes modes and
higher dimensions will be flattened <em>as if row ordered</em> and must flatten into
a concatenated list of (scalars, vectors, matrices).
If the provided array can be interpreted as a contiguous row-ordered two
dimensional array it will be used in place, otherwise a copy will be made.</p></li>
<li><p><strong>values_elements</strong> (<em>integer vector-like</em>) – A multi-purpose vector containing, in order:</p>
<ul>
<li><p>the number of scalar-like eigenvalue elements,</p></li>
<li><p>the number of vector-like eigenvalue <em>elements</em> (must be <span class="math">\(3\times N\)</span>),</p></li>
<li><p>the number of matrix-like eigenvalue <em>elements</em> (must be <span class="math">\(9\times N\)</span>),</p></li>
<li><p>an integer <a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> value denoting
<em>how</em> the vector-like and matrix-like parts transform under application
of a symmetry operation (see note below).</p></li>
<li><p>an integer <a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a> value denoting what units
the vector-like and matrix-like parts are in (see note below).</p></li>
</ul>
</li>
<li><p><strong>vectors_data</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – The eigenvector data to be stored in the grid. Same shape restrictions as
<code class="docutils literal notranslate"><span class="pre">values_data</span></code></p></li>
<li><p><strong>vectors_elements</strong> – Like <code class="docutils literal notranslate"><span class="pre">values_elements</span></code> but for the eigenvectors</p></li>
<li><p><strong>sort</strong> (logical (default <code class="docutils literal notranslate"><span class="pre">False</span></code>)) – Whether the equivalent-mode permutations should be (re)determined following
the update to the flags and weights.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Mapping of integers to <a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>vector</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>pseudovector</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>Gamma</cite></p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 0.</p>
<p>Mapping of integers to <a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>none</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>angstrom</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>inverse_angstrom</cite></p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p><cite>real_lattice</cite></p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p><cite>reciprocal_lattice</cite></p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 3.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>fill(self: brille._brille.BZTrellisQcc, values_data: numpy.ndarray[numpy.complex128], values_elements: numpy.ndarray[numpy.int32], values_weights: numpy.ndarray[numpy.float64], vectors_data: numpy.ndarray[numpy.complex128], vectors_elements: numpy.ndarray[numpy.int32], vectors_weights: numpy.ndarray[numpy.float64], sort: bool = False) -&gt; None</p></li>
</ol>
<p>Provide all data required for interpolation to the grid at once</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>values_data</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – The eigenvalue data to be stored in the grid. The first dimension must be
equal in size to the number of grid-vertices. If two dimensional the second
dimension is interpreted as all information for a single mode flattened
and concatenated into (scalars, vectors, matrices) – in that order.
If more than two dimensional, the second dimension indexes modes and
higher dimensions will be flattened <em>as if row ordered</em> and must flatten into
a concatenated list of (scalars, vectors, matrices).
If the provided array can be interpreted as a contiguous row-ordered two
dimensional array it will be used in place, otherwise a copy will be made.</p></li>
<li><p><strong>values_elements</strong> (<em>integer vector-like</em>) – A multi-purpose vector containing, in order:</p>
<ul class="simple">
<li><p>the number of scalar-like eigenvalue elements,</p></li>
<li><p>the number of vector-like eigenvalue <em>elements</em> (must be <span class="math">\(3\times N\)</span>),</p></li>
<li><p>the number of matrix-like eigenvalue <em>elements</em> (must be <span class="math">\(9\times N\)</span>),</p></li>
<li><p>an integer <a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> value denoting
<em>how</em> the vector-like and matrix-like parts transform under application
of a symmetry operation (see note below),</p></li>
<li><p>an integer <a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a> value denoting what units
the vector-like and matrix-like parts are in (see note below)</p></li>
<li><p>which scalar cost function should be used (see below),</p></li>
<li><p>which vector cost function should be used (see below).</p></li>
</ul>
<p>See the note below for the meaning of the last three values.</p>
</li>
<li><p><strong>values_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvalue elements stored in the grid</p></li>
<li><p><strong>vectors_data</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – The eigenvector data to be stored in the grid. Same shape restrictions as
<strong>values_data</strong></p></li>
<li><p><strong>vectors_elements</strong> – Like <strong>values_elements</strong> but for the eigenvectors</p></li>
<li><p><strong>vectors_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvector elements stored in the grid</p></li>
<li><p><strong>sort</strong> (logical (default <code class="docutils literal notranslate"><span class="pre">False</span></code>)) – Whether the equivalent-mode permutations should be (re)determined following
the update to the flags and weights.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Mapping of integers to <a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>vector</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>pseudovector</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>Gamma</cite></p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to <a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>none</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>angstrom</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>inverse_angstrom</cite></p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p><cite>real_lattice</cite></p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p><cite>reciprocal_lattice</cite></p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 3.</p>
<p>Mapping of integers to scalar cost function:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(x,y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>magnitude(x-y)</p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to vector cost function:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(vec_x, vec_y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>sin(hermitian_angle(vec_x, vec_y))</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>vector_distance(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>1 - vector_product(vec_x, vec_y)</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>vector_angle(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>hermitian_angle(vec_x, vec_y)</p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 0.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZTrellisQcc.from_file">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">entry</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'BZTrellisQcc'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="module/grids.html#brille._brille.BZTrellisQcc" title="brille._brille.BZTrellisQcc"><span class="pre">brille._brille.BZTrellisQcc</span></a></span></span><a class="headerlink" href="#brille.BZTrellisQcc.from_file" title="Link to this definition"></a></dt>
<dd><p>Save the object to an HDF5 file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> (<em>str</em>) – The full path specification for the file to read from</p></li>
<li><p><strong>entry</strong> (<em>str</em>) – The group path, e.g., “my/cool/grid”, where to read from inside the file,
with a default equal to the object Class name</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>clsObj</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZTrellisQcc.inner_invA">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">inner_invA</span></span><a class="headerlink" href="#brille.BZTrellisQcc.inner_invA" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZTrellisQcc.inner_rlu">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">inner_rlu</span></span><a class="headerlink" href="#brille.BZTrellisQcc.inner_rlu" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZTrellisQcc.interpolate_at">
<span class="sig-name descname"><span class="pre">interpolate_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZTrellisQcc" title="brille._brille.BZTrellisQcc"><span class="pre">brille._brille.BZTrellisQcc</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">useparallel</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threads</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">do_not_move_points</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.complex128</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.complex128</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#brille.BZTrellisQcc.interpolate_at" title="Link to this definition"></a></dt>
<dd><p>Perform linear interpolation of the stored data at equivalent points</p>
<p>The first Brillouin zone is the part of reciprocal space which is invariant
under application of the integer translations of a reciprocal space lattice.
This method finds points equivalent to the input within the first Brillouin
zone and then interpolates pre-stored information to provide an estimate at
the found positions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Q</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – A two dimensional array with <code class="docutils literal notranslate"><span class="pre">Q.shape[1]</span> <span class="pre">==</span> <span class="pre">3</span></code> containing the positions at
which an interpolated result is required, expressed in units of the
reciprocal lattice.</p></li>
<li><p><strong>useparallel</strong> (<em>bool, optional</em>) – Whether a serial or parallel code should be utilised</p></li>
<li><p><strong>threads</strong> (<em>int, optional</em>) – How many OpenMP workers should be utilised; if this value is less than one
the environment variable <code class="docutils literal notranslate"><span class="pre">OMP_NUM_THREADS</span></code> will be used.</p></li>
<li><p><strong>do_not_move_points</strong> (<em>bool, optional</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code> the provided <strong>Q</strong> points must already lie within the first Brillouin
zone. No check is made to verify this requirement and if any <strong>Q</strong> lie outside
of the gridded volume out-of-bounds errors may result in bad data or runtime
errors.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The interpolated eigenvalues and eigenvectors at the equivalent
first Brillouin zone points.
The shape of each output will depend on the shape of the data provided to
the <a class="reference internal" href="module/grids.html#brille._brille.BZTrellisQdc.fill" title="brille._brille.BZTrellisQdc.fill"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fill()</span></code></a> method.
If the filled eigenvalues were of shape
<code class="docutils literal notranslate"><span class="pre">[N_grid_points,</span> <span class="pre">N_modes,</span> <span class="pre">A,</span> <span class="pre">...,</span> <span class="pre">B]</span></code>, the eigenvectors were of shape
<code class="docutils literal notranslate"><span class="pre">[N_grid_points,</span> <span class="pre">N_modes,</span> <span class="pre">C,</span> <span class="pre">...,</span> <span class="pre">D]</span></code>, and the provided points of shape
<code class="docutils literal notranslate"><span class="pre">[N_Q_points,</span> <span class="pre">3]</span></code> then the output shapes will be
<code class="docutils literal notranslate"><span class="pre">[N_Q_points,</span> <span class="pre">N_modes,</span> <span class="pre">A,</span> <span class="pre">...,</span> <span class="pre">B]</span></code> and <code class="docutils literal notranslate"><span class="pre">[N_Q_points,</span> <span class="pre">N_modes,</span> <span class="pre">C,</span> <span class="pre">...,</span> <span class="pre">D]</span></code>
for the eigenvalues and eigenvectors, respectively.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZTrellisQcc.invA">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">invA</span></span><a class="headerlink" href="#brille.BZTrellisQcc.invA" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZTrellisQcc.ir_interpolate_at">
<span class="sig-name descname"><span class="pre">ir_interpolate_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZTrellisQcc" title="brille._brille.BZTrellisQcc"><span class="pre">brille._brille.BZTrellisQcc</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">useparallel</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threads</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">do_not_move_points</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.complex128</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.complex128</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#brille.BZTrellisQcc.ir_interpolate_at" title="Link to this definition"></a></dt>
<dd><p>Perform linear interpolation of the stored data at irreducible equivalent points</p>
<p>The irreducible first Brillouin zone is the part of reciprocal space which is
invariant under application of the integer translations <em>and</em> the pointgroup
operations of a reciprocal space lattice. This method finds points equivalent
to the input within the irreducible first Brillouin zone and then interpolates
pre-stored information to provide an estimate at the found positions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Q</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – A two dimensional array with <code class="docutils literal notranslate"><span class="pre">Q.shape[1]</span> <span class="pre">==</span> <span class="pre">3</span></code> containing the positions at
which an interpolated result is required, expressed in units of the
reciprocal lattice.</p></li>
<li><p><strong>useparallel</strong> (<em>bool, optional</em>) – Whether a serial or parallel code should be utilised</p></li>
<li><p><strong>threads</strong> (<em>int, optional</em>) – How many OpenMP workers should be utilised; if this value is less than one
the environment variable <code class="docutils literal notranslate"><span class="pre">OMP_NUM_THREADS</span></code> will be used.</p></li>
<li><p><strong>do_not_move_points</strong> (<em>bool, optional</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code> the provided <strong>Q</strong> points must already lie within the first Brillouin
zone. No check is made to verify this requirement and if any <strong>Q</strong> lie outside
of the gridded volume out-of-bounds errors may result in bad data or runtime
errors.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The interpolated eigenvalues and eigenvectors at the equivalent
irreducible first Brillouin zone points.
The shape of each output will depend on the shape of the data provided to
the <a class="reference internal" href="module/grids.html#brille._brille.BZTrellisQdc.fill" title="brille._brille.BZTrellisQdc.fill"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fill()</span></code></a> method. i
If the filled eigenvalues were of shape
<code class="docutils literal notranslate"><span class="pre">[N_grid_points,</span> <span class="pre">N_modes,</span> <span class="pre">A,</span> <span class="pre">...,</span> <span class="pre">B]</span></code>, the eigenvectors were of shape
<code class="docutils literal notranslate"><span class="pre">[N_grid_points,</span> <span class="pre">N_modes,</span> <span class="pre">C,</span> <span class="pre">...,</span> <span class="pre">D]</span></code>, and the provided points of shape
<code class="docutils literal notranslate"><span class="pre">[N_Q_points,</span> <span class="pre">3]</span></code> then the output shapes will be
<code class="docutils literal notranslate"><span class="pre">[N_Q_points,</span> <span class="pre">N_modes,</span> <span class="pre">A,</span> <span class="pre">...,</span> <span class="pre">B]</span></code> and <code class="docutils literal notranslate"><span class="pre">[N_Q_points,</span> <span class="pre">N_modes,</span> <span class="pre">C,</span> <span class="pre">...,</span> <span class="pre">D]</span></code>
for the eigenvalues and eigenvectors, respectively.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZTrellisQcc.node_at">
<span class="sig-name descname"><span class="pre">node_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZTrellisQcc" title="brille._brille.BZTrellisQcc"><span class="pre">brille._brille.BZTrellisQcc</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">subscript</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Annotated[list[int],</span> <span class="pre">FixedSize(3)]</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">brille::polyhedron::Poly&lt;double,</span> <span class="pre">brille::Array2&gt;</span></span></span><a class="headerlink" href="#brille.BZTrellisQcc.node_at" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZTrellisQcc.node_at_type">
<span class="sig-name descname"><span class="pre">node_at_type</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZTrellisQcc" title="brille._brille.BZTrellisQcc"><span class="pre">brille._brille.BZTrellisQcc</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">subscript</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Annotated[list[int],</span> <span class="pre">FixedSize(3)]</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">brille::NodeType</span></span></span><a class="headerlink" href="#brille.BZTrellisQcc.node_at_type" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZTrellisQcc.node_containing">
<span class="sig-name descname"><span class="pre">node_containing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZTrellisQcc" title="brille._brille.BZTrellisQcc"><span class="pre">brille._brille.BZTrellisQcc</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">brille::polyhedron::Poly&lt;double,</span> <span class="pre">brille::Array2&gt;</span></span></span><a class="headerlink" href="#brille.BZTrellisQcc.node_containing" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZTrellisQcc.node_containing_type">
<span class="sig-name descname"><span class="pre">node_containing_type</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZTrellisQcc" title="brille._brille.BZTrellisQcc"><span class="pre">brille._brille.BZTrellisQcc</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">brille::NodeType</span></span></span><a class="headerlink" href="#brille.BZTrellisQcc.node_containing_type" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZTrellisQcc.outer_invA">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">outer_invA</span></span><a class="headerlink" href="#brille.BZTrellisQcc.outer_invA" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZTrellisQcc.outer_rlu">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">outer_rlu</span></span><a class="headerlink" href="#brille.BZTrellisQcc.outer_rlu" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZTrellisQcc.rlu">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">rlu</span></span><a class="headerlink" href="#brille.BZTrellisQcc.rlu" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZTrellisQcc.set_flags_weights">
<span class="sig-name descname"><span class="pre">set_flags_weights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZTrellisQcc" title="brille._brille.BZTrellisQcc"><span class="pre">brille._brille.BZTrellisQcc</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">values_flags</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">values_weights</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vectors_flags</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vectors_weights</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#brille.BZTrellisQcc.set_flags_weights" title="Link to this definition"></a></dt>
<dd><p>Set <a class="reference internal" href="module/grids.html#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a>, <cite>~brille._brille.LengthUnit</cite>
and cost functions plus relative cost weights for the values and vectors
stored in the object</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>values_flags</strong> (<em>integer, vector-like</em>) – One or more values indicating the <a class="reference internal" href="module/grids.html#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a>
value for the eigenvalues stored in the object, the <cite>~brille._brille.LengthUnit</cite>
value, plus which cost function to use when comparing stored eigenvalues at
neighbouring grid points for scalar- and vector-like eigenvalues.</p></li>
<li><p><strong>values_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvalue elements stored in the grid</p></li>
<li><p><strong>vectors_flags</strong> (<em>integer, vector-like</em>) – One or more values indicating the <a class="reference internal" href="module/grids.html#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a>
value for the eigenvalues stored in the object, the <cite>~brille._brille.LengthUnit</cite>
value, plus which cost function to use when comparing stored eigenvectors at
neighbouring grid points for scalar- and vector-like eigenvectors.</p></li>
<li><p><strong>vectors_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvector elements stored in the grid</p></li>
<li><p><strong>sort</strong> (<em>bool, optional</em>) – Whether the equivalent-mode permutations should be (re)determined following
the update to the flags and weights.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Mapping of integers to <a class="reference internal" href="module/grids.html#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>vector</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>pseudovector</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>Gamma</cite></p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to <a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>none</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>angstrom</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>inverse_angstrom</cite></p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p><cite>real_lattice</cite></p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p><cite>reciprocal_lattice</cite></p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to scalar cost function:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(x,y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>magnitude(x-y)</p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to vector cost function:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(vec_x, vec_y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>sin(hermitian_angle(vec_x, vec_y))</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>vector_distance(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>1 - vector_product(vec_x, vec_y)</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>vector_angle(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>hermitian_angle(vec_x, vec_y)</p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 0.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZTrellisQcc.sort">
<span class="sig-name descname"><span class="pre">sort</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZTrellisQcc" title="brille._brille.BZTrellisQcc"><span class="pre">brille._brille.BZTrellisQcc</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#brille.BZTrellisQcc.sort" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZTrellisQcc.tetrahedra">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">tetrahedra</span></span><a class="headerlink" href="#brille.BZTrellisQcc.tetrahedra" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZTrellisQcc.to_file">
<span class="sig-name descname"><span class="pre">to_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZTrellisQcc" title="brille._brille.BZTrellisQcc"><span class="pre">brille._brille.BZTrellisQcc</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">entry</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'BZTrellisQcc'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'ac'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#brille.BZTrellisQcc.to_file" title="Link to this definition"></a></dt>
<dd><p>Save the object to an HDF5 file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> (<em>str</em>) – The full path specification for the file to write into</p></li>
<li><p><strong>entry</strong> (<em>str</em>) – The group path, e.g., “my/cool/grid”, where to write inside the file,
with a default equal to the object Class name</p></li>
<li><p><strong>flags</strong> (<em>str</em>) – The HDF5 permissions to use when opening the file. Default ‘a’ writes to an
existing file – if <cite>entry</cite> exists in the file it is overwritten.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Possible <cite>flags</cite> are:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><cite>flags</cite></p></th>
<th class="head"><p>meaning</p></th>
<th class="head"><p>HDF equivalent</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>‘r’</p></td>
<td><p>read</p></td>
<td><p>H5F_ACC_RDONLY</p></td>
</tr>
<tr class="row-odd"><td><p>‘x’</p></td>
<td><p>write, error if exists</p></td>
<td><p>H5F_ACC_EXCL</p></td>
</tr>
<tr class="row-even"><td><p>‘a’</p></td>
<td><p>write, append to file</p></td>
<td><p>H5F_ACC_RDWR</p></td>
</tr>
<tr class="row-odd"><td><p>‘c’</p></td>
<td><p>write, error if exists</p></td>
<td><p>H5F_ACC_CREAT</p></td>
</tr>
<tr class="row-even"><td><p>‘t’</p></td>
<td><p>write, replace existing</p></td>
<td><p>H5F_ACC_TRUNC</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Indication of writing success.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZTrellisQcc.values">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">values</span></span><a class="headerlink" href="#brille.BZTrellisQcc.values" title="Link to this definition"></a></dt>
<dd><p>Return a shared view of the stored eigenvalues</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZTrellisQcc.vectors">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">vectors</span></span><a class="headerlink" href="#brille.BZTrellisQcc.vectors" title="Link to this definition"></a></dt>
<dd><p>Return a shared view of the stored eigenvectors</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="brille.BZTrellisQdc">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">brille.</span></span><span class="sig-name descname"><span class="pre">BZTrellisQdc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille.BZTrellisQdc" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: brille._brille.BZTrellisQdc, brillouin_zone: brille._brille.BrillouinZone, node_volume_fraction: float = 0.1, always_triangulate: bool = False) -&gt; None</p></li>
<li><p>__init__(self: brille._brille.BZTrellisQdc, brillouin_zone: brille._brille.BrillouinZone, node_volume_fraction: float, always_triangulate: bool, approx_config: brille::approx_float::Config) -&gt; None</p></li>
</ol>
<dl class="py property">
<dt class="sig sig-object py" id="brille.BZTrellisQdc.BrillouinZone">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">BrillouinZone</span></span><a class="headerlink" href="#brille.BZTrellisQdc.BrillouinZone" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZTrellisQdc.all_node_types">
<span class="sig-name descname"><span class="pre">all_node_types</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZTrellisQdc" title="brille._brille.BZTrellisQdc"><span class="pre">brille._brille.BZTrellisQdc</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list[brille::NodeType]</span></span></span><a class="headerlink" href="#brille.BZTrellisQdc.all_node_types" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZTrellisQdc.bytes_per_point">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bytes_per_point</span></span><a class="headerlink" href="#brille.BZTrellisQdc.bytes_per_point" title="Link to this definition"></a></dt>
<dd><p>Return the memory required per interpolation point <em>result</em> in bytes</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZTrellisQdc.fill">
<span class="sig-name descname"><span class="pre">fill</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille.BZTrellisQdc.fill" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>fill(self: brille._brille.BZTrellisQdc, values_data: numpy.ndarray[numpy.float64], values_elements: numpy.ndarray[numpy.int32], vectors_data: numpy.ndarray[numpy.complex128], vectors_elements: numpy.ndarray[numpy.int32], sort: bool = False) -&gt; None</p></li>
</ol>
<p>Provide data required for interpolation to the grid without cost information.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>values_data</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – The eigenvalue data to be stored in the grid. The first dimension must be
equal in size to the number of grid-vertices. If two dimensional the second
dimension is interpreted as all information for a single mode flattened
and concatenated into (scalars, vectors, matrices) – in that order.
If more than two dimensional, the second dimension indexes modes and
higher dimensions will be flattened <em>as if row ordered</em> and must flatten into
a concatenated list of (scalars, vectors, matrices).
If the provided array can be interpreted as a contiguous row-ordered two
dimensional array it will be used in place, otherwise a copy will be made.</p></li>
<li><p><strong>values_elements</strong> (<em>integer vector-like</em>) – A multi-purpose vector containing, in order:</p>
<ul>
<li><p>the number of scalar-like eigenvalue elements,</p></li>
<li><p>the number of vector-like eigenvalue <em>elements</em> (must be <span class="math">\(3\times N\)</span>),</p></li>
<li><p>the number of matrix-like eigenvalue <em>elements</em> (must be <span class="math">\(9\times N\)</span>),</p></li>
<li><p>an integer <a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> value denoting
<em>how</em> the vector-like and matrix-like parts transform under application
of a symmetry operation (see note below).</p></li>
<li><p>an integer <a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a> value denoting what units
the vector-like and matrix-like parts are in (see note below).</p></li>
</ul>
</li>
<li><p><strong>vectors_data</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – The eigenvector data to be stored in the grid. Same shape restrictions as
<code class="docutils literal notranslate"><span class="pre">values_data</span></code></p></li>
<li><p><strong>vectors_elements</strong> – Like <code class="docutils literal notranslate"><span class="pre">values_elements</span></code> but for the eigenvectors</p></li>
<li><p><strong>sort</strong> (logical (default <code class="docutils literal notranslate"><span class="pre">False</span></code>)) – Whether the equivalent-mode permutations should be (re)determined following
the update to the flags and weights.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Mapping of integers to <a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>vector</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>pseudovector</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>Gamma</cite></p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 0.</p>
<p>Mapping of integers to <a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>none</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>angstrom</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>inverse_angstrom</cite></p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p><cite>real_lattice</cite></p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p><cite>reciprocal_lattice</cite></p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 3.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>fill(self: brille._brille.BZTrellisQdc, values_data: numpy.ndarray[numpy.float64], values_elements: numpy.ndarray[numpy.int32], values_weights: numpy.ndarray[numpy.float64], vectors_data: numpy.ndarray[numpy.complex128], vectors_elements: numpy.ndarray[numpy.int32], vectors_weights: numpy.ndarray[numpy.float64], sort: bool = False) -&gt; None</p></li>
</ol>
<p>Provide all data required for interpolation to the grid at once</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>values_data</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – The eigenvalue data to be stored in the grid. The first dimension must be
equal in size to the number of grid-vertices. If two dimensional the second
dimension is interpreted as all information for a single mode flattened
and concatenated into (scalars, vectors, matrices) – in that order.
If more than two dimensional, the second dimension indexes modes and
higher dimensions will be flattened <em>as if row ordered</em> and must flatten into
a concatenated list of (scalars, vectors, matrices).
If the provided array can be interpreted as a contiguous row-ordered two
dimensional array it will be used in place, otherwise a copy will be made.</p></li>
<li><p><strong>values_elements</strong> (<em>integer vector-like</em>) – A multi-purpose vector containing, in order:</p>
<ul class="simple">
<li><p>the number of scalar-like eigenvalue elements,</p></li>
<li><p>the number of vector-like eigenvalue <em>elements</em> (must be <span class="math">\(3\times N\)</span>),</p></li>
<li><p>the number of matrix-like eigenvalue <em>elements</em> (must be <span class="math">\(9\times N\)</span>),</p></li>
<li><p>an integer <a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> value denoting
<em>how</em> the vector-like and matrix-like parts transform under application
of a symmetry operation (see note below),</p></li>
<li><p>an integer <a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a> value denoting what units
the vector-like and matrix-like parts are in (see note below)</p></li>
<li><p>which scalar cost function should be used (see below),</p></li>
<li><p>which vector cost function should be used (see below).</p></li>
</ul>
<p>See the note below for the meaning of the last three values.</p>
</li>
<li><p><strong>values_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvalue elements stored in the grid</p></li>
<li><p><strong>vectors_data</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – The eigenvector data to be stored in the grid. Same shape restrictions as
<strong>values_data</strong></p></li>
<li><p><strong>vectors_elements</strong> – Like <strong>values_elements</strong> but for the eigenvectors</p></li>
<li><p><strong>vectors_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvector elements stored in the grid</p></li>
<li><p><strong>sort</strong> (logical (default <code class="docutils literal notranslate"><span class="pre">False</span></code>)) – Whether the equivalent-mode permutations should be (re)determined following
the update to the flags and weights.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Mapping of integers to <a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>vector</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>pseudovector</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>Gamma</cite></p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to <a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>none</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>angstrom</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>inverse_angstrom</cite></p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p><cite>real_lattice</cite></p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p><cite>reciprocal_lattice</cite></p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 3.</p>
<p>Mapping of integers to scalar cost function:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(x,y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>magnitude(x-y)</p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to vector cost function:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(vec_x, vec_y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>sin(hermitian_angle(vec_x, vec_y))</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>vector_distance(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>1 - vector_product(vec_x, vec_y)</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>vector_angle(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>hermitian_angle(vec_x, vec_y)</p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 0.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZTrellisQdc.from_file">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">entry</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'BZTrellisQdc'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="module/grids.html#brille._brille.BZTrellisQdc" title="brille._brille.BZTrellisQdc"><span class="pre">brille._brille.BZTrellisQdc</span></a></span></span><a class="headerlink" href="#brille.BZTrellisQdc.from_file" title="Link to this definition"></a></dt>
<dd><p>Save the object to an HDF5 file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> (<em>str</em>) – The full path specification for the file to read from</p></li>
<li><p><strong>entry</strong> (<em>str</em>) – The group path, e.g., “my/cool/grid”, where to read from inside the file,
with a default equal to the object Class name</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>clsObj</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZTrellisQdc.inner_invA">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">inner_invA</span></span><a class="headerlink" href="#brille.BZTrellisQdc.inner_invA" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZTrellisQdc.inner_rlu">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">inner_rlu</span></span><a class="headerlink" href="#brille.BZTrellisQdc.inner_rlu" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZTrellisQdc.interpolate_at">
<span class="sig-name descname"><span class="pre">interpolate_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZTrellisQdc" title="brille._brille.BZTrellisQdc"><span class="pre">brille._brille.BZTrellisQdc</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">useparallel</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threads</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">do_not_move_points</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.complex128</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#brille.BZTrellisQdc.interpolate_at" title="Link to this definition"></a></dt>
<dd><p>Perform linear interpolation of the stored data at equivalent points</p>
<p>The first Brillouin zone is the part of reciprocal space which is invariant
under application of the integer translations of a reciprocal space lattice.
This method finds points equivalent to the input within the first Brillouin
zone and then interpolates pre-stored information to provide an estimate at
the found positions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Q</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – A two dimensional array with <code class="docutils literal notranslate"><span class="pre">Q.shape[1]</span> <span class="pre">==</span> <span class="pre">3</span></code> containing the positions at
which an interpolated result is required, expressed in units of the
reciprocal lattice.</p></li>
<li><p><strong>useparallel</strong> (<em>bool, optional</em>) – Whether a serial or parallel code should be utilised</p></li>
<li><p><strong>threads</strong> (<em>int, optional</em>) – How many OpenMP workers should be utilised; if this value is less than one
the environment variable <code class="docutils literal notranslate"><span class="pre">OMP_NUM_THREADS</span></code> will be used.</p></li>
<li><p><strong>do_not_move_points</strong> (<em>bool, optional</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code> the provided <strong>Q</strong> points must already lie within the first Brillouin
zone. No check is made to verify this requirement and if any <strong>Q</strong> lie outside
of the gridded volume out-of-bounds errors may result in bad data or runtime
errors.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The interpolated eigenvalues and eigenvectors at the equivalent
first Brillouin zone points.
The shape of each output will depend on the shape of the data provided to
the <a class="reference internal" href="module/grids.html#brille._brille.BZTrellisQdc.fill" title="brille._brille.BZTrellisQdc.fill"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fill()</span></code></a> method.
If the filled eigenvalues were of shape
<code class="docutils literal notranslate"><span class="pre">[N_grid_points,</span> <span class="pre">N_modes,</span> <span class="pre">A,</span> <span class="pre">...,</span> <span class="pre">B]</span></code>, the eigenvectors were of shape
<code class="docutils literal notranslate"><span class="pre">[N_grid_points,</span> <span class="pre">N_modes,</span> <span class="pre">C,</span> <span class="pre">...,</span> <span class="pre">D]</span></code>, and the provided points of shape
<code class="docutils literal notranslate"><span class="pre">[N_Q_points,</span> <span class="pre">3]</span></code> then the output shapes will be
<code class="docutils literal notranslate"><span class="pre">[N_Q_points,</span> <span class="pre">N_modes,</span> <span class="pre">A,</span> <span class="pre">...,</span> <span class="pre">B]</span></code> and <code class="docutils literal notranslate"><span class="pre">[N_Q_points,</span> <span class="pre">N_modes,</span> <span class="pre">C,</span> <span class="pre">...,</span> <span class="pre">D]</span></code>
for the eigenvalues and eigenvectors, respectively.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZTrellisQdc.invA">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">invA</span></span><a class="headerlink" href="#brille.BZTrellisQdc.invA" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZTrellisQdc.ir_interpolate_at">
<span class="sig-name descname"><span class="pre">ir_interpolate_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZTrellisQdc" title="brille._brille.BZTrellisQdc"><span class="pre">brille._brille.BZTrellisQdc</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">useparallel</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threads</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">do_not_move_points</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.complex128</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#brille.BZTrellisQdc.ir_interpolate_at" title="Link to this definition"></a></dt>
<dd><p>Perform linear interpolation of the stored data at irreducible equivalent points</p>
<p>The irreducible first Brillouin zone is the part of reciprocal space which is
invariant under application of the integer translations <em>and</em> the pointgroup
operations of a reciprocal space lattice. This method finds points equivalent
to the input within the irreducible first Brillouin zone and then interpolates
pre-stored information to provide an estimate at the found positions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Q</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – A two dimensional array with <code class="docutils literal notranslate"><span class="pre">Q.shape[1]</span> <span class="pre">==</span> <span class="pre">3</span></code> containing the positions at
which an interpolated result is required, expressed in units of the
reciprocal lattice.</p></li>
<li><p><strong>useparallel</strong> (<em>bool, optional</em>) – Whether a serial or parallel code should be utilised</p></li>
<li><p><strong>threads</strong> (<em>int, optional</em>) – How many OpenMP workers should be utilised; if this value is less than one
the environment variable <code class="docutils literal notranslate"><span class="pre">OMP_NUM_THREADS</span></code> will be used.</p></li>
<li><p><strong>do_not_move_points</strong> (<em>bool, optional</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code> the provided <strong>Q</strong> points must already lie within the first Brillouin
zone. No check is made to verify this requirement and if any <strong>Q</strong> lie outside
of the gridded volume out-of-bounds errors may result in bad data or runtime
errors.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The interpolated eigenvalues and eigenvectors at the equivalent
irreducible first Brillouin zone points.
The shape of each output will depend on the shape of the data provided to
the <a class="reference internal" href="module/grids.html#brille._brille.BZTrellisQdc.fill" title="brille._brille.BZTrellisQdc.fill"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fill()</span></code></a> method. i
If the filled eigenvalues were of shape
<code class="docutils literal notranslate"><span class="pre">[N_grid_points,</span> <span class="pre">N_modes,</span> <span class="pre">A,</span> <span class="pre">...,</span> <span class="pre">B]</span></code>, the eigenvectors were of shape
<code class="docutils literal notranslate"><span class="pre">[N_grid_points,</span> <span class="pre">N_modes,</span> <span class="pre">C,</span> <span class="pre">...,</span> <span class="pre">D]</span></code>, and the provided points of shape
<code class="docutils literal notranslate"><span class="pre">[N_Q_points,</span> <span class="pre">3]</span></code> then the output shapes will be
<code class="docutils literal notranslate"><span class="pre">[N_Q_points,</span> <span class="pre">N_modes,</span> <span class="pre">A,</span> <span class="pre">...,</span> <span class="pre">B]</span></code> and <code class="docutils literal notranslate"><span class="pre">[N_Q_points,</span> <span class="pre">N_modes,</span> <span class="pre">C,</span> <span class="pre">...,</span> <span class="pre">D]</span></code>
for the eigenvalues and eigenvectors, respectively.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZTrellisQdc.node_at">
<span class="sig-name descname"><span class="pre">node_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZTrellisQdc" title="brille._brille.BZTrellisQdc"><span class="pre">brille._brille.BZTrellisQdc</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">subscript</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Annotated[list[int],</span> <span class="pre">FixedSize(3)]</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">brille::polyhedron::Poly&lt;double,</span> <span class="pre">brille::Array2&gt;</span></span></span><a class="headerlink" href="#brille.BZTrellisQdc.node_at" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZTrellisQdc.node_at_type">
<span class="sig-name descname"><span class="pre">node_at_type</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZTrellisQdc" title="brille._brille.BZTrellisQdc"><span class="pre">brille._brille.BZTrellisQdc</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">subscript</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Annotated[list[int],</span> <span class="pre">FixedSize(3)]</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">brille::NodeType</span></span></span><a class="headerlink" href="#brille.BZTrellisQdc.node_at_type" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZTrellisQdc.node_containing">
<span class="sig-name descname"><span class="pre">node_containing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZTrellisQdc" title="brille._brille.BZTrellisQdc"><span class="pre">brille._brille.BZTrellisQdc</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">brille::polyhedron::Poly&lt;double,</span> <span class="pre">brille::Array2&gt;</span></span></span><a class="headerlink" href="#brille.BZTrellisQdc.node_containing" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZTrellisQdc.node_containing_type">
<span class="sig-name descname"><span class="pre">node_containing_type</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZTrellisQdc" title="brille._brille.BZTrellisQdc"><span class="pre">brille._brille.BZTrellisQdc</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">brille::NodeType</span></span></span><a class="headerlink" href="#brille.BZTrellisQdc.node_containing_type" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZTrellisQdc.outer_invA">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">outer_invA</span></span><a class="headerlink" href="#brille.BZTrellisQdc.outer_invA" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZTrellisQdc.outer_rlu">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">outer_rlu</span></span><a class="headerlink" href="#brille.BZTrellisQdc.outer_rlu" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZTrellisQdc.rlu">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">rlu</span></span><a class="headerlink" href="#brille.BZTrellisQdc.rlu" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZTrellisQdc.set_flags_weights">
<span class="sig-name descname"><span class="pre">set_flags_weights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZTrellisQdc" title="brille._brille.BZTrellisQdc"><span class="pre">brille._brille.BZTrellisQdc</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">values_flags</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">values_weights</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vectors_flags</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vectors_weights</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#brille.BZTrellisQdc.set_flags_weights" title="Link to this definition"></a></dt>
<dd><p>Set <a class="reference internal" href="module/grids.html#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a>, <cite>~brille._brille.LengthUnit</cite>
and cost functions plus relative cost weights for the values and vectors
stored in the object</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>values_flags</strong> (<em>integer, vector-like</em>) – One or more values indicating the <a class="reference internal" href="module/grids.html#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a>
value for the eigenvalues stored in the object, the <cite>~brille._brille.LengthUnit</cite>
value, plus which cost function to use when comparing stored eigenvalues at
neighbouring grid points for scalar- and vector-like eigenvalues.</p></li>
<li><p><strong>values_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvalue elements stored in the grid</p></li>
<li><p><strong>vectors_flags</strong> (<em>integer, vector-like</em>) – One or more values indicating the <a class="reference internal" href="module/grids.html#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a>
value for the eigenvalues stored in the object, the <cite>~brille._brille.LengthUnit</cite>
value, plus which cost function to use when comparing stored eigenvectors at
neighbouring grid points for scalar- and vector-like eigenvectors.</p></li>
<li><p><strong>vectors_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvector elements stored in the grid</p></li>
<li><p><strong>sort</strong> (<em>bool, optional</em>) – Whether the equivalent-mode permutations should be (re)determined following
the update to the flags and weights.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Mapping of integers to <a class="reference internal" href="module/grids.html#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>vector</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>pseudovector</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>Gamma</cite></p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to <a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>none</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>angstrom</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>inverse_angstrom</cite></p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p><cite>real_lattice</cite></p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p><cite>reciprocal_lattice</cite></p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to scalar cost function:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(x,y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>magnitude(x-y)</p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to vector cost function:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(vec_x, vec_y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>sin(hermitian_angle(vec_x, vec_y))</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>vector_distance(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>1 - vector_product(vec_x, vec_y)</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>vector_angle(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>hermitian_angle(vec_x, vec_y)</p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 0.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZTrellisQdc.sort">
<span class="sig-name descname"><span class="pre">sort</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZTrellisQdc" title="brille._brille.BZTrellisQdc"><span class="pre">brille._brille.BZTrellisQdc</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#brille.BZTrellisQdc.sort" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZTrellisQdc.tetrahedra">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">tetrahedra</span></span><a class="headerlink" href="#brille.BZTrellisQdc.tetrahedra" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZTrellisQdc.to_file">
<span class="sig-name descname"><span class="pre">to_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZTrellisQdc" title="brille._brille.BZTrellisQdc"><span class="pre">brille._brille.BZTrellisQdc</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">entry</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'BZTrellisQdc'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'ac'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#brille.BZTrellisQdc.to_file" title="Link to this definition"></a></dt>
<dd><p>Save the object to an HDF5 file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> (<em>str</em>) – The full path specification for the file to write into</p></li>
<li><p><strong>entry</strong> (<em>str</em>) – The group path, e.g., “my/cool/grid”, where to write inside the file,
with a default equal to the object Class name</p></li>
<li><p><strong>flags</strong> (<em>str</em>) – The HDF5 permissions to use when opening the file. Default ‘a’ writes to an
existing file – if <cite>entry</cite> exists in the file it is overwritten.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Possible <cite>flags</cite> are:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><cite>flags</cite></p></th>
<th class="head"><p>meaning</p></th>
<th class="head"><p>HDF equivalent</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>‘r’</p></td>
<td><p>read</p></td>
<td><p>H5F_ACC_RDONLY</p></td>
</tr>
<tr class="row-odd"><td><p>‘x’</p></td>
<td><p>write, error if exists</p></td>
<td><p>H5F_ACC_EXCL</p></td>
</tr>
<tr class="row-even"><td><p>‘a’</p></td>
<td><p>write, append to file</p></td>
<td><p>H5F_ACC_RDWR</p></td>
</tr>
<tr class="row-odd"><td><p>‘c’</p></td>
<td><p>write, error if exists</p></td>
<td><p>H5F_ACC_CREAT</p></td>
</tr>
<tr class="row-even"><td><p>‘t’</p></td>
<td><p>write, replace existing</p></td>
<td><p>H5F_ACC_TRUNC</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Indication of writing success.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZTrellisQdc.values">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">values</span></span><a class="headerlink" href="#brille.BZTrellisQdc.values" title="Link to this definition"></a></dt>
<dd><p>Return a shared view of the stored eigenvalues</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZTrellisQdc.vectors">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">vectors</span></span><a class="headerlink" href="#brille.BZTrellisQdc.vectors" title="Link to this definition"></a></dt>
<dd><p>Return a shared view of the stored eigenvectors</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="brille.BZTrellisQdd">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">brille.</span></span><span class="sig-name descname"><span class="pre">BZTrellisQdd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille.BZTrellisQdd" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: brille._brille.BZTrellisQdd, brillouin_zone: brille._brille.BrillouinZone, node_volume_fraction: float = 0.1, always_triangulate: bool = False) -&gt; None</p></li>
<li><p>__init__(self: brille._brille.BZTrellisQdd, brillouin_zone: brille._brille.BrillouinZone, node_volume_fraction: float, always_triangulate: bool, approx_config: brille::approx_float::Config) -&gt; None</p></li>
</ol>
<dl class="py property">
<dt class="sig sig-object py" id="brille.BZTrellisQdd.BrillouinZone">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">BrillouinZone</span></span><a class="headerlink" href="#brille.BZTrellisQdd.BrillouinZone" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZTrellisQdd.all_node_types">
<span class="sig-name descname"><span class="pre">all_node_types</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZTrellisQdd" title="brille._brille.BZTrellisQdd"><span class="pre">brille._brille.BZTrellisQdd</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list[brille::NodeType]</span></span></span><a class="headerlink" href="#brille.BZTrellisQdd.all_node_types" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZTrellisQdd.bytes_per_point">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bytes_per_point</span></span><a class="headerlink" href="#brille.BZTrellisQdd.bytes_per_point" title="Link to this definition"></a></dt>
<dd><p>Return the memory required per interpolation point <em>result</em> in bytes</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZTrellisQdd.fill">
<span class="sig-name descname"><span class="pre">fill</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille.BZTrellisQdd.fill" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>fill(self: brille._brille.BZTrellisQdd, values_data: numpy.ndarray[numpy.float64], values_elements: numpy.ndarray[numpy.int32], vectors_data: numpy.ndarray[numpy.float64], vectors_elements: numpy.ndarray[numpy.int32], sort: bool = False) -&gt; None</p></li>
</ol>
<p>Provide data required for interpolation to the grid without cost information.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>values_data</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – The eigenvalue data to be stored in the grid. The first dimension must be
equal in size to the number of grid-vertices. If two dimensional the second
dimension is interpreted as all information for a single mode flattened
and concatenated into (scalars, vectors, matrices) – in that order.
If more than two dimensional, the second dimension indexes modes and
higher dimensions will be flattened <em>as if row ordered</em> and must flatten into
a concatenated list of (scalars, vectors, matrices).
If the provided array can be interpreted as a contiguous row-ordered two
dimensional array it will be used in place, otherwise a copy will be made.</p></li>
<li><p><strong>values_elements</strong> (<em>integer vector-like</em>) – A multi-purpose vector containing, in order:</p>
<ul>
<li><p>the number of scalar-like eigenvalue elements,</p></li>
<li><p>the number of vector-like eigenvalue <em>elements</em> (must be <span class="math">\(3\times N\)</span>),</p></li>
<li><p>the number of matrix-like eigenvalue <em>elements</em> (must be <span class="math">\(9\times N\)</span>),</p></li>
<li><p>an integer <a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> value denoting
<em>how</em> the vector-like and matrix-like parts transform under application
of a symmetry operation (see note below).</p></li>
<li><p>an integer <a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a> value denoting what units
the vector-like and matrix-like parts are in (see note below).</p></li>
</ul>
</li>
<li><p><strong>vectors_data</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – The eigenvector data to be stored in the grid. Same shape restrictions as
<code class="docutils literal notranslate"><span class="pre">values_data</span></code></p></li>
<li><p><strong>vectors_elements</strong> – Like <code class="docutils literal notranslate"><span class="pre">values_elements</span></code> but for the eigenvectors</p></li>
<li><p><strong>sort</strong> (logical (default <code class="docutils literal notranslate"><span class="pre">False</span></code>)) – Whether the equivalent-mode permutations should be (re)determined following
the update to the flags and weights.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Mapping of integers to <a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>vector</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>pseudovector</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>Gamma</cite></p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 0.</p>
<p>Mapping of integers to <a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>none</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>angstrom</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>inverse_angstrom</cite></p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p><cite>real_lattice</cite></p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p><cite>reciprocal_lattice</cite></p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 3.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>fill(self: brille._brille.BZTrellisQdd, values_data: numpy.ndarray[numpy.float64], values_elements: numpy.ndarray[numpy.int32], values_weights: numpy.ndarray[numpy.float64], vectors_data: numpy.ndarray[numpy.float64], vectors_elements: numpy.ndarray[numpy.int32], vectors_weights: numpy.ndarray[numpy.float64], sort: bool = False) -&gt; None</p></li>
</ol>
<p>Provide all data required for interpolation to the grid at once</p>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>values_data</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – The eigenvalue data to be stored in the grid. The first dimension must be
equal in size to the number of grid-vertices. If two dimensional the second
dimension is interpreted as all information for a single mode flattened
and concatenated into (scalars, vectors, matrices) – in that order.
If more than two dimensional, the second dimension indexes modes and
higher dimensions will be flattened <em>as if row ordered</em> and must flatten into
a concatenated list of (scalars, vectors, matrices).
If the provided array can be interpreted as a contiguous row-ordered two
dimensional array it will be used in place, otherwise a copy will be made.</p></li>
<li><p><strong>values_elements</strong> (<em>integer vector-like</em>) – A multi-purpose vector containing, in order:</p>
<ul class="simple">
<li><p>the number of scalar-like eigenvalue elements,</p></li>
<li><p>the number of vector-like eigenvalue <em>elements</em> (must be <span class="math">\(3\times N\)</span>),</p></li>
<li><p>the number of matrix-like eigenvalue <em>elements</em> (must be <span class="math">\(9\times N\)</span>),</p></li>
<li><p>an integer <a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> value denoting
<em>how</em> the vector-like and matrix-like parts transform under application
of a symmetry operation (see note below),</p></li>
<li><p>an integer <a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a> value denoting what units
the vector-like and matrix-like parts are in (see note below)</p></li>
<li><p>which scalar cost function should be used (see below),</p></li>
<li><p>which vector cost function should be used (see below).</p></li>
</ul>
<p>See the note below for the meaning of the last three values.</p>
</li>
<li><p><strong>values_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvalue elements stored in the grid</p></li>
<li><p><strong>vectors_data</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – The eigenvector data to be stored in the grid. Same shape restrictions as
<strong>values_data</strong></p></li>
<li><p><strong>vectors_elements</strong> – Like <strong>values_elements</strong> but for the eigenvectors</p></li>
<li><p><strong>vectors_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvector elements stored in the grid</p></li>
<li><p><strong>sort</strong> (logical (default <code class="docutils literal notranslate"><span class="pre">False</span></code>)) – Whether the equivalent-mode permutations should be (re)determined following
the update to the flags and weights.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Mapping of integers to <a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>vector</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>pseudovector</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>Gamma</cite></p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to <a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>none</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>angstrom</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>inverse_angstrom</cite></p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p><cite>real_lattice</cite></p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p><cite>reciprocal_lattice</cite></p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 3.</p>
<p>Mapping of integers to scalar cost function:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(x,y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>magnitude(x-y)</p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to vector cost function:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(vec_x, vec_y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>sin(hermitian_angle(vec_x, vec_y))</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>vector_distance(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>1 - vector_product(vec_x, vec_y)</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>vector_angle(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>hermitian_angle(vec_x, vec_y)</p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 0.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZTrellisQdd.from_file">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">entry</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'BZTrellisQdd'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="module/grids.html#brille._brille.BZTrellisQdd" title="brille._brille.BZTrellisQdd"><span class="pre">brille._brille.BZTrellisQdd</span></a></span></span><a class="headerlink" href="#brille.BZTrellisQdd.from_file" title="Link to this definition"></a></dt>
<dd><p>Save the object to an HDF5 file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> (<em>str</em>) – The full path specification for the file to read from</p></li>
<li><p><strong>entry</strong> (<em>str</em>) – The group path, e.g., “my/cool/grid”, where to read from inside the file,
with a default equal to the object Class name</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>clsObj</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZTrellisQdd.inner_invA">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">inner_invA</span></span><a class="headerlink" href="#brille.BZTrellisQdd.inner_invA" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZTrellisQdd.inner_rlu">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">inner_rlu</span></span><a class="headerlink" href="#brille.BZTrellisQdd.inner_rlu" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZTrellisQdd.interpolate_at">
<span class="sig-name descname"><span class="pre">interpolate_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZTrellisQdd" title="brille._brille.BZTrellisQdd"><span class="pre">brille._brille.BZTrellisQdd</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">useparallel</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threads</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">do_not_move_points</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#brille.BZTrellisQdd.interpolate_at" title="Link to this definition"></a></dt>
<dd><p>Perform linear interpolation of the stored data at equivalent points</p>
<p>The first Brillouin zone is the part of reciprocal space which is invariant
under application of the integer translations of a reciprocal space lattice.
This method finds points equivalent to the input within the first Brillouin
zone and then interpolates pre-stored information to provide an estimate at
the found positions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Q</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – A two dimensional array with <code class="docutils literal notranslate"><span class="pre">Q.shape[1]</span> <span class="pre">==</span> <span class="pre">3</span></code> containing the positions at
which an interpolated result is required, expressed in units of the
reciprocal lattice.</p></li>
<li><p><strong>useparallel</strong> (<em>bool, optional</em>) – Whether a serial or parallel code should be utilised</p></li>
<li><p><strong>threads</strong> (<em>int, optional</em>) – How many OpenMP workers should be utilised; if this value is less than one
the environment variable <code class="docutils literal notranslate"><span class="pre">OMP_NUM_THREADS</span></code> will be used.</p></li>
<li><p><strong>do_not_move_points</strong> (<em>bool, optional</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code> the provided <strong>Q</strong> points must already lie within the first Brillouin
zone. No check is made to verify this requirement and if any <strong>Q</strong> lie outside
of the gridded volume out-of-bounds errors may result in bad data or runtime
errors.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The interpolated eigenvalues and eigenvectors at the equivalent
first Brillouin zone points.
The shape of each output will depend on the shape of the data provided to
the <a class="reference internal" href="module/grids.html#brille._brille.BZTrellisQdc.fill" title="brille._brille.BZTrellisQdc.fill"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fill()</span></code></a> method.
If the filled eigenvalues were of shape
<code class="docutils literal notranslate"><span class="pre">[N_grid_points,</span> <span class="pre">N_modes,</span> <span class="pre">A,</span> <span class="pre">...,</span> <span class="pre">B]</span></code>, the eigenvectors were of shape
<code class="docutils literal notranslate"><span class="pre">[N_grid_points,</span> <span class="pre">N_modes,</span> <span class="pre">C,</span> <span class="pre">...,</span> <span class="pre">D]</span></code>, and the provided points of shape
<code class="docutils literal notranslate"><span class="pre">[N_Q_points,</span> <span class="pre">3]</span></code> then the output shapes will be
<code class="docutils literal notranslate"><span class="pre">[N_Q_points,</span> <span class="pre">N_modes,</span> <span class="pre">A,</span> <span class="pre">...,</span> <span class="pre">B]</span></code> and <code class="docutils literal notranslate"><span class="pre">[N_Q_points,</span> <span class="pre">N_modes,</span> <span class="pre">C,</span> <span class="pre">...,</span> <span class="pre">D]</span></code>
for the eigenvalues and eigenvectors, respectively.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZTrellisQdd.invA">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">invA</span></span><a class="headerlink" href="#brille.BZTrellisQdd.invA" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZTrellisQdd.ir_interpolate_at">
<span class="sig-name descname"><span class="pre">ir_interpolate_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZTrellisQdd" title="brille._brille.BZTrellisQdd"><span class="pre">brille._brille.BZTrellisQdd</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">useparallel</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threads</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">do_not_move_points</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#brille.BZTrellisQdd.ir_interpolate_at" title="Link to this definition"></a></dt>
<dd><p>Perform linear interpolation of the stored data at irreducible equivalent points</p>
<p>The irreducible first Brillouin zone is the part of reciprocal space which is
invariant under application of the integer translations <em>and</em> the pointgroup
operations of a reciprocal space lattice. This method finds points equivalent
to the input within the irreducible first Brillouin zone and then interpolates
pre-stored information to provide an estimate at the found positions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Q</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – A two dimensional array with <code class="docutils literal notranslate"><span class="pre">Q.shape[1]</span> <span class="pre">==</span> <span class="pre">3</span></code> containing the positions at
which an interpolated result is required, expressed in units of the
reciprocal lattice.</p></li>
<li><p><strong>useparallel</strong> (<em>bool, optional</em>) – Whether a serial or parallel code should be utilised</p></li>
<li><p><strong>threads</strong> (<em>int, optional</em>) – How many OpenMP workers should be utilised; if this value is less than one
the environment variable <code class="docutils literal notranslate"><span class="pre">OMP_NUM_THREADS</span></code> will be used.</p></li>
<li><p><strong>do_not_move_points</strong> (<em>bool, optional</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code> the provided <strong>Q</strong> points must already lie within the first Brillouin
zone. No check is made to verify this requirement and if any <strong>Q</strong> lie outside
of the gridded volume out-of-bounds errors may result in bad data or runtime
errors.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The interpolated eigenvalues and eigenvectors at the equivalent
irreducible first Brillouin zone points.
The shape of each output will depend on the shape of the data provided to
the <a class="reference internal" href="module/grids.html#brille._brille.BZTrellisQdc.fill" title="brille._brille.BZTrellisQdc.fill"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fill()</span></code></a> method. i
If the filled eigenvalues were of shape
<code class="docutils literal notranslate"><span class="pre">[N_grid_points,</span> <span class="pre">N_modes,</span> <span class="pre">A,</span> <span class="pre">...,</span> <span class="pre">B]</span></code>, the eigenvectors were of shape
<code class="docutils literal notranslate"><span class="pre">[N_grid_points,</span> <span class="pre">N_modes,</span> <span class="pre">C,</span> <span class="pre">...,</span> <span class="pre">D]</span></code>, and the provided points of shape
<code class="docutils literal notranslate"><span class="pre">[N_Q_points,</span> <span class="pre">3]</span></code> then the output shapes will be
<code class="docutils literal notranslate"><span class="pre">[N_Q_points,</span> <span class="pre">N_modes,</span> <span class="pre">A,</span> <span class="pre">...,</span> <span class="pre">B]</span></code> and <code class="docutils literal notranslate"><span class="pre">[N_Q_points,</span> <span class="pre">N_modes,</span> <span class="pre">C,</span> <span class="pre">...,</span> <span class="pre">D]</span></code>
for the eigenvalues and eigenvectors, respectively.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZTrellisQdd.node_at">
<span class="sig-name descname"><span class="pre">node_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZTrellisQdd" title="brille._brille.BZTrellisQdd"><span class="pre">brille._brille.BZTrellisQdd</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">subscript</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Annotated[list[int],</span> <span class="pre">FixedSize(3)]</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">brille::polyhedron::Poly&lt;double,</span> <span class="pre">brille::Array2&gt;</span></span></span><a class="headerlink" href="#brille.BZTrellisQdd.node_at" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZTrellisQdd.node_at_type">
<span class="sig-name descname"><span class="pre">node_at_type</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZTrellisQdd" title="brille._brille.BZTrellisQdd"><span class="pre">brille._brille.BZTrellisQdd</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">subscript</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Annotated[list[int],</span> <span class="pre">FixedSize(3)]</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">brille::NodeType</span></span></span><a class="headerlink" href="#brille.BZTrellisQdd.node_at_type" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZTrellisQdd.node_containing">
<span class="sig-name descname"><span class="pre">node_containing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZTrellisQdd" title="brille._brille.BZTrellisQdd"><span class="pre">brille._brille.BZTrellisQdd</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">brille::polyhedron::Poly&lt;double,</span> <span class="pre">brille::Array2&gt;</span></span></span><a class="headerlink" href="#brille.BZTrellisQdd.node_containing" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZTrellisQdd.node_containing_type">
<span class="sig-name descname"><span class="pre">node_containing_type</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZTrellisQdd" title="brille._brille.BZTrellisQdd"><span class="pre">brille._brille.BZTrellisQdd</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">brille::NodeType</span></span></span><a class="headerlink" href="#brille.BZTrellisQdd.node_containing_type" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZTrellisQdd.outer_invA">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">outer_invA</span></span><a class="headerlink" href="#brille.BZTrellisQdd.outer_invA" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZTrellisQdd.outer_rlu">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">outer_rlu</span></span><a class="headerlink" href="#brille.BZTrellisQdd.outer_rlu" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZTrellisQdd.rlu">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">rlu</span></span><a class="headerlink" href="#brille.BZTrellisQdd.rlu" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZTrellisQdd.set_flags_weights">
<span class="sig-name descname"><span class="pre">set_flags_weights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZTrellisQdd" title="brille._brille.BZTrellisQdd"><span class="pre">brille._brille.BZTrellisQdd</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">values_flags</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">values_weights</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vectors_flags</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vectors_weights</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#brille.BZTrellisQdd.set_flags_weights" title="Link to this definition"></a></dt>
<dd><p>Set <a class="reference internal" href="module/grids.html#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a>, <cite>~brille._brille.LengthUnit</cite>
and cost functions plus relative cost weights for the values and vectors
stored in the object</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>values_flags</strong> (<em>integer, vector-like</em>) – One or more values indicating the <a class="reference internal" href="module/grids.html#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a>
value for the eigenvalues stored in the object, the <cite>~brille._brille.LengthUnit</cite>
value, plus which cost function to use when comparing stored eigenvalues at
neighbouring grid points for scalar- and vector-like eigenvalues.</p></li>
<li><p><strong>values_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvalue elements stored in the grid</p></li>
<li><p><strong>vectors_flags</strong> (<em>integer, vector-like</em>) – One or more values indicating the <a class="reference internal" href="module/grids.html#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a>
value for the eigenvalues stored in the object, the <cite>~brille._brille.LengthUnit</cite>
value, plus which cost function to use when comparing stored eigenvectors at
neighbouring grid points for scalar- and vector-like eigenvectors.</p></li>
<li><p><strong>vectors_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvector elements stored in the grid</p></li>
<li><p><strong>sort</strong> (<em>bool, optional</em>) – Whether the equivalent-mode permutations should be (re)determined following
the update to the flags and weights.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Mapping of integers to <a class="reference internal" href="module/grids.html#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.RotatesLike" title="brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>vector</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>pseudovector</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>Gamma</cite></p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to <a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a> values:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille.LengthUnit" title="brille.LengthUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">LengthUnit</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>none</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>angstrom</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>inverse_angstrom</cite></p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p><cite>real_lattice</cite></p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p><cite>reciprocal_lattice</cite></p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to scalar cost function:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(x,y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>magnitude(x-y)</p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to vector cost function:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(vec_x, vec_y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>sin(hermitian_angle(vec_x, vec_y))</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>vector_distance(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>1 - vector_product(vec_x, vec_y)</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>vector_angle(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>hermitian_angle(vec_x, vec_y)</p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 0.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZTrellisQdd.sort">
<span class="sig-name descname"><span class="pre">sort</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZTrellisQdd" title="brille._brille.BZTrellisQdd"><span class="pre">brille._brille.BZTrellisQdd</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#brille.BZTrellisQdd.sort" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZTrellisQdd.tetrahedra">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">tetrahedra</span></span><a class="headerlink" href="#brille.BZTrellisQdd.tetrahedra" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BZTrellisQdd.to_file">
<span class="sig-name descname"><span class="pre">to_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.BZTrellisQdd" title="brille._brille.BZTrellisQdd"><span class="pre">brille._brille.BZTrellisQdd</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">entry</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'BZTrellisQdd'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'ac'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#brille.BZTrellisQdd.to_file" title="Link to this definition"></a></dt>
<dd><p>Save the object to an HDF5 file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> (<em>str</em>) – The full path specification for the file to write into</p></li>
<li><p><strong>entry</strong> (<em>str</em>) – The group path, e.g., “my/cool/grid”, where to write inside the file,
with a default equal to the object Class name</p></li>
<li><p><strong>flags</strong> (<em>str</em>) – The HDF5 permissions to use when opening the file. Default ‘a’ writes to an
existing file – if <cite>entry</cite> exists in the file it is overwritten.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Possible <cite>flags</cite> are:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><cite>flags</cite></p></th>
<th class="head"><p>meaning</p></th>
<th class="head"><p>HDF equivalent</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>‘r’</p></td>
<td><p>read</p></td>
<td><p>H5F_ACC_RDONLY</p></td>
</tr>
<tr class="row-odd"><td><p>‘x’</p></td>
<td><p>write, error if exists</p></td>
<td><p>H5F_ACC_EXCL</p></td>
</tr>
<tr class="row-even"><td><p>‘a’</p></td>
<td><p>write, append to file</p></td>
<td><p>H5F_ACC_RDWR</p></td>
</tr>
<tr class="row-odd"><td><p>‘c’</p></td>
<td><p>write, error if exists</p></td>
<td><p>H5F_ACC_CREAT</p></td>
</tr>
<tr class="row-even"><td><p>‘t’</p></td>
<td><p>write, replace existing</p></td>
<td><p>H5F_ACC_TRUNC</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Indication of writing success.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZTrellisQdd.values">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">values</span></span><a class="headerlink" href="#brille.BZTrellisQdd.values" title="Link to this definition"></a></dt>
<dd><p>Return a shared view of the stored eigenvalues</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BZTrellisQdd.vectors">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">vectors</span></span><a class="headerlink" href="#brille.BZTrellisQdd.vectors" title="Link to this definition"></a></dt>
<dd><p>Return a shared view of the stored eigenvectors</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="brille.Basis">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">brille.</span></span><span class="sig-name descname"><span class="pre">Basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille.Basis" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: brille._brille.Basis, arg0: numpy.ndarray[numpy.float64]) -&gt; None</p></li>
<li><p>__init__(self: brille._brille.Basis, arg0: numpy.ndarray[numpy.float64], arg1: list[int]) -&gt; None</p></li>
</ol>
<dl class="py property">
<dt class="sig sig-object py" id="brille.Basis.positions">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">positions</span></span><a class="headerlink" href="#brille.Basis.positions" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.Basis.size">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">size</span></span><a class="headerlink" href="#brille.Basis.size" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.Basis.types">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">types</span></span><a class="headerlink" href="#brille.Basis.types" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="brille.Bravais">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">brille.</span></span><span class="sig-name descname"><span class="pre">Bravais</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/lattice.html#brille._brille.Bravais" title="brille._brille.Bravais"><span class="pre">brille._brille.Bravais</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille.Bravais" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<blockquote>
<div><p>A Bravais letter indicating the centering of a lattice</p>
<p>When the unit cell does not reflect the symmetry of the lattice, it is usual
to refer to a ‘conventional’ crystallographic basis,
<span class="math">\((\mathbf{a}_s\,\mathbf{b}_s\,\mathbf{c}_s)\)</span>, instead of
a primitive basis, <span class="math">\((\mathbf{a}_p\,\mathbf{b}_p\,\mathbf{c}_p)\)</span>.
Such a conventional basis has ‘extra’ lattice points added at the centre of
the unit cell, the centre of a face, or the centre of three faces.
The ‘extra’ nodes in the conventional basis are displaced from the origin of
the unit cell by ‘centring vectors’. As with any space-spanning basis, any
whole-number linear combination of the conventional basis vectors is a lattice
point but in addition there exist linear combinations
<span class="math">\(x\mathbf{a}_s+y\mathbf{b}_s+z\mathbf{c}_s\)</span> with at least
two fractional coefficients <span class="math">\((x,y,z)\)</span> that are lattice points as well.</p>
<p>Each conventional basis is ascribed a Bravais letter, which forms part of the
Hermann-Mauguin symbol of a space group.
A subset of the 10 possible Bravais letters is used herein:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Bravais letter</p></th>
<th class="head"><p>Centring</p></th>
<th class="head"><p>Centring vectors</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>P</p></td>
<td><p>primitive</p></td>
<td><p><span class="math">\(\mathbf{0}\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>A</p></td>
<td><p>A-face centred</p></td>
<td><p><span class="math">\(\frac{\mathbf{b}_s+\mathbf{c}_s}{2}\)</span></p></td>
</tr>
<tr class="row-even"><td><p>B</p></td>
<td><p>B-face centred</p></td>
<td><p><span class="math">\(\frac{\mathbf{c}_s+\mathbf{a}_s}{2}\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>C</p></td>
<td><p>C-face centred</p></td>
<td><p><span class="math">\(\frac{\mathbf{a}_s+\mathbf{b}_s}{2}\)</span></p></td>
</tr>
<tr class="row-even"><td><p>I</p></td>
<td><p>body centred (<em>Innenzentriert</em>)</p></td>
<td><p><span class="math">\(\frac{\mathbf{a}_s+\mathbf{b}_s+\mathbf{c}_s}{2}\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>F</p></td>
<td><p>all-face centred</p></td>
<td><p><span class="math">\(\frac{\mathbf{b}_s+\mathbf{c}_s}{2}\)</span>,
<span class="math">\(\frac{\mathbf{c}_s+\mathbf{a}_s}{2}\)</span>,
<span class="math">\(\frac{\mathbf{a}_s+\mathbf{b}_s}{2}\)</span></p></td>
</tr>
<tr class="row-even"><td><p>R</p></td>
<td><p>rhombohedrally centred (hexagonal axes)</p></td>
<td><p><span class="math">\(\frac{2\mathbf{a}_s+\mathbf{b}_s+\mathbf{c}_s}{3}\)</span>
<span class="math">\(\frac{\mathbf{a}_s+2\mathbf{b}_s+2\mathbf{c}_s}{3}\)</span></p></td>
</tr>
</tbody>
</table>
<p>For further details, see the <a class="reference external" href="http://reference.iucr.org/dictionary/Centred_lattice">IUCr Online Dictionary of Crystallography</a>.</p>
</div></blockquote>
<p>Members:</p>
<blockquote>
<div><p>invalid</p>
<p>P : primitive</p>
<p>A : A-face centred</p>
<p>B : B-face centred</p>
<p>C : C-face centred</p>
<p>I : body-centred</p>
<p>F : face centred</p>
<p>R : rhombohedrally centred</p>
</div></blockquote>
<dl class="py attribute">
<dt class="sig sig-object py" id="brille.Bravais.A">
<span class="sig-name descname"><span class="pre">A</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;Bravais.A:</span> <span class="pre">2&gt;</span></em><a class="headerlink" href="#brille.Bravais.A" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="brille.Bravais.B">
<span class="sig-name descname"><span class="pre">B</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;Bravais.B:</span> <span class="pre">3&gt;</span></em><a class="headerlink" href="#brille.Bravais.B" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="brille.Bravais.C">
<span class="sig-name descname"><span class="pre">C</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;Bravais.C:</span> <span class="pre">4&gt;</span></em><a class="headerlink" href="#brille.Bravais.C" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="brille.Bravais.F">
<span class="sig-name descname"><span class="pre">F</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;Bravais.F:</span> <span class="pre">6&gt;</span></em><a class="headerlink" href="#brille.Bravais.F" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="brille.Bravais.I">
<span class="sig-name descname"><span class="pre">I</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;Bravais.I:</span> <span class="pre">5&gt;</span></em><a class="headerlink" href="#brille.Bravais.I" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="brille.Bravais.P">
<span class="sig-name descname"><span class="pre">P</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;Bravais.P:</span> <span class="pre">1&gt;</span></em><a class="headerlink" href="#brille.Bravais.P" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="brille.Bravais.R">
<span class="sig-name descname"><span class="pre">R</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;Bravais.R:</span> <span class="pre">7&gt;</span></em><a class="headerlink" href="#brille.Bravais.R" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="brille.Bravais.invalid">
<span class="sig-name descname"><span class="pre">invalid</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;Bravais.invalid:</span> <span class="pre">0&gt;</span></em><a class="headerlink" href="#brille.Bravais.invalid" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.Bravais.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#brille.Bravais.name" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.Bravais.value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#brille.Bravais.value" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="brille.BrillouinZone">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">brille.</span></span><span class="sig-name descname"><span class="pre">BrillouinZone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille.BrillouinZone" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<p>Construct and hold a first Brillouin zone and, optionally and by default,
an irreducible Brillouin zone.</p>
<p>The region closer to a given lattice point than to any other is the
Wigner-Seitz cell of that lattice. The same construction is one possible
first Brillouin zone of a reciprocal lattice and is used within <code class="docutils literal notranslate"><span class="pre">brille</span></code>.
For example, a two-dimensional hexagonal lattice has a first Brillouin
zone which is a hexagon:</p>
<div class="figure" style="text-align: center"><p><img  src="_images/tikz-88254c2784df39920d5791ada03a7b377267c6b9.svg" alt="Figure made with TikZ" /></p>
</div><p>Since all physical properties of a crystal must have the same periodicity
as its lattice, the powerful feature of the first Brillouin zone is that it
encompasses a region of reciprocal space which must fully represent all
of reciprocal space.</p>
<p>Most crystals contain rotational or rotoinversion symmetries in addition to
the translational ones which give rise to the first Brillouin zone. These
symmetries are the pointgroup of the lattice and enforce that the properties
of the crystal also have the same symmetry. The first Brillouin zone,
therefore, typically contains redundant information.</p>
<p>An irreducible Brillouin zone is a subsection of the first Brillouin zone
which contains the minimal part required to have only unique crystal
properties. This class can find an irreducible Brillouin zone for any
crystal lattice. In the example of the hexagonal lattice there are six
equivalent irreducible Brillouin zones one of which is:</p>
<div class="figure" style="text-align: center"><p><img  src="_images/tikz-5d467740d9d0c83bfb90b7d5c694810a57b81ee7.svg" alt="Figure made with TikZ" /></p>
</div><dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lattice</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">brille._brille.Reciprocal</span></code>) – The reciprocal space lattice for which a Brillouin zone will be found</p></li>
<li><p><strong>use_primitive</strong> (<em>bool</em>) – If the provided <code class="xref py py-class docutils literal notranslate"><span class="pre">brille._brille.Reciprocal</span></code> lattice is a
conventional Bravais lattice, this parameter controls whether the
equivalent primitive Bravais lattice should be used to find the first
Brillouin zone. This is <code class="docutils literal notranslate"><span class="pre">True</span></code> by default and should only be modified
for testing purposes.</p></li>
<li><p><strong>search_length</strong> (<em>int</em>) – The Wigner-Seitz construction of the first Brillouin zone finds the
volume of space closer to a chosen reciprocal lattice point than any
other reciprocal lattice point. This is accomplished by successively
dividing the space by planes halfway between the chosen point and a
subset of all other planes. The subset used is controlled by
<cite>search_length</cite> and is every unique <span class="math">\((\pm s_i\,0\,0)\)</span>,
<span class="math">\((0\,\pm s_j\,0)\)</span>, <span class="math">\((0\,0\,\pm s_k)\)</span>,
<span class="math">\((\pm s_i\,\pm s_j\,0)\)</span>, <span class="math">\((\pm s_i\,0\,\pm s_k)\)</span>,
<span class="math">\((0\,\pm s_j\,\pm s_k)\)</span>, <span class="math">\((\pm s_i\,\pm s_j\,\pm s_k)\)</span> for
<span class="math">\(1 \le s_\alpha \le\)</span> <cite>search_length</cite>.
If the reciprocal lattice is primitive then the default <cite>search_length</cite>
of <code class="docutils literal notranslate"><span class="pre">1</span></code> should always give the correct first Brillouin zone.
For extra assurance that the correct first Brillouin zone is found, the
procedure is internally repeated with <cite>search_length</cite> incremented by
one and an error is raised if the two constructed polyhedra have
different volumes.</p></li>
<li><p><strong>time_reversal_symmetry</strong> (<em>bool</em>) – Controls whether time reversal symmetry should be added to pointgroups
lacking space inversion. This affects the found irreducible Brillouin
zone for such systems. To avoid inadvertently adding time reversal
symmetry when it is not appropriate, this is <code class="docutils literal notranslate"><span class="pre">False</span></code> by default.</p></li>
<li><p><strong>wedge_search</strong> (<em>bool</em>) – Controls whether an irreducible Brillouin zone should be found. With
this set to <code class="docutils literal notranslate"><span class="pre">False</span></code> the returned <a class="reference internal" href="module/bz.html#brille._brille.BrillouinZone" title="brille._brille.BrillouinZone"><code class="xref py py-class docutils literal notranslate"><span class="pre">brille._brille.BrillouinZone</span></code></a>
will only contain the first Brillouin zone. If <code class="docutils literal notranslate"><span class="pre">True</span></code> the pointgroup
symmetry operations will be used to identify <em>an</em> irreducible Brillouin
zone as well. If the provided lattice’s parameters do not match the
symmetry of the pointgroup (e.g., a lattice which should be tetragonal
like <span class="math">\(I4/mmm\)</span> but constructed with <span class="math">\(\gamma=120^\circ\)</span>) the
algorithm will fail to find an appropriate irreducible Brillouin zone
and an error will be raised. (Set to <code class="docutils literal notranslate"><span class="pre">True</span></code> by default).</p></li>
</ul>
</dd>
</dl>
<p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: brille._brille.BrillouinZone, lattice: brille._brille.Lattice, use_primitive: bool = True, search_length: int = 1, time_reversal_symmetry: bool = False, wedge_search: bool = True, divide_primitive: bool = True) -&gt; None</p></li>
<li><p>__init__(self: brille._brille.BrillouinZone, lattice: brille._brille.Lattice, approx_config: brille::approx_float::Config, use_primitive: bool = True, search_length: int = 1, time_reversal_symmetry: bool = False, wedge_search: bool = True, divide_primitive: bool = True) -&gt; None</p></li>
</ol>
<dl class="py property">
<dt class="sig sig-object py" id="brille.BrillouinZone.faces_per_vertex">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">faces_per_vertex</span></span><a class="headerlink" href="#brille.BrillouinZone.faces_per_vertex" title="Link to this definition"></a></dt>
<dd><p>Return the first Brillouin zone face indices for each unique face corner</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BrillouinZone.from_file">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">entry</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'BrillouinZone'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="module/bz.html#brille._brille.BrillouinZone" title="brille._brille.BrillouinZone"><span class="pre">brille._brille.BrillouinZone</span></a></span></span><a class="headerlink" href="#brille.BrillouinZone.from_file" title="Link to this definition"></a></dt>
<dd><p>Save the object to an HDF5 file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> (<em>str</em>) – The full path specification for the file to read from</p></li>
<li><p><strong>entry</strong> (<em>str</em>) – The group path, e.g., “my/cool/bz”, where to read from inside the file,
with a default equal to the object Class name</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>clsObj</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BrillouinZone.half_edge_points">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">half_edge_points</span></span><a class="headerlink" href="#brille.BrillouinZone.half_edge_points" title="Link to this definition"></a></dt>
<dd><p>Return the first Brillouin zone face edge centres in rlu</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BrillouinZone.half_edge_points_invA">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">half_edge_points_invA</span></span><a class="headerlink" href="#brille.BrillouinZone.half_edge_points_invA" title="Link to this definition"></a></dt>
<dd><p>Return the first Brillouin zone face edge centres in inverse ångstrom</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BrillouinZone.ir_faces_per_vertex">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ir_faces_per_vertex</span></span><a class="headerlink" href="#brille.BrillouinZone.ir_faces_per_vertex" title="Link to this definition"></a></dt>
<dd><p>Return the irreducible Brillouin zone face index per unique face corner</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BrillouinZone.ir_moveinto">
<span class="sig-name descname"><span class="pre">ir_moveinto</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/bz.html#brille._brille.BrillouinZone" title="brille._brille.BrillouinZone"><span class="pre">brille._brille.BrillouinZone</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threads</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#brille.BrillouinZone.ir_moveinto" title="Link to this definition"></a></dt>
<dd><p>Find points equivalent to those provided within the irreducible Brillouin zone.</p>
<p>The BrillouinZone object defines a volume of reciprocal space which contains
an irreducible part of the full reciprocal-space. This method will find
points equivalent under the operations of the lattice which fall within this
irreducible volume.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Q</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – A 2 dimensional array of three-vectors (<code class="docutils literal notranslate"><span class="pre">Q.shape[1]==3</span></code>) expressed in
units of the reciprocal lattice.</p></li>
<li><p><strong>threads</strong> (<em>integer, optional</em>) – The number of parallel threads that should be used. If this value is less
than one the maximum number of OpenMP threads will be used – this value
can be controlled by the environment variable <code class="docutils literal notranslate"><span class="pre">OMP_NUM_THREADS</span></code> and is
typically the number of logical cores if not explicitly set.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>Qir</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – The array of equivalent irreducible <span class="math">\(\mathbf{q}_\text{ir}\)</span> points
for all <span class="math">\(\mathbf{Q}\)</span>;</p></li>
<li><p><strong>tau</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – the closest reciprocal lattice vector, <span class="math">\(\boldsymbol{\tau}\)</span>,
to each <span class="math">\(\mathbf{Q}\)</span>;</p></li>
<li><p><strong>R</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – the pointgroup symmetry operation <span class="math">\(R\)</span></p></li>
<li><p><strong>Rinv</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – the inverse point group symmetry operation which obey
<span class="math">\(\mathbf{Q} = R^{-1} \mathbf{q}_\text{ir} + \boldsymbol{\tau}\)</span>.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BrillouinZone.ir_moveinto_wedge">
<span class="sig-name descname"><span class="pre">ir_moveinto_wedge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/bz.html#brille._brille.BrillouinZone" title="brille._brille.BrillouinZone"><span class="pre">brille._brille.BrillouinZone</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threads</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#brille.BrillouinZone.ir_moveinto_wedge" title="Link to this definition"></a></dt>
<dd><p>Find points equivalent to those provided within the irreducible wedge.</p>
<p>The BrillouinZone object defines a wedge of reciprocal space which contains
an irreducible part of the full-space 4π steradian solid angle. This method
will find points equivalent under the pointgroup operations of the lattice
which fall within this irreducible solid angle and maintain their absolute
magnitude.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Q</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – A 2 dimensional array of three-vectors (<code class="docutils literal notranslate"><span class="pre">Q.shape[1]==3</span></code>) expressed in
units of the reciprocal lattice.</p></li>
<li><p><strong>threads</strong> (<em>integer, optional (default 0)</em>) – The number of parallel threads that should be used. If this value is less
than one the maximum number of OpenMP threads will be used – this value
can be controlled by the environment variable <code class="docutils literal notranslate"><span class="pre">OMP_NUM_THREADS</span></code> and is
typically the number of logical cores if not explicitly set.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The array of equivalent in-wedge <span class="math">\(\mathbf{Q}_\text{ir}\)</span> points
for all <span class="math">\(\mathbf{Q}\)</span>, and the pointgroup operation fulfilling
<span class="math">\(\mathbf{Q}_\text{ir} = R \mathbf{Q}\)</span>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>, <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BrillouinZone.ir_normals">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ir_normals</span></span><a class="headerlink" href="#brille.BrillouinZone.ir_normals" title="Link to this definition"></a></dt>
<dd><p>Return the irreducible Brillouin zone face normals in rlu</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BrillouinZone.ir_normals_invA">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ir_normals_invA</span></span><a class="headerlink" href="#brille.BrillouinZone.ir_normals_invA" title="Link to this definition"></a></dt>
<dd><p>Return the irreducible Brillouin zone face normals in inverse ångstrom</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BrillouinZone.ir_normals_primitive">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ir_normals_primitive</span></span><a class="headerlink" href="#brille.BrillouinZone.ir_normals_primitive" title="Link to this definition"></a></dt>
<dd><p>Return the irreducible Brillouin zone face normals in primitive-lattice rlu</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BrillouinZone.ir_points">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ir_points</span></span><a class="headerlink" href="#brille.BrillouinZone.ir_points" title="Link to this definition"></a></dt>
<dd><p>Return the irreducible Brillouin zone face centres in rlu</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BrillouinZone.ir_points_invA">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ir_points_invA</span></span><a class="headerlink" href="#brille.BrillouinZone.ir_points_invA" title="Link to this definition"></a></dt>
<dd><p>Return the irreducible Brillouin zone face centres in inverse ångstrom</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BrillouinZone.ir_points_primitive">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ir_points_primitive</span></span><a class="headerlink" href="#brille.BrillouinZone.ir_points_primitive" title="Link to this definition"></a></dt>
<dd><p>Return the irreducible Brillouin zone face centres in primitive-lattice rlu</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BrillouinZone.ir_polyhedron">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ir_polyhedron</span></span><a class="headerlink" href="#brille.BrillouinZone.ir_polyhedron" title="Link to this definition"></a></dt>
<dd><p>Returns the irreducible Brillouin zone <a class="reference internal" href="#brille.Polyhedron" title="brille._brille.Polyhedron"><code class="xref py py-class docutils literal notranslate"><span class="pre">brille._brille.Polyhedron</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>If no irreducible Brillouin zone was requested at construction, the returned
polyhedron is that of the first Brillouin zone instead.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#brille.Polyhedron" title="brille._brille.Polyhedron"><code class="xref py py-class docutils literal notranslate"><span class="pre">brille._brille.Polyhedron</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BrillouinZone.ir_polyhedron_generated">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ir_polyhedron_generated</span></span><a class="headerlink" href="#brille.BrillouinZone.ir_polyhedron_generated" title="Link to this definition"></a></dt>
<dd><p>Returns the found irreducible Brillouin zone <a class="reference internal" href="#brille.Polyhedron" title="brille._brille.Polyhedron"><code class="xref py py-class docutils literal notranslate"><span class="pre">brille._brille.Polyhedron</span></code></a></p>
<p>If the lattice pointgroup does not contain the space inversion operator
the internally held ‘irreducible’ polyhedron is only half of the real
irreducible polyhedron. This method gives access to the polyhedron found by
the algorithm before being doubled for output.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BrillouinZone.ir_vertices">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ir_vertices</span></span><a class="headerlink" href="#brille.BrillouinZone.ir_vertices" title="Link to this definition"></a></dt>
<dd><p>Return the irreducible Brillouin zone unique face corners in rlu</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BrillouinZone.ir_vertices_invA">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ir_vertices_invA</span></span><a class="headerlink" href="#brille.BrillouinZone.ir_vertices_invA" title="Link to this definition"></a></dt>
<dd><p>Return the irreducible Brillouin zone unique face corners in inverse ångstrom</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BrillouinZone.ir_vertices_per_face">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ir_vertices_per_face</span></span><a class="headerlink" href="#brille.BrillouinZone.ir_vertices_per_face" title="Link to this definition"></a></dt>
<dd><p>Return the irreducible Brillouin zone unique face corners per face</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BrillouinZone.ir_vertices_primitive">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ir_vertices_primitive</span></span><a class="headerlink" href="#brille.BrillouinZone.ir_vertices_primitive" title="Link to this definition"></a></dt>
<dd><p>Return the irreducible Brillouin zone unique face corners in primitive-lattice rlu</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BrillouinZone.isinside">
<span class="sig-name descname"><span class="pre">isinside</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/bz.html#brille._brille.BrillouinZone" title="brille._brille.BrillouinZone"><span class="pre">brille._brille.BrillouinZone</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">points</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#brille.BrillouinZone.isinside" title="Link to this definition"></a></dt>
<dd><p>Determine whether each of the provided reciprocal lattice points is located
within the first Brillouin zone</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>Q</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – A 2 dimensional array of three-vectors (<code class="docutils literal notranslate"><span class="pre">Q.shape[1]==3</span></code>) expressed in
units of the reciprocal lattice.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>One dimensional logical array with <code class="docutils literal notranslate"><span class="pre">True</span></code> indicating ‘inside’</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BrillouinZone.lattice">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">lattice</span></span><a class="headerlink" href="#brille.BrillouinZone.lattice" title="Link to this definition"></a></dt>
<dd><p>Returns the defining <a class="reference internal" href="module/lattice.html#brille._brille.Lattice" title="brille._brille.Lattice"><code class="xref py py-class docutils literal notranslate"><span class="pre">brille._brille.Lattice</span></code></a> lattice</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BrillouinZone.moveinto">
<span class="sig-name descname"><span class="pre">moveinto</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/bz.html#brille._brille.BrillouinZone" title="brille._brille.BrillouinZone"><span class="pre">brille._brille.BrillouinZone</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threads</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span></span></span><a class="headerlink" href="#brille.BrillouinZone.moveinto" title="Link to this definition"></a></dt>
<dd><p>Find points equivalent to those provided within the first Brillouin zone.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Q</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – A 2 dimensional array of three-vectors (<code class="docutils literal notranslate"><span class="pre">Q.shape[1]==3</span></code>) expressed in
units of the reciprocal lattice.</p></li>
<li><p><strong>threads</strong> (<em>integer, optional</em>) – The number of parallel threads that should be used. If this value is less
than one the maximum number of OpenMP threads will be used – this value
can be controlled by the environment variable <code class="docutils literal notranslate"><span class="pre">OMP_NUM_THREADS</span></code> and is
typically the number of logical cores if not explicitly set.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The floating point array of equivalent reduced <span class="math">\(\mathbf{q}\)</span>
points for all <span class="math">\(\mathbf{Q}\)</span>, and an integer array filled with
<span class="math">\(\boldsymbol{\tau} = \mathbf{Q}-\mathbf{q}\)</span>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>, <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.0)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BrillouinZone.normals">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">normals</span></span><a class="headerlink" href="#brille.BrillouinZone.normals" title="Link to this definition"></a></dt>
<dd><p>Return the first Brillouin zone face normals in rlu</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BrillouinZone.normals_invA">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">normals_invA</span></span><a class="headerlink" href="#brille.BrillouinZone.normals_invA" title="Link to this definition"></a></dt>
<dd><p>Return the first Brillouin zone face normals in inverse ångstrom</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BrillouinZone.normals_primitive">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">normals_primitive</span></span><a class="headerlink" href="#brille.BrillouinZone.normals_primitive" title="Link to this definition"></a></dt>
<dd><p>Return the first Brillouin zone face normals in primitive-lattice rlu</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BrillouinZone.points">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">points</span></span><a class="headerlink" href="#brille.BrillouinZone.points" title="Link to this definition"></a></dt>
<dd><p>Return the first Brillouin zone face centres in rlu</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BrillouinZone.points_invA">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">points_invA</span></span><a class="headerlink" href="#brille.BrillouinZone.points_invA" title="Link to this definition"></a></dt>
<dd><p>Return the first Brillouin zone face centres in inverse ångstrom</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BrillouinZone.points_primitive">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">points_primitive</span></span><a class="headerlink" href="#brille.BrillouinZone.points_primitive" title="Link to this definition"></a></dt>
<dd><p>Return the first Brillouin zone face centres in primitive-lattice rlu</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BrillouinZone.polyhedron">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">polyhedron</span></span><a class="headerlink" href="#brille.BrillouinZone.polyhedron" title="Link to this definition"></a></dt>
<dd><p>Returns the first Brillouin zone <a class="reference internal" href="#brille.Polyhedron" title="brille._brille.Polyhedron"><code class="xref py py-class docutils literal notranslate"><span class="pre">brille._brille.Polyhedron</span></code></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.BrillouinZone.to_file">
<span class="sig-name descname"><span class="pre">to_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/bz.html#brille._brille.BrillouinZone" title="brille._brille.BrillouinZone"><span class="pre">brille._brille.BrillouinZone</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">entry</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'BrillouinZone'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'ac'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#brille.BrillouinZone.to_file" title="Link to this definition"></a></dt>
<dd><p>Save the object to an HDF5 file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> (<em>str</em>) – The full path specification for the file to write into</p></li>
<li><p><strong>entry</strong> (<em>str</em>) – The group path, e.g., “my/cool/bz”, where to write inside the file,
with a default equal to BrillouinZone name</p></li>
<li><p><strong>flags</strong> (<em>str</em>) – The HDF5 permissions to use when opening the file. Default ‘a’ writes to an
existing file – if <cite>entry</cite> exists in the file it is overwritten.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Possible <cite>flags</cite> are:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><cite>flags</cite></p></th>
<th class="head"><p>meaning</p></th>
<th class="head"><p>HDF equivalent</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>‘r’</p></td>
<td><p>read</p></td>
<td><p>H5F_ACC_RDONLY</p></td>
</tr>
<tr class="row-odd"><td><p>‘x’</p></td>
<td><p>write, error if exists</p></td>
<td><p>H5F_ACC_EXCL</p></td>
</tr>
<tr class="row-even"><td><p>‘a’</p></td>
<td><p>write, append to file</p></td>
<td><p>H5F_ACC_RDWR</p></td>
</tr>
<tr class="row-odd"><td><p>‘c’</p></td>
<td><p>write, error if exists</p></td>
<td><p>H5F_ACC_CREAT</p></td>
</tr>
<tr class="row-even"><td><p>‘t’</p></td>
<td><p>write, replace existing</p></td>
<td><p>H5F_ACC_TRUNC</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Indication of writing success.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BrillouinZone.vertices">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">vertices</span></span><a class="headerlink" href="#brille.BrillouinZone.vertices" title="Link to this definition"></a></dt>
<dd><p>Return the first Brillouin zone unique face corners in rlu</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BrillouinZone.vertices_invA">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">vertices_invA</span></span><a class="headerlink" href="#brille.BrillouinZone.vertices_invA" title="Link to this definition"></a></dt>
<dd><p>Return the first Brillouin zone unique face corners in inverse ångstrom</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BrillouinZone.vertices_per_face">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">vertices_per_face</span></span><a class="headerlink" href="#brille.BrillouinZone.vertices_per_face" title="Link to this definition"></a></dt>
<dd><p>Return the first Brillouin zone face corner indices for each face</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BrillouinZone.vertices_primitive">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">vertices_primitive</span></span><a class="headerlink" href="#brille.BrillouinZone.vertices_primitive" title="Link to this definition"></a></dt>
<dd><p>Return the first Brillouin zone unique face corners in primitive-lattice rlu</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BrillouinZone.wedge_normals">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">wedge_normals</span></span><a class="headerlink" href="#brille.BrillouinZone.wedge_normals" title="Link to this definition"></a></dt>
<dd><p>Return the normals of the irreducible wedge rlu</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BrillouinZone.wedge_normals_invA">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">wedge_normals_invA</span></span><a class="headerlink" href="#brille.BrillouinZone.wedge_normals_invA" title="Link to this definition"></a></dt>
<dd><p>Return the normals of the irreducible wedge inverse ångstrom</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.BrillouinZone.wedge_normals_primitive">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">wedge_normals_primitive</span></span><a class="headerlink" href="#brille.BrillouinZone.wedge_normals_primitive" title="Link to this definition"></a></dt>
<dd><p>Return the normals of the irreducible wedge primitive-lattice rlu</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="brille.HallSymbol">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">brille.</span></span><span class="sig-name descname"><span class="pre">HallSymbol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/symmetry.html#brille._brille.HallSymbol" title="brille._brille.HallSymbol"><span class="pre">brille._brille.HallSymbol</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">Hall_symbol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille.HallSymbol" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<p>A crystallographic spacegroup’s symmetries encoded in Hall’s notation</p>
<p>Hall proposed a compact unambiguous notation for the representation of the
generators of a spacegroup. Within his notation each motion is comprised of
a character with one or more subscripts and superscripts which describe its
order, unique axis, and translation. The notation specifies that, depending
on the position of a motion and details of any preceding motion, some or
all of the sub- and superscripts can be omitted. The <a class="reference internal" href="#brille.HallSymbol" title="brille.HallSymbol"><code class="xref py py-class docutils literal notranslate"><span class="pre">HallSymbol</span></code></a> has
been written to handle the logic necessary to decode a Hall symbol into its
equivalent motions.
An added complication arises when the Hall symbol is encoded as an ASCII
string. Namely, there are no sub- or superscript glyphs and some scheme must
be enacted to represent them.</p>
<dl class="py property">
<dt class="sig sig-object py" id="brille.HallSymbol.generators">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">generators</span></span><a class="headerlink" href="#brille.HallSymbol.generators" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="brille.LPolyhedron">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">brille.</span></span><span class="sig-name descname"><span class="pre">LPolyhedron</span></span><a class="headerlink" href="#brille.LPolyhedron" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<dl class="py property">
<dt class="sig sig-object py" id="brille.LPolyhedron.centre">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">centre</span></span><a class="headerlink" href="#brille.LPolyhedron.centre" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.LPolyhedron.faces">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">faces</span></span><a class="headerlink" href="#brille.LPolyhedron.faces" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.LPolyhedron.intersection">
<span class="sig-name descname"><span class="pre">intersection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#brille.LPolyhedron" title="brille._brille.LPolyhedron"><span class="pre">brille._brille.LPolyhedron</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#brille.LPolyhedron" title="brille._brille.LPolyhedron"><span class="pre">brille._brille.LPolyhedron</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#brille.LPolyhedron" title="brille._brille.LPolyhedron"><span class="pre">brille._brille.LPolyhedron</span></a></span></span><a class="headerlink" href="#brille.LPolyhedron.intersection" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.LPolyhedron.mirror">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">mirror</span></span><a class="headerlink" href="#brille.LPolyhedron.mirror" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.LPolyhedron.normals">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">normals</span></span><a class="headerlink" href="#brille.LPolyhedron.normals" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.LPolyhedron.points">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">points</span></span><a class="headerlink" href="#brille.LPolyhedron.points" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.LPolyhedron.rotate">
<span class="sig-name descname"><span class="pre">rotate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#brille.LPolyhedron" title="brille._brille.LPolyhedron"><span class="pre">brille._brille.LPolyhedron</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/symmetry.html#brille._brille.PointSymmetry" title="brille._brille.PointSymmetry"><span class="pre">brille._brille.PointSymmetry</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#brille.LPolyhedron" title="brille._brille.LPolyhedron"><span class="pre">brille._brille.LPolyhedron</span></a></span></span><a class="headerlink" href="#brille.LPolyhedron.rotate" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.LPolyhedron.to_Cartesian">
<span class="sig-name descname"><span class="pre">to_Cartesian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#brille.LPolyhedron" title="brille._brille.LPolyhedron"><span class="pre">brille._brille.LPolyhedron</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#brille.Polyhedron" title="brille._brille.Polyhedron"><span class="pre">brille._brille.Polyhedron</span></a></span></span><a class="headerlink" href="#brille.LPolyhedron.to_Cartesian" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.LPolyhedron.vertices">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">vertices</span></span><a class="headerlink" href="#brille.LPolyhedron.vertices" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.LPolyhedron.volume">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">volume</span></span><a class="headerlink" href="#brille.LPolyhedron.volume" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="brille.Lattice">
<span class="sig-prename descclassname"><span class="pre">brille.</span></span><span class="sig-name descname"><span class="pre">Lattice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">values</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spacegroup</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmetry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">basis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille.Lattice" title="Link to this definition"></a></dt>
<dd><p>Construct a space-spanning lattice in three dimensions</p>
<p>A space-spanning lattice in <span class="math">\(N\)</span> dimensions has <span class="math">\(N\)</span> basis vectors
which can be described fully by their <span class="math">\(N\)</span> lengths and the
<span class="math">\(\frac{1}{2} N (N-1)\)</span> angles between each set of basis vectors, or
<span class="math">\(\frac{1}{2}N(N+1)\)</span> scalars in total.
This class stores the basis vectors of the lattice described in an orthonormal space,
plus the metric of the space, and the equivalent information for the dual of the lattice.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">brille</span> <span class="kn">import</span> <span class="n">Lattice</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mf">3.95</span><span class="p">,</span> <span class="mf">12.9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">avec</span><span class="p">,</span> <span class="n">bvec</span><span class="p">,</span> <span class="n">cvec</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">basis</span> <span class="o">=</span> <span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">]],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">symmetry</span> <span class="o">=</span> <span class="p">(</span><span class="n">rotations</span><span class="p">,</span> <span class="n">translations</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lat</span> <span class="o">=</span> <span class="n">Lattice</span><span class="p">(([</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">],</span> <span class="p">[</span><span class="mi">90</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">90</span><span class="p">]),</span> <span class="n">spacegroup</span><span class="o">=</span><span class="s1">&#39;I4/mmm&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="n">basis</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lat</span> <span class="o">=</span> <span class="n">Lattice</span><span class="p">(([</span><span class="n">avec</span><span class="p">,</span> <span class="n">bvec</span><span class="p">,</span> <span class="n">cvec</span><span class="p">],),</span> <span class="n">symmetry</span><span class="o">=</span><span class="n">symmetry</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="n">basis</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lat</span> <span class="o">=</span> <span class="n">Lattice</span><span class="p">([</span><span class="n">avec</span><span class="p">,</span> <span class="n">bvec</span><span class="p">,</span> <span class="n">cvec</span><span class="p">],</span> <span class="n">spacegroup</span><span class="o">=</span><span class="s1">&#39;I4/mmm&#39;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="n">basis</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The parameters packed into <code class="docutils literal notranslate"><span class="pre">values</span></code> are position-based and should be <em>either</em> <code class="docutils literal notranslate"><span class="pre">(lengths,</span> <span class="pre">angles)</span></code>
<em>or</em> <code class="docutils literal notranslate"><span class="pre">(vectors,)</span></code> [which also requires setting <code class="docutils literal notranslate"><span class="pre">row_vectors=False</span></code> if the matrix represents column vectors].
The lengths or vector components are interpreted in angstrom or inverse angstrom for real or reciprocal lattice
parameters, respectively, and are assumed to be angstrom if the keyword <code class="docutils literal notranslate"><span class="pre">real_space</span></code> is missing or True.</p>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>values</strong> (<em>(lengths, angles), vectors</em>) – See the note above and the documenation for <code class="docutils literal notranslate"><span class="pre">lengths</span></code>, <code class="docutils literal notranslate"><span class="pre">angles</span></code>, and <code class="docutils literal notranslate"><span class="pre">vectors</span></code> below.</p></li>
<li><p><strong>lengths</strong> (<em>list, tuple, numpy.ndarray</em>) – The three basis vector lengths in angstrom for real lattice, or inverse angstrom for reciprocal lattices</p></li>
<li><p><strong>angles</strong> (<em>list, tuple, numpy.ndarray</em>) – The three angles between the basis vectors in degrees or radians. The angles are interpreted as radians
if none are greater than pi and are otherwise assumed to be degrees.</p></li>
<li><p><strong>vectors</strong> (<em>list[list,…], tuple(tuple,…), numpy.ndarray</em>) – The basis vectors in angstrom for real lattices, or inverse angstrom for reciprocal lattices,
expressed in an orthorhombic coordinate system. An optional keyword argument, <code class="docutils literal notranslate"><span class="pre">row_vectors</span></code>, identifies
if the provided basis vectors are row vectors [<cite>row_vectors=True</cite>, default] or column vectors
[<code class="docutils literal notranslate"><span class="pre">row_vectors=False</span></code>].</p></li>
<li><p><strong>spacegroup</strong> (<em>str, tuple(str, str)</em>) – The International Tables name, Hermann-Mauguin symbol with optional choice, or Hall symbol for the
spacegroup of the lattice. The spacegroup may be provided as positional argument(s) or by keyword.
If present, the <code class="docutils literal notranslate"><span class="pre">symmetry</span></code> keyword must not be used.
Valid syntax for <code class="docutils literal notranslate"><span class="pre">(Hermann-Mauguin,</span> <span class="pre">choice)</span></code> input depends on the spacegroup but is generally one of:</p>
<ul class="simple">
<li><p>a single letter (‘a’, ‘b’, or ‘c’) with possible prepended ‘-’, denoting unique-axis choice</p></li>
<li><p>a single digit (‘1’, ‘2’, or ‘3’), denoting origin choice</p></li>
<li><p>a letter and digit, denoting unique-axis and origin choice</p></li>
<li><p>a permutation of ‘abc’ with possible ‘-’ before one of the letters, denoting axis permutation</p></li>
<li><p>or ‘R’ or ‘H’ for trigonal systems with Rhombohedral or Hexagonal lattice settings, respectively.</p></li>
</ul>
<p>Acceptable values are contained in the C++ source code in the seventh column of
<a class="reference external" href="https://github.com/brille/brille/blob/eecb4cb28227665908793abc47e88c69518c09fc/src/spg_database.cpp#L63-L610">this table</a>
with each line representing one spacegroup with values, in order, defined by the
<a class="reference external" href="https://github.com/brille/brille/blob/eecb4cb28227665908793abc47e88c69518c09fc/src/spg_database.hpp#L80-L91">class signature</a>
These values come from spglib, which likely obtained them from
<a class="reference external" href="https://web.archive.org/web/20210621195003/http://pmsl.planet.sci.kobe-u.ac.jp/~seto/?page_id=37&amp;lang=en">Seto’s Home Page</a>.</p>
</li>
<li><p><strong>symmetry</strong> (<em>brille.Symmetry, tuple(matrices, vectors), str</em>) – The spacegroup symmetry operations as an object, a tuple of the (pseudo)rotation matrices and translation
vectors, or a CIF xyz encoded string. The symmetry information must be provided by keyword.
If present, the ‘spacegroup’ positional argument(s) or keyword must not be used.</p></li>
<li><p><strong>basis</strong> (<em>brille.Basis, tuple(positions, types)</em>) – The atom basis information of the lattice, expressed in units of the real space basis vectors. The types
must be integer and are used only to identify equivalent atoms – they should probably be contiguous from
zero to 1-N where N is the number of unique atoms in the atom basis.
If present, either spacegroup or symmetry information must be provided.</p></li>
<li><p><strong>kwargs</strong> – Keyword arguments are passed to the <a class="reference internal" href="module/lattice.html#brille._brille.Lattice" title="brille._brille.Lattice"><code class="xref py py-class docutils literal notranslate"><span class="pre">brille._brille.Lattice</span></code></a> constructor,
see its documentation for details.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="brille.LengthUnit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">brille.</span></span><span class="sig-name descname"><span class="pre">LengthUnit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#brille.LengthUnit" title="brille._brille.LengthUnit"><span class="pre">brille._brille.LengthUnit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille.LengthUnit" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<blockquote>
<div><p>The units of a number representing a length</p>
</div></blockquote>
<p>Members:</p>
<blockquote>
<div><p>none</p>
<p>angstrom : 10⁻¹⁰ meter</p>
<p>inverse_angstrom : 1 / angstrom</p>
<p>real_lattice : fractional coordinates of real lattice</p>
<p>reciprocal_lattice : fractional coordinates of reciprocal lattice</p>
</div></blockquote>
<dl class="py attribute">
<dt class="sig sig-object py" id="brille.LengthUnit.angstrom">
<span class="sig-name descname"><span class="pre">angstrom</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;LengthUnit.angstrom:</span> <span class="pre">1&gt;</span></em><a class="headerlink" href="#brille.LengthUnit.angstrom" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="brille.LengthUnit.inverse_angstrom">
<span class="sig-name descname"><span class="pre">inverse_angstrom</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;LengthUnit.inverse_angstrom:</span> <span class="pre">2&gt;</span></em><a class="headerlink" href="#brille.LengthUnit.inverse_angstrom" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.LengthUnit.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#brille.LengthUnit.name" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="brille.LengthUnit.none">
<span class="sig-name descname"><span class="pre">none</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;LengthUnit.none:</span> <span class="pre">0&gt;</span></em><a class="headerlink" href="#brille.LengthUnit.none" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="brille.LengthUnit.real_lattice">
<span class="sig-name descname"><span class="pre">real_lattice</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;LengthUnit.real_lattice:</span> <span class="pre">3&gt;</span></em><a class="headerlink" href="#brille.LengthUnit.real_lattice" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="brille.LengthUnit.reciprocal_lattice">
<span class="sig-name descname"><span class="pre">reciprocal_lattice</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;LengthUnit.reciprocal_lattice:</span> <span class="pre">4&gt;</span></em><a class="headerlink" href="#brille.LengthUnit.reciprocal_lattice" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.LengthUnit.value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#brille.LengthUnit.value" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="brille.NodeType">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">brille.</span></span><span class="sig-name descname"><span class="pre">NodeType</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#brille.NodeType" title="brille._brille.NodeType"><span class="pre">brille._brille.NodeType</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille.NodeType" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<blockquote>
<div><p>The units of a number representing a length</p>
</div></blockquote>
<p>Members:</p>
<blockquote>
<div><p>assumed_null : Indicates a node which should be null but no explicit check was performed</p>
<p>found_null : A node which an explicit check found to be null</p>
<p>null : A null node</p>
<p>cube : A cube shaped node</p>
<p>polygon : A convex polygon shaped node</p>
</div></blockquote>
<dl class="py attribute">
<dt class="sig sig-object py" id="brille.NodeType.assumed_null">
<span class="sig-name descname"><span class="pre">assumed_null</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;NodeType.assumed_null:</span> <span class="pre">0&gt;</span></em><a class="headerlink" href="#brille.NodeType.assumed_null" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="brille.NodeType.cube">
<span class="sig-name descname"><span class="pre">cube</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;NodeType.cube:</span> <span class="pre">3&gt;</span></em><a class="headerlink" href="#brille.NodeType.cube" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="brille.NodeType.found_null">
<span class="sig-name descname"><span class="pre">found_null</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;NodeType.found_null:</span> <span class="pre">1&gt;</span></em><a class="headerlink" href="#brille.NodeType.found_null" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.NodeType.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#brille.NodeType.name" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="brille.NodeType.null">
<span class="sig-name descname"><span class="pre">null</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;NodeType.null:</span> <span class="pre">2&gt;</span></em><a class="headerlink" href="#brille.NodeType.null" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="brille.NodeType.polygon">
<span class="sig-name descname"><span class="pre">polygon</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;NodeType.polygon:</span> <span class="pre">4&gt;</span></em><a class="headerlink" href="#brille.NodeType.polygon" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.NodeType.value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#brille.NodeType.value" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="brille.PointSymmetry">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">brille.</span></span><span class="sig-name descname"><span class="pre">PointSymmetry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille.PointSymmetry" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<p>Holds the <span class="math">\(3 \times 3\)</span> rotation matrices <span class="math">\(R\)</span> which comprise
a point group symmetry.</p>
<p>A point group describes the local symmetry of a lattice point. It contains
all of the generalised rotations of a <a class="reference internal" href="module/symmetry.html#brille._brille.Symmetry" title="brille._brille.Symmetry"><code class="xref py py-class docutils literal notranslate"><span class="pre">Symmetry</span></code></a>
with none of its translations.</p>
<p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: brille._brille.PointSymmetry, Hall_number: int, time_reversal: int = 0) -&gt; None</p></li>
<li><p>__init__(self: brille._brille.PointSymmetry, Symmetry: brille._brille.Symmetry) -&gt; None</p></li>
</ol>
<dl class="py property">
<dt class="sig sig-object py" id="brille.PointSymmetry.W">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">W</span></span><a class="headerlink" href="#brille.PointSymmetry.W" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.PointSymmetry.axis">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">axis</span></span><a class="headerlink" href="#brille.PointSymmetry.axis" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.PointSymmetry.generate">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">generate</span></span><a class="headerlink" href="#brille.PointSymmetry.generate" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.PointSymmetry.generators">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">generators</span></span><a class="headerlink" href="#brille.PointSymmetry.generators" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.PointSymmetry.isometry">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">isometry</span></span><a class="headerlink" href="#brille.PointSymmetry.isometry" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.PointSymmetry.nfolds">
<span class="sig-name descname"><span class="pre">nfolds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/symmetry.html#brille._brille.PointSymmetry" title="brille._brille.PointSymmetry"><span class="pre">brille._brille.PointSymmetry</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="module/symmetry.html#brille._brille.PointSymmetry" title="brille._brille.PointSymmetry"><span class="pre">brille._brille.PointSymmetry</span></a></span></span><a class="headerlink" href="#brille.PointSymmetry.nfolds" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.PointSymmetry.order">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">order</span></span><a class="headerlink" href="#brille.PointSymmetry.order" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.PointSymmetry.size">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">size</span></span><a class="headerlink" href="#brille.PointSymmetry.size" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="brille.Pointgroup">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">brille.</span></span><span class="sig-name descname"><span class="pre">Pointgroup</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self:</span> <span class="pre">brille._brille.Pointgroup</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Pointgroup</span> <span class="pre">number:</span> <span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille.Pointgroup" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<dl class="py property">
<dt class="sig sig-object py" id="brille.Pointgroup.holohedry">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">holohedry</span></span><a class="headerlink" href="#brille.Pointgroup.holohedry" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.Pointgroup.laue">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">laue</span></span><a class="headerlink" href="#brille.Pointgroup.laue" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.Pointgroup.number">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">number</span></span><a class="headerlink" href="#brille.Pointgroup.number" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.Pointgroup.symbol">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">symbol</span></span><a class="headerlink" href="#brille.Pointgroup.symbol" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="brille.Polyhedron">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">brille.</span></span><span class="sig-name descname"><span class="pre">Polyhedron</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille.Polyhedron" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: brille._brille.Polyhedron, vertices: numpy.ndarray[numpy.float64]) -&gt; None</p></li>
<li><p>__init__(self: brille._brille.Polyhedron, vertices: numpy.ndarray[numpy.float64], faces: list[list[int]]) -&gt; None</p></li>
</ol>
<dl class="py property">
<dt class="sig sig-object py" id="brille.Polyhedron.centre">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">centre</span></span><a class="headerlink" href="#brille.Polyhedron.centre" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.Polyhedron.faces">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">faces</span></span><a class="headerlink" href="#brille.Polyhedron.faces" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.Polyhedron.intersection">
<span class="sig-name descname"><span class="pre">intersection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#brille.Polyhedron" title="brille._brille.Polyhedron"><span class="pre">brille._brille.Polyhedron</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#brille.Polyhedron" title="brille._brille.Polyhedron"><span class="pre">brille._brille.Polyhedron</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#brille.Polyhedron" title="brille._brille.Polyhedron"><span class="pre">brille._brille.Polyhedron</span></a></span></span><a class="headerlink" href="#brille.Polyhedron.intersection" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.Polyhedron.mirror">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">mirror</span></span><a class="headerlink" href="#brille.Polyhedron.mirror" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.Polyhedron.normals">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">normals</span></span><a class="headerlink" href="#brille.Polyhedron.normals" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.Polyhedron.points">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">points</span></span><a class="headerlink" href="#brille.Polyhedron.points" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.Polyhedron.vertices">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">vertices</span></span><a class="headerlink" href="#brille.Polyhedron.vertices" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.Polyhedron.volume">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">volume</span></span><a class="headerlink" href="#brille.Polyhedron.volume" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="brille.PrimitiveTransform">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">brille.</span></span><span class="sig-name descname"><span class="pre">PrimitiveTransform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self:</span> <span class="pre">brille._brille.PrimitiveTransform</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Hall</span> <span class="pre">number:</span> <span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille.PrimitiveTransform" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<dl class="py property">
<dt class="sig sig-object py" id="brille.PrimitiveTransform.P">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">P</span></span><a class="headerlink" href="#brille.PrimitiveTransform.P" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.PrimitiveTransform.Pt">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Pt</span></span><a class="headerlink" href="#brille.PrimitiveTransform.Pt" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.PrimitiveTransform.does_anything">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">does_anything</span></span><a class="headerlink" href="#brille.PrimitiveTransform.does_anything" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.PrimitiveTransform.invP">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">invP</span></span><a class="headerlink" href="#brille.PrimitiveTransform.invP" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.PrimitiveTransform.invPt">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">invPt</span></span><a class="headerlink" href="#brille.PrimitiveTransform.invPt" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.PrimitiveTransform.is_primitive">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">is_primitive</span></span><a class="headerlink" href="#brille.PrimitiveTransform.is_primitive" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="brille.RotatesLike">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">brille.</span></span><span class="sig-name descname"><span class="pre">RotatesLike</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/grids.html#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><span class="pre">brille._brille.RotatesLike</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille.RotatesLike" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<blockquote>
<div><p>Enumeration indicating how vector and matrix values transform</p>
</div></blockquote>
<p>Members:</p>
<blockquote>
<div><p>vector : Rotates like a vector</p>
<p>pseudovector : Rotates like a pseudovector</p>
<p>Gamma : Rotates like a (real space) phonon eigenvector</p>
</div></blockquote>
<dl class="py attribute">
<dt class="sig sig-object py" id="brille.RotatesLike.Gamma">
<span class="sig-name descname"><span class="pre">Gamma</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;RotatesLike.Gamma:</span> <span class="pre">2&gt;</span></em><a class="headerlink" href="#brille.RotatesLike.Gamma" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.RotatesLike.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#brille.RotatesLike.name" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="brille.RotatesLike.pseudovector">
<span class="sig-name descname"><span class="pre">pseudovector</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;RotatesLike.pseudovector:</span> <span class="pre">1&gt;</span></em><a class="headerlink" href="#brille.RotatesLike.pseudovector" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.RotatesLike.value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#brille.RotatesLike.value" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="brille.RotatesLike.vector">
<span class="sig-name descname"><span class="pre">vector</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;RotatesLike.vector:</span> <span class="pre">0&gt;</span></em><a class="headerlink" href="#brille.RotatesLike.vector" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="brille.SortingStatus">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">brille.</span></span><span class="sig-name descname"><span class="pre">SortingStatus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#brille.SortingStatus" title="brille._brille.SortingStatus"><span class="pre">brille._brille.SortingStatus</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">sorted</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">locked</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">visits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille.SortingStatus" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<p>An object representing the status of a single object under sorting.</p>
<p>Internally may be represented as a single unsigned integer where two or
more bits are reserved for various flags, or as a set of boolean values
and an integer.</p>
<dl class="py property">
<dt class="sig sig-object py" id="brille.SortingStatus.locked">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">locked</span></span><a class="headerlink" href="#brille.SortingStatus.locked" title="Link to this definition"></a></dt>
<dd><p>Return the locked flag</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.SortingStatus.sorted">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">sorted</span></span><a class="headerlink" href="#brille.SortingStatus.sorted" title="Link to this definition"></a></dt>
<dd><p>Return the sorted flag</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.SortingStatus.visits">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">visits</span></span><a class="headerlink" href="#brille.SortingStatus.visits" title="Link to this definition"></a></dt>
<dd><p>Return the visit count</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="brille.Spacegroup">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">brille.</span></span><span class="sig-name descname"><span class="pre">Spacegroup</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self:</span> <span class="pre">brille._brille.Spacegroup</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Hall</span> <span class="pre">number:</span> <span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille.Spacegroup" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<dl class="py property">
<dt class="sig sig-object py" id="brille.Spacegroup.choice">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">choice</span></span><a class="headerlink" href="#brille.Spacegroup.choice" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.Spacegroup.hall_number">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">hall_number</span></span><a class="headerlink" href="#brille.Spacegroup.hall_number" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.Spacegroup.hall_symbol">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">hall_symbol</span></span><a class="headerlink" href="#brille.Spacegroup.hall_symbol" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.Spacegroup.international_table_full">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">international_table_full</span></span><a class="headerlink" href="#brille.Spacegroup.international_table_full" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.Spacegroup.international_table_number">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">international_table_number</span></span><a class="headerlink" href="#brille.Spacegroup.international_table_number" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.Spacegroup.international_table_short">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">international_table_short</span></span><a class="headerlink" href="#brille.Spacegroup.international_table_short" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.Spacegroup.international_table_symbol">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">international_table_symbol</span></span><a class="headerlink" href="#brille.Spacegroup.international_table_symbol" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.Spacegroup.pointgroup_number">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">pointgroup_number</span></span><a class="headerlink" href="#brille.Spacegroup.pointgroup_number" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.Spacegroup.schoenflies_symbol">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">schoenflies_symbol</span></span><a class="headerlink" href="#brille.Spacegroup.schoenflies_symbol" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="brille.Symmetry">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">brille.</span></span><span class="sig-name descname"><span class="pre">Symmetry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille.Symmetry" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pybind11_object</span></code></p>
<p>One or more symmetry operations of a space group.</p>
<p>A symmetry operation is the combination of a generalised rotation, <span class="math">\(W\)</span>,
and translation, <span class="math">\(\mathbf{w}\)</span>.
For any position in space, <span class="math">\(\mathbf{x}\)</span>, the operation transforms
<span class="math">\(\mathbf{x}\)</span> to another equivalent position</p>
<div class="math">
\[\mathbf{x}' = W \mathbf{x} + \mathbf{w}

\]</div>
<p>and can equivalently be expressed as <span class="math">\(\mathbf{x}' = \mathscr{M}\mathbf{x}\)</span>.</p>
<p>Crystallographic symmetry operations have an order, <span class="math">\(o\)</span>,
for which <span class="math">\(\mathscr{M}^o = \mathscr{E}\)</span> i.e. <span class="math">\(o\)</span> repeated
applications of the operation is equivalent to the identity operator.</p>
<p>A set of symmetry operations can form a group, <span class="math">\(\mathbb{G}\)</span>, with the property that
<span class="math">\(\mathscr{M}_k = \mathscr{M}_i \mathscr{M}_j\)</span> with <span class="math">\(\mathscr{M}_i,\mathscr{M}_j,\mathscr{M}_k \in \mathbb{G}\)</span>.</p>
<p>This class can be used to hold any number of related symmetry operators, and to generate all spacegroup operators from those stored.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hall</strong> (<em>int</em>) – The integer Hall number for the desired space group operations [[deprecated]].</p></li>
<li><p><strong>W</strong> (<em>arraylike, int</em>) – The generalised rotation (matrix) part of the symmetry operator(s)</p></li>
<li><p><strong>w</strong> (<em>arraylike, float</em>) – The translation (vector) part of the symmetry operator(s)</p></li>
<li><p><strong>cifxyz</strong> (<em>str</em>) – The symmetry operator(s) encoded in CIF xyz format</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The overloaded forms of <code class="docutils literal notranslate"><span class="pre">__init__</span></code> take one of <strong>hall</strong>, (<strong>W</strong>, <strong>w</strong>), <em>or</em> <strong>cifxyz</strong>.</p>
</div>
<p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: brille._brille.Symmetry, Hall number: int) -&gt; None</p></li>
<li><p>__init__(self: brille._brille.Symmetry, W: numpy.ndarray[numpy.int32], w: numpy.ndarray[numpy.float64]) -&gt; None</p></li>
<li><p>__init__(self: brille._brille.Symmetry, CIF xyz string: str) -&gt; None</p></li>
</ol>
<dl class="py property">
<dt class="sig sig-object py" id="brille.Symmetry.W">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">W</span></span><a class="headerlink" href="#brille.Symmetry.W" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.Symmetry.centring">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">centring</span></span><a class="headerlink" href="#brille.Symmetry.centring" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.Symmetry.generate">
<span class="sig-name descname"><span class="pre">generate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/symmetry.html#brille._brille.Symmetry" title="brille._brille.Symmetry"><span class="pre">brille._brille.Symmetry</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="module/symmetry.html#brille._brille.Symmetry" title="brille._brille.Symmetry"><span class="pre">brille._brille.Symmetry</span></a></span></span><a class="headerlink" href="#brille.Symmetry.generate" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille.Symmetry.generators">
<span class="sig-name descname"><span class="pre">generators</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="module/symmetry.html#brille._brille.Symmetry" title="brille._brille.Symmetry"><span class="pre">brille._brille.Symmetry</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="module/symmetry.html#brille._brille.Symmetry" title="brille._brille.Symmetry"><span class="pre">brille._brille.Symmetry</span></a></span></span><a class="headerlink" href="#brille.Symmetry.generators" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.Symmetry.size">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">size</span></span><a class="headerlink" href="#brille.Symmetry.size" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille.Symmetry.w">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">w</span></span><a class="headerlink" href="#brille.Symmetry.w" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="brille.real_space_tolerance">
<span class="sig-prename descclassname"><span class="pre">brille.</span></span><span class="sig-name descname"><span class="pre">real_space_tolerance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille.real_space_tolerance" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>real_space_tolerance() -&gt; float</p></li>
<li><p>real_space_tolerance(arg0: float) -&gt; None</p></li>
</ol>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="brille.reciprocal_space_tolerance">
<span class="sig-prename descclassname"><span class="pre">brille.</span></span><span class="sig-name descname"><span class="pre">reciprocal_space_tolerance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille.reciprocal_space_tolerance" title="Link to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>reciprocal_space_tolerance() -&gt; float</p></li>
<li><p>reciprocal_space_tolerance(arg0: float) -&gt; None</p></li>
</ol>
</dd></dl>

<section id="documented-thus-far">
<span id="module-brille._brille"></span><h1>Documented thus far:<a class="headerlink" href="#documented-thus-far" title="Link to this heading"></a></h1>
<p>The pybind-wrapped objects fully documented (in C++ doc strings) thus far are</p>
<p><a class="reference internal" href="module/lattice.html#brille._brille.Bravais" title="brille._brille.Bravais"><code class="xref py py-class docutils literal notranslate"><span class="pre">Bravais</span></code></a>
<a class="reference internal" href="module/lattice.html#brille._brille.Lattice" title="brille._brille.Lattice"><code class="xref py py-class docutils literal notranslate"><span class="pre">Lattice</span></code></a></p>
<div class="toctree-wrapper compound">
<p class="caption" role="heading"><span class="caption-text">Index</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="module/lattice.html">Lattices</a></li>
<li class="toctree-l1"><a class="reference internal" href="module/debug.html">Debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="module/bz.html">Brillouin Zone</a></li>
<li class="toctree-l1"><a class="reference internal" href="module/grids.html">Grids</a></li>
<li class="toctree-l1"><a class="reference internal" href="module/symmetry.html">Symmetry</a></li>
<li class="toctree-l1"><a class="reference internal" href="module/everything.html">Remainder</a></li>
</ul>
</div>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="tutorials/tutorial_01.html" class="btn btn-neutral float-left" title="Specifying a lattice Spacegroup" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="module/lattice.html" class="btn btn-neutral float-right" title="Lattices" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, Gregory Tucker.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>
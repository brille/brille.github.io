<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Grids &mdash; brille 0.6.1.dev14+g6dcd3ad documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.0/dist/katex.min.css" type="text/css" />
      <link rel="stylesheet" href="../_static/katex-math.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/katex@0.15.0/dist/katex.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/katex@0.15.0/dist/contrib/auto-render.min.js"></script>
        <script src="../_static/katex_autorenderer.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Symmetry" href="symmetry.html" />
    <link rel="prev" title="Brillouin Zone" href="bz.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> brille
            <img src="../_static/brille.svg" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.6.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">User documents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../install_guide.html">Installation Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../motivation.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../memory_usage.html">Memory Use</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tutorial.html">User Guide</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API documents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../brille.html">Python module <code class="xref py py-mod docutils literal notranslate"><span class="pre">brille</span></code></a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../brille.html#documented-thus-far">Documented thus far:</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="lattice.html">Lattices</a></li>
<li class="toctree-l2"><a class="reference internal" href="debug.html">Debugging</a></li>
<li class="toctree-l2"><a class="reference internal" href="bz.html">Brillouin Zone</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Grids</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#regular-grids">Regular grids</a></li>
<li class="toctree-l3"><a class="reference internal" href="#triangulated-grids">Triangulated grids</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#simple">Simple</a></li>
<li class="toctree-l4"><a class="reference internal" href="#hierarchy">Hierarchy</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#hybrid-grids">Hybrid grids</a></li>
<li class="toctree-l3"><a class="reference internal" href="#helper-classes">Helper classes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="symmetry.html">Symmetry</a></li>
<li class="toctree-l2"><a class="reference internal" href="everything.html">Remainder</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../plotting.html">Plotting utilities for <code class="docutils literal notranslate"><span class="pre">brille</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../utils.html">Utilities for <code class="docutils literal notranslate"><span class="pre">brille</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../doxygen.html">Doxygen documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../undoc_brille.html">Undocumented C++ Classes</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">brille</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../brille.html">Python module <code class="xref py py-mod docutils literal notranslate"><span class="pre">brille</span></code></a> &raquo;</li>
      <li>Grids</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/module/grids.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="grids">
<h1>Grids<a class="headerlink" href="#grids" title="Permalink to this headline"></a></h1>
<p>There are likely myriad ways one could divide an <span class="math">\(N\)</span> dimensional
space but the two most basic building blocks are the parallelepiped
(or its <span class="math">\(N\)</span> dimensional equivalent) and the <span class="math">\(N\)</span>-simplex.
An <span class="math">\(N\)</span>-simplex always requires <span class="math">\(N+1\)</span> points
where a parallelepiped requires <span class="math">\(2^N\)</span>.</p>
<p>The parallelepiped lends itself to a regular grid while arrangements of <cite>N</cite>-simplexs can be regular or irregular.
In two dimensions the parallelepiped grid is a regular Cartesian grid:</p>
<div class="figure" style="text-align: center"><p><img  src="../_images/tikz-9b49e5823c5b67fda7921ff5e39427254d27da8f.svg" alt="Figure made with TikZ" /></p>
</div><p>while an irregular mesh of triangles is also possible:</p>
<div class="figure" style="text-align: center"><p><img  src="../_images/tikz-0409b50474d169000f3835a3eebd7216ad25c2dc.svg" alt="Figure made with TikZ" /></p>
</div><p>The <a class="reference internal" href="../brille.html#module-brille._brille" title="brille._brille"><code class="xref py py-mod docutils literal notranslate"><span class="pre">brille._brille</span></code></a> module implements multiple grid types for linear interpolation
within the first or irreducible Brillouin zone.
In most cases the <a class="reference internal" href="#brille._brille.BZTrellisQdc" title="brille._brille.BZTrellisQdc"><code class="xref py py-class docutils literal notranslate"><span class="pre">BZTrellisQdc</span></code></a> should be used.</p>
<p>Since the grids are intended to be used with eigenvectors and their associated eigenvalues
each must support mixed real and complex data.
To allow this, each type of grid is exposed to Python three times with a suffix
<cite>dd</cite> for <cite>(double, double)</cite>, <cite>dc</cite> for <cite>(double, std::complex&lt;double&gt;)</cite>
and <cite>cc</cite> for <cite>(std::complex&lt;double&gt;, std::complex&lt;double&gt;)</cite>.</p>
<section id="regular-grids">
<h2>Regular grids<a class="headerlink" href="#regular-grids" title="Permalink to this headline"></a></h2>
<p>Interpolation using grids constructed of regular parallelepipeds is possible,
but will lead to artefacts near the Brillouin zone boundary if the primitive
lattice has any non-orthogonal basis vectors.
This is such a large restriction that regular grids are no longer supported in <a class="reference internal" href="../brille.html#module-brille._brille" title="brille._brille"><code class="xref py py-mod docutils literal notranslate"><span class="pre">brille._brille</span></code></a></p>
<div class="figure" style="text-align: center"><p><img  src="../_images/tikz-e0ae3754da374bddfe7ac535009b74dca4f59200.svg" alt="Figure made with TikZ" /></p>
</div></section>
<section id="triangulated-grids">
<h2>Triangulated grids<a class="headerlink" href="#triangulated-grids" title="Permalink to this headline"></a></h2>
<p>An alternative to the regular parallelepiped grid which may still have some utility is the
triangulation of a bounded space.
If the triangulated space is bounded by a polyhedron then the triangulation can always
represent it exactly, though possibly with sub-optimal triangulated cells.</p>
<div class="figure" style="text-align: center"><p><img  src="../_images/tikz-69b5c738b8af6eada71de2fd79c6cac957d00d78.svg" alt="Figure made with TikZ" /></p>
</div><p>There are two exposed implementations of the triangulated grid,
both detailed below under the headings <a class="reference internal" href="#simple">Simple</a> and <a class="reference internal" href="#hierarchy">Hierarchy</a>.</p>
<section id="simple">
<h3>Simple<a class="headerlink" href="#simple" title="Permalink to this headline"></a></h3>
<p>The <a class="reference internal" href="#brille._brille.BZMeshQdc" title="brille._brille.BZMeshQdc"><code class="xref py py-class docutils literal notranslate"><span class="pre">BZMeshQdc</span></code></a> and its type-siblings implement a simple triangulated grid.
Locating the tetrahedron within the grid which contains a test point could require as many in-tetrahedron
checks as there are tetrahedra in the grid.
This class should be fine for use in applications where intra-grid-point interpolation is not required,
such as Brillouin zone integrations, but should be avoided when interpolation at random points is required.</p>
<dl class="py class">
<dt class="sig sig-object py" id="brille._brille.BZMeshQdd">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">brille._brille.</span></span><span class="sig-name descname"><span class="pre">BZMeshQdd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#brille._brille.BZMeshQdd" title="brille._brille.BZMeshQdd"><span class="pre">brille._brille.BZMeshQdd</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">bz_</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="bz.html#brille._brille.BrillouinZone" title="brille._brille.BrillouinZone"><span class="pre">brille._brille.BrillouinZone</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-</span> <span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_levels</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_points</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#brille._brille.BZMeshQdd" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="brille._brille.BZMeshQcc">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">brille._brille.</span></span><span class="sig-name descname"><span class="pre">BZMeshQcc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#brille._brille.BZMeshQcc" title="brille._brille.BZMeshQcc"><span class="pre">brille._brille.BZMeshQcc</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">bz_</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="bz.html#brille._brille.BrillouinZone" title="brille._brille.BrillouinZone"><span class="pre">brille._brille.BrillouinZone</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-</span> <span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_levels</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_points</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#brille._brille.BZMeshQcc" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="brille._brille.BZMeshQdc">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">brille._brille.</span></span><span class="sig-name descname"><span class="pre">BZMeshQdc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#brille._brille.BZMeshQdc" title="brille._brille.BZMeshQdc"><span class="pre">brille._brille.BZMeshQdc</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">bz_</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="bz.html#brille._brille.BrillouinZone" title="brille._brille.BrillouinZone"><span class="pre">brille._brille.BrillouinZone</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-</span> <span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_levels</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_points</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#brille._brille.BZMeshQdc" title="Permalink to this definition"></a></dt>
<dd><dl class="py property">
<dt class="sig sig-object py" id="brille._brille.BZMeshQdc.bytes_per_point">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bytes_per_point</span></span><a class="headerlink" href="#brille._brille.BZMeshQdc.bytes_per_point" title="Permalink to this definition"></a></dt>
<dd><p>Return the memory required per interpolation point <em>result</em> in bytes</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille._brille.BZMeshQdc.fill">
<span class="sig-name descname"><span class="pre">fill</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille._brille.BZMeshQdc.fill" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>fill(self: brille._brille.BZMeshQdc, values_data: numpy.ndarray[numpy.float64], values_elements: numpy.ndarray[numpy.int32], vectors_data: numpy.ndarray[numpy.complex128], vectors_elements: numpy.ndarray[numpy.int32], sort: bool = False) -&gt; None</p></li>
</ol>
<p>Provide data required for interpolation to the grid without cost information.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul>
<li><p><strong>values_data</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.23)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – The eigenvalue data to be stored in the grid. The first dimension must be
equal in size to the number of grid-vertices. If two dimensional the second
dimension is interpreted as all information for a single mode flattened
and concatenated into (scalars, vectors, matrices) – in that order.
If more than two dimensional, the second dimension indexes modes and
higher dimensions will be flattened <em>as if row ordered</em> and must flatten into
a concatenated list of (scalars, vectors, matrices).
If the provided array can be interpreted as a contiguous row-ordered two
dimensional array it will be used in place, otherwise a copy will be made.</p></li>
<li><p><strong>values_elements</strong> (<em>integer vector-like</em>) –</p>
<dl class="simple">
<dt>A multi-purpose vector containing, in order:</dt><dd><ul class="simple">
<li><p>the number of scalar-like eigenvalue elements,</p></li>
<li><p>the number of vector-like eigenvalue <em>elements</em> (must be <span class="math">\(3\times N\)</span>),</p></li>
<li><p>the number of matrix-like eigenvalue <em>elements</em> (must be <span class="math">\(9\times N\)</span>),</p></li>
<li><p>an integer <a class="reference internal" href="#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> value denoting
<em>how</em> the vector-like and matrix-like parts transform under application
of a symmetry operation (see note below).</p></li>
</ul>
</dd>
</dl>
</li>
<li><p><strong>vectors_data</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.23)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – The eigenvector data to be stored in the grid. Same shape restrictions as
<strong>values_data</strong></p></li>
<li><p><strong>vectors_elements</strong> – Like <strong>values_elements</strong> but for the eigenvectors</p></li>
<li><p><strong>sort</strong> (logical (default <code class="docutils literal notranslate"><span class="pre">False</span></code>)) – Whether the equivalent-mode permutations should be (re)determined following
the update to the flags and weights.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Mapping of integers to <a class="reference internal" href="#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> values:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 15%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>Real</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>Reciprocal</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>Axial</cite></p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p><cite>Gamma</cite></p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 0.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>fill(self: brille._brille.BZMeshQdc, values_data: numpy.ndarray[numpy.float64], values_elements: numpy.ndarray[numpy.int32], values_weights: numpy.ndarray[numpy.float64], vectors_data: numpy.ndarray[numpy.complex128], vectors_elements: numpy.ndarray[numpy.int32], vectors_weights: numpy.ndarray[numpy.float64], sort: bool = False) -&gt; None</p></li>
</ol>
<p>Provide all data required for interpolation to the grid at once</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul>
<li><p><strong>values_data</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.23)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – The eigenvalue data to be stored in the grid. The first dimension must be
equal in size to the number of grid-vertices. If two dimensional the second
dimension is interpreted as all information for a single mode flattened
and concatenated into (scalars, vectors, matrices) – in that order.
If more than two dimensional, the second dimension indexes modes and
higher dimensions will be flattened <em>as if row ordered</em> and must flatten into
a concatenated list of (scalars, vectors, matrices).
If the provided array can be interpreted as a contiguous row-ordered two
dimensional array it will be used in place, otherwise a copy will be made.</p></li>
<li><p><strong>values_elements</strong> (<em>integer vector-like</em>) –</p>
<dl class="simple">
<dt>A multi-purpose vector containing, in order:</dt><dd><ul class="simple">
<li><p>the number of scalar-like eigenvalue elements,</p></li>
<li><p>the number of vector-like eigenvalue <em>elements</em> (must be <span class="math">\(3\times N\)</span>),</p></li>
<li><p>the number of matrix-like eigenvalue <em>elements</em> (must be <span class="math">\(9\times N\)</span>),</p></li>
<li><p>an integer <a class="reference internal" href="#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> value denoting
<em>how</em> the vector-like and matrix-like parts transform under application
of a symmetry operation (see note below),</p></li>
<li><p>which scalar cost function should be used (see below),</p></li>
<li><p>which vector cost function should be used (see below).</p></li>
</ul>
</dd>
</dl>
<p>See the note below fore the meaning of the last three values.</p>
</li>
<li><p><strong>values_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvalue elements stored in the grid</p></li>
<li><p><strong>vectors_data</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.23)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – The eigenvector data to be stored in the grid. Same shape restrictions as
<strong>values_data</strong></p></li>
<li><p><strong>vectors_elements</strong> – Like <strong>values_elements</strong> but for the eigenvectors</p></li>
<li><p><strong>vectors_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvector elements stored in the grid</p></li>
<li><p><strong>sort</strong> (logical (default <code class="docutils literal notranslate"><span class="pre">False</span></code>)) – Whether the equivalent-mode permutations should be (re)determined following
the update to the flags and weights.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Mapping of integers to <a class="reference internal" href="#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> values:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 15%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>Real</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>Reciprocal</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>Axial</cite></p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p><cite>Gamma</cite></p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to scalar cost function:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(x,y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>magnitude(x-y)</p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to vector cost function:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 16%" />
<col style="width: 84%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(vec_x, vec_y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>sin(hermitian_angle(vec_x, vec_y))</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>vector_distance(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>1 - vector_product(vec_x, vec_y)</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>vector_angle(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>hermitian_angle(vec_x, vec_y)</p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 0.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille._brille.BZMeshQdc.from_file">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">entry</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'BZMeshQdc'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#brille._brille.BZMeshQdc" title="brille._brille.BZMeshQdc"><span class="pre">brille._brille.BZMeshQdc</span></a></span></span><a class="headerlink" href="#brille._brille.BZMeshQdc.from_file" title="Permalink to this definition"></a></dt>
<dd><p>Save the object to an HDF5 file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> (<em>str</em>) – The full path specification for the file to read from</p></li>
<li><p><strong>entry</strong> (<em>str</em>) – The group path, e.g., “my/cool/grid”, where to read from inside the file,
with a default equal to the object Class name</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>clsObj</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille._brille.BZMeshQdc.ir_interpolate_at">
<span class="sig-name descname"><span class="pre">ir_interpolate_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#brille._brille.BZMeshQdc" title="brille._brille.BZMeshQdc"><span class="pre">brille._brille.BZMeshQdc</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.23)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">useparallel</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threads</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">do_not_move_points</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.23)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.23)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.complex128</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#brille._brille.BZMeshQdc.ir_interpolate_at" title="Permalink to this definition"></a></dt>
<dd><p>Perform linear interpolation of the stored data at irreducible equivalent points</p>
<p>The irreducible first Brillouin zone is the part of reciprocal space which is
invariant under application of the integer translations <em>and</em> the pointgroup
operations of a reciprocal space lattice. This method finds points equivalent
to the input within the irreducible first Brillouin zone and then interpolates
pre-stored information to provide an estimate at the found positions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Q</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.23)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – A two dimensional array with <code class="docutils literal notranslate"><span class="pre">Q.shape[1]</span> <span class="pre">==</span> <span class="pre">3</span></code> containing the positions at
which an interpolated result is required, expressed in units of the
reciprocal lattice.</p></li>
<li><p><strong>useparallel</strong> (<em>bool, optional</em>) – Whether a serial or parallel code should be utilised</p></li>
<li><p><strong>threads</strong> (<em>int, optional</em>) – How many OpenMP workers should be utilised; if this value is less than one
the environment variable <code class="docutils literal notranslate"><span class="pre">OMP_NUM_THREADS</span></code> will be used.</p></li>
<li><p><strong>do_not_move_points</strong> (<em>bool, optional</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code> the provided <strong>Q</strong> points must already lie within the first Brillouin
zone. No check is made to verify this requirement and if any <strong>Q</strong> lie outside
of the gridded volume out-of-bounds errors may result in bad data or runtime
errors.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The interpolated eigenvalues and eigenvectors at the equivalent
irreducible first Brillouin zone points.
The shape of each output will depend on the shape of the data provided to
the <a class="reference internal" href="#brille._brille.BZTrellisQdc.fill" title="brille._brille.BZTrellisQdc.fill"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fill()</span></code></a> method. i
If the filled eigenvalues were of shape
<code class="docutils literal notranslate"><span class="pre">[N_grid_points,</span> <span class="pre">N_modes,</span> <span class="pre">A,</span> <span class="pre">...,</span> <span class="pre">B]</span></code>, the eigenvectors were of shape
<code class="docutils literal notranslate"><span class="pre">[N_grid_points,</span> <span class="pre">N_modes,</span> <span class="pre">C,</span> <span class="pre">...,</span> <span class="pre">D]</span></code>, and the provided points of shape
<code class="docutils literal notranslate"><span class="pre">[N_Q_points,</span> <span class="pre">3]</span></code> then the output shapes will be
<code class="docutils literal notranslate"><span class="pre">[N_Q_points,</span> <span class="pre">N_modes,</span> <span class="pre">A,</span> <span class="pre">...,</span> <span class="pre">B]</span></code> and <code class="docutils literal notranslate"><span class="pre">[N_Q_points,</span> <span class="pre">N_modes,</span> <span class="pre">C,</span> <span class="pre">...,</span> <span class="pre">D]</span></code>
for the eigenvalues and eigenvectors, respectively.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille._brille.BZMeshQdc.set_flags_weights">
<span class="sig-name descname"><span class="pre">set_flags_weights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#brille._brille.BZMeshQdc" title="brille._brille.BZMeshQdc"><span class="pre">brille._brille.BZMeshQdc</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">values_flags</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.23)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">values_weights</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.23)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vectors_flags</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.23)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vectors_weights</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.23)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#brille._brille.BZMeshQdc.set_flags_weights" title="Permalink to this definition"></a></dt>
<dd><p>Set <a class="reference internal" href="#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> and cost functions plus
relative cost weights for the values and vectors stored in the object</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>values_flags</strong> (<em>integer, vector-like</em>) – One or more values indicating the <a class="reference internal" href="#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a>
value for the eigenvalues stored in the object, plus which cost function
to use when comparing stored eigenvalues at neighbouring grid points for
scalar- and vector-like eigenvalues.</p></li>
<li><p><strong>values_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvalue elements stored in the grid</p></li>
<li><p><strong>vectors_flags</strong> (<em>integer, vector-like</em>) – One or more values indicating the <a class="reference internal" href="#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a>
value for the eigenvectors stored in the object, plus which cost function
to use when comparing stored eigenvectors at neighbouring grid points for
scalar- and vector-like eigenvectors.</p></li>
<li><p><strong>vectors_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvector elements stored in the grid</p></li>
<li><p><strong>sort</strong> (<em>bool, optional</em>) – Whether the equivalent-mode permutations should be (re)determined following
the update to the flags and weights.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Mapping of integers to <a class="reference internal" href="#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> values:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 15%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>Real</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>Reciprocal</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>Axial</cite></p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p><cite>Gamma</cite></p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to scalar cost function:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(x,y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>magnitude(x-y)</p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to vector cost function:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 16%" />
<col style="width: 84%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(vec_x, vec_y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>sin(hermitian_angle(vec_x, vec_y))</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>vector_distance(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>1 - vector_product(vec_x, vec_y)</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>vector_angle(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>hermitian_angle(vec_x, vec_y)</p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 0.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille._brille.BZMeshQdc.sort">
<span class="sig-name descname"><span class="pre">sort</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#brille._brille.BZMeshQdc" title="brille._brille.BZMeshQdc"><span class="pre">brille._brille.BZMeshQdc</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#brille._brille.BZMeshQdc.sort" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille._brille.BZMeshQdc.to_file">
<span class="sig-name descname"><span class="pre">to_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#brille._brille.BZMeshQdc" title="brille._brille.BZMeshQdc"><span class="pre">brille._brille.BZMeshQdc</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">entry</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'BZMeshQdc'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'ac'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#brille._brille.BZMeshQdc.to_file" title="Permalink to this definition"></a></dt>
<dd><p>Save the object to an HDF5 file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> (<em>str</em>) – The full path specification for the file to write into</p></li>
<li><p><strong>entry</strong> (<em>str</em>) – The group path, e.g., “my/cool/grid”, where to write inside the file,
with a default equal to the object Class name</p></li>
<li><p><strong>flags</strong> (<em>str</em>) – The HDF5 permissions to use when opening the file. Default ‘a’ writes to an
existing file – if <cite>entry</cite> exists in the file it is overwritten.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Possible <cite>flags</cite> are:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 18%" />
<col style="width: 50%" />
<col style="width: 32%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><cite>flags</cite></p></th>
<th class="head"><p>meaning</p></th>
<th class="head"><p>HDF equivalent</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>‘r’</p></td>
<td><p>read</p></td>
<td><p>H5F_ACC_RDONLY</p></td>
</tr>
<tr class="row-odd"><td><p>‘x’</p></td>
<td><p>write, error if exists</p></td>
<td><p>H5F_ACC_EXCL</p></td>
</tr>
<tr class="row-even"><td><p>‘a’</p></td>
<td><p>write, append to file</p></td>
<td><p>H5F_ACC_RDWR</p></td>
</tr>
<tr class="row-odd"><td><p>‘c’</p></td>
<td><p>write, error if exists</p></td>
<td><p>H5F_ACC_CREAT</p></td>
</tr>
<tr class="row-even"><td><p>‘t’</p></td>
<td><p>write, replace existing</p></td>
<td><p>H5F_ACC_TRUNC</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Indication of writing success.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille._brille.BZMeshQdc.values">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">values</span></span><a class="headerlink" href="#brille._brille.BZMeshQdc.values" title="Permalink to this definition"></a></dt>
<dd><p>Return a shared view of the stored eigenvalues</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille._brille.BZMeshQdc.vectors">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">vectors</span></span><a class="headerlink" href="#brille._brille.BZMeshQdc.vectors" title="Permalink to this definition"></a></dt>
<dd><p>Return a shared view of the stored eigenvectors</p>
</dd></dl>

</dd></dl>

</section>
<section id="hierarchy">
<h3>Hierarchy<a class="headerlink" href="#hierarchy" title="Permalink to this headline"></a></h3>
<p>The <a class="reference internal" href="#brille._brille.BZNestQdc" title="brille._brille.BZNestQdc"><code class="xref py py-class docutils literal notranslate"><span class="pre">BZNestQdc</span></code></a> and its type-siblings implements a triangulated grid with
multiple triangulations of the Brillouin Zone of increasingly finer maximum tetrahedron size;
overlapping regions of these triangulations are identified and stored to simplify later finding
the smallest tetrahedron containing a given point.</p>
<p>Starting from the coarsest ‘top’ <cite>layer</cite> of tetrahedra, a containing tetrahedron should be quick to locate.
Then the list of overlapping next-finer <cite>layer</cite> tetrahedra can be used to locate the next containing tetrahedron.
This process repeats until the finest <cite>layer</cite> tetrahedron containing the point is found.
The total number of in-tetrahedron checks is then on the order of the sum of the average number of connected
tetrahedra at each layer over the number of layers; which should be chosen to be smaller than the total
number of tetrahedra at the finest layer.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>As implemented, the tetrahedra of two subsequent triangulations could have any overlapping relationship
including one finer-tetrahedron intersecting with two (or more) coarser-tetrahedra.
In practice it seems that the <cite>TetGen</cite> meshing algorithm always produces finer-tetrahedra which subdivide
a coarser-tetrahedra, so that a finite-tree is formed between the <cite>layers</cite> of the <cite>nest</cite>.
A class requiring this relationship should be able to extract memory and speed efficiencies which the
current implementation sacrificed for greater relationsional flexibility.</p>
</div>
<p>If the <span class="math">\(i^\text{th}\)</span> layer has tetrahedra which on average contain <span class="math">\(\left&lt;m\right&gt;_i\)</span> overlapping
number of tetrahedra in the <span class="math">\((i+1)^\text{th}\)</span> layer, then the typical number of in-tetrahedra
checks required to find the finest-tetrahedra containing any point is</p>
<div class="math">
\[N_\text{checks} \propto \sum_{i=1}^n \left< m \right>_i

\]</div>
<p>and the finest <cite>layer</cite> contains</p>
<div class="math">
\[N_\text{tetrahedra}^n = \prod_{i=1}^n \left< m \right>_i

\]</div>
<p>tetrahedra. As long as <span class="math">\(N_\text{checks} &lt; N_\text{tetrahedra}^n\)</span> this location method will be more efficient.</p>
<dl class="py class">
<dt class="sig sig-object py" id="brille._brille.BZNestQdd">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">brille._brille.</span></span><span class="sig-name descname"><span class="pre">BZNestQdd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille._brille.BZNestQdd" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: brille._brille.BZNestQdd, <a href="#id2"><span class="problematic" id="id3">bz_</span></a>: brille._brille.BrillouinZone, max_volume: float, max_branchings: int = 5) -&gt; None</p></li>
<li><p>__init__(self: brille._brille.BZNestQdd, <a href="#id4"><span class="problematic" id="id5">bz_</span></a>: brille._brille.BrillouinZone, number_density: int, max_branchings: int = 5) -&gt; None</p></li>
</ol>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="brille._brille.BZNestQcc">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">brille._brille.</span></span><span class="sig-name descname"><span class="pre">BZNestQcc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille._brille.BZNestQcc" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: brille._brille.BZNestQcc, <a href="#id6"><span class="problematic" id="id7">bz_</span></a>: brille._brille.BrillouinZone, max_volume: float, max_branchings: int = 5) -&gt; None</p></li>
<li><p>__init__(self: brille._brille.BZNestQcc, <a href="#id8"><span class="problematic" id="id9">bz_</span></a>: brille._brille.BrillouinZone, number_density: int, max_branchings: int = 5) -&gt; None</p></li>
</ol>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="brille._brille.BZNestQdc">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">brille._brille.</span></span><span class="sig-name descname"><span class="pre">BZNestQdc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille._brille.BZNestQdc" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: brille._brille.BZNestQdc, <a href="#id10"><span class="problematic" id="id11">bz_</span></a>: brille._brille.BrillouinZone, max_volume: float, max_branchings: int = 5) -&gt; None</p></li>
<li><p>__init__(self: brille._brille.BZNestQdc, <a href="#id12"><span class="problematic" id="id13">bz_</span></a>: brille._brille.BrillouinZone, number_density: int, max_branchings: int = 5) -&gt; None</p></li>
</ol>
<dl class="py property">
<dt class="sig sig-object py" id="brille._brille.BZNestQdc.bytes_per_point">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bytes_per_point</span></span><a class="headerlink" href="#brille._brille.BZNestQdc.bytes_per_point" title="Permalink to this definition"></a></dt>
<dd><p>Return the memory required per interpolation point <em>result</em> in bytes</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille._brille.BZNestQdc.fill">
<span class="sig-name descname"><span class="pre">fill</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille._brille.BZNestQdc.fill" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>fill(self: brille._brille.BZNestQdc, values_data: numpy.ndarray[numpy.float64], values_elements: numpy.ndarray[numpy.int32], vectors_data: numpy.ndarray[numpy.complex128], vectors_elements: numpy.ndarray[numpy.int32], sort: bool = False) -&gt; None</p></li>
</ol>
<p>Provide data required for interpolation to the grid without cost information.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul>
<li><p><strong>values_data</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.23)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – The eigenvalue data to be stored in the grid. The first dimension must be
equal in size to the number of grid-vertices. If two dimensional the second
dimension is interpreted as all information for a single mode flattened
and concatenated into (scalars, vectors, matrices) – in that order.
If more than two dimensional, the second dimension indexes modes and
higher dimensions will be flattened <em>as if row ordered</em> and must flatten into
a concatenated list of (scalars, vectors, matrices).
If the provided array can be interpreted as a contiguous row-ordered two
dimensional array it will be used in place, otherwise a copy will be made.</p></li>
<li><p><strong>values_elements</strong> (<em>integer vector-like</em>) –</p>
<dl class="simple">
<dt>A multi-purpose vector containing, in order:</dt><dd><ul class="simple">
<li><p>the number of scalar-like eigenvalue elements,</p></li>
<li><p>the number of vector-like eigenvalue <em>elements</em> (must be <span class="math">\(3\times N\)</span>),</p></li>
<li><p>the number of matrix-like eigenvalue <em>elements</em> (must be <span class="math">\(9\times N\)</span>),</p></li>
<li><p>an integer <a class="reference internal" href="#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> value denoting
<em>how</em> the vector-like and matrix-like parts transform under application
of a symmetry operation (see note below).</p></li>
</ul>
</dd>
</dl>
</li>
<li><p><strong>vectors_data</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.23)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – The eigenvector data to be stored in the grid. Same shape restrictions as
<strong>values_data</strong></p></li>
<li><p><strong>vectors_elements</strong> – Like <strong>values_elements</strong> but for the eigenvectors</p></li>
<li><p><strong>sort</strong> (logical (default <code class="docutils literal notranslate"><span class="pre">False</span></code>)) – Whether the equivalent-mode permutations should be (re)determined following
the update to the flags and weights.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Mapping of integers to <a class="reference internal" href="#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> values:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 15%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>Real</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>Reciprocal</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>Axial</cite></p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p><cite>Gamma</cite></p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 0.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>fill(self: brille._brille.BZNestQdc, values_data: numpy.ndarray[numpy.float64], values_elements: numpy.ndarray[numpy.int32], values_weights: numpy.ndarray[numpy.float64], vectors_data: numpy.ndarray[numpy.complex128], vectors_elements: numpy.ndarray[numpy.int32], vectors_weights: numpy.ndarray[numpy.float64], sort: bool = False) -&gt; None</p></li>
</ol>
<p>Provide all data required for interpolation to the grid at once</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul>
<li><p><strong>values_data</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.23)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – The eigenvalue data to be stored in the grid. The first dimension must be
equal in size to the number of grid-vertices. If two dimensional the second
dimension is interpreted as all information for a single mode flattened
and concatenated into (scalars, vectors, matrices) – in that order.
If more than two dimensional, the second dimension indexes modes and
higher dimensions will be flattened <em>as if row ordered</em> and must flatten into
a concatenated list of (scalars, vectors, matrices).
If the provided array can be interpreted as a contiguous row-ordered two
dimensional array it will be used in place, otherwise a copy will be made.</p></li>
<li><p><strong>values_elements</strong> (<em>integer vector-like</em>) –</p>
<dl class="simple">
<dt>A multi-purpose vector containing, in order:</dt><dd><ul class="simple">
<li><p>the number of scalar-like eigenvalue elements,</p></li>
<li><p>the number of vector-like eigenvalue <em>elements</em> (must be <span class="math">\(3\times N\)</span>),</p></li>
<li><p>the number of matrix-like eigenvalue <em>elements</em> (must be <span class="math">\(9\times N\)</span>),</p></li>
<li><p>an integer <a class="reference internal" href="#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> value denoting
<em>how</em> the vector-like and matrix-like parts transform under application
of a symmetry operation (see note below),</p></li>
<li><p>which scalar cost function should be used (see below),</p></li>
<li><p>which vector cost function should be used (see below).</p></li>
</ul>
</dd>
</dl>
<p>See the note below fore the meaning of the last three values.</p>
</li>
<li><p><strong>values_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvalue elements stored in the grid</p></li>
<li><p><strong>vectors_data</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.23)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – The eigenvector data to be stored in the grid. Same shape restrictions as
<strong>values_data</strong></p></li>
<li><p><strong>vectors_elements</strong> – Like <strong>values_elements</strong> but for the eigenvectors</p></li>
<li><p><strong>vectors_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvector elements stored in the grid</p></li>
<li><p><strong>sort</strong> (logical (default <code class="docutils literal notranslate"><span class="pre">False</span></code>)) – Whether the equivalent-mode permutations should be (re)determined following
the update to the flags and weights.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Mapping of integers to <a class="reference internal" href="#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> values:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 15%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>Real</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>Reciprocal</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>Axial</cite></p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p><cite>Gamma</cite></p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to scalar cost function:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(x,y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>magnitude(x-y)</p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to vector cost function:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 16%" />
<col style="width: 84%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(vec_x, vec_y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>sin(hermitian_angle(vec_x, vec_y))</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>vector_distance(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>1 - vector_product(vec_x, vec_y)</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>vector_angle(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>hermitian_angle(vec_x, vec_y)</p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 0.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille._brille.BZNestQdc.from_file">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">entry</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'BZNestQdc'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#brille._brille.BZNestQdc" title="brille._brille.BZNestQdc"><span class="pre">brille._brille.BZNestQdc</span></a></span></span><a class="headerlink" href="#brille._brille.BZNestQdc.from_file" title="Permalink to this definition"></a></dt>
<dd><p>Save the object to an HDF5 file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> (<em>str</em>) – The full path specification for the file to read from</p></li>
<li><p><strong>entry</strong> (<em>str</em>) – The group path, e.g., “my/cool/grid”, where to read from inside the file,
with a default equal to the object Class name</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>clsObj</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille._brille.BZNestQdc.ir_interpolate_at">
<span class="sig-name descname"><span class="pre">ir_interpolate_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#brille._brille.BZNestQdc" title="brille._brille.BZNestQdc"><span class="pre">brille._brille.BZNestQdc</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.23)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">useparallel</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threads</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">do_not_move_points</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.23)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.23)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.complex128</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#brille._brille.BZNestQdc.ir_interpolate_at" title="Permalink to this definition"></a></dt>
<dd><p>Perform linear interpolation of the stored data at irreducible equivalent points</p>
<p>The irreducible first Brillouin zone is the part of reciprocal space which is
invariant under application of the integer translations <em>and</em> the pointgroup
operations of a reciprocal space lattice. This method finds points equivalent
to the input within the irreducible first Brillouin zone and then interpolates
pre-stored information to provide an estimate at the found positions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Q</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.23)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – A two dimensional array with <code class="docutils literal notranslate"><span class="pre">Q.shape[1]</span> <span class="pre">==</span> <span class="pre">3</span></code> containing the positions at
which an interpolated result is required, expressed in units of the
reciprocal lattice.</p></li>
<li><p><strong>useparallel</strong> (<em>bool, optional</em>) – Whether a serial or parallel code should be utilised</p></li>
<li><p><strong>threads</strong> (<em>int, optional</em>) – How many OpenMP workers should be utilised; if this value is less than one
the environment variable <code class="docutils literal notranslate"><span class="pre">OMP_NUM_THREADS</span></code> will be used.</p></li>
<li><p><strong>do_not_move_points</strong> (<em>bool, optional</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code> the provided <strong>Q</strong> points must already lie within the first Brillouin
zone. No check is made to verify this requirement and if any <strong>Q</strong> lie outside
of the gridded volume out-of-bounds errors may result in bad data or runtime
errors.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The interpolated eigenvalues and eigenvectors at the equivalent
irreducible first Brillouin zone points.
The shape of each output will depend on the shape of the data provided to
the <a class="reference internal" href="#brille._brille.BZTrellisQdc.fill" title="brille._brille.BZTrellisQdc.fill"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fill()</span></code></a> method. i
If the filled eigenvalues were of shape
<code class="docutils literal notranslate"><span class="pre">[N_grid_points,</span> <span class="pre">N_modes,</span> <span class="pre">A,</span> <span class="pre">...,</span> <span class="pre">B]</span></code>, the eigenvectors were of shape
<code class="docutils literal notranslate"><span class="pre">[N_grid_points,</span> <span class="pre">N_modes,</span> <span class="pre">C,</span> <span class="pre">...,</span> <span class="pre">D]</span></code>, and the provided points of shape
<code class="docutils literal notranslate"><span class="pre">[N_Q_points,</span> <span class="pre">3]</span></code> then the output shapes will be
<code class="docutils literal notranslate"><span class="pre">[N_Q_points,</span> <span class="pre">N_modes,</span> <span class="pre">A,</span> <span class="pre">...,</span> <span class="pre">B]</span></code> and <code class="docutils literal notranslate"><span class="pre">[N_Q_points,</span> <span class="pre">N_modes,</span> <span class="pre">C,</span> <span class="pre">...,</span> <span class="pre">D]</span></code>
for the eigenvalues and eigenvectors, respectively.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille._brille.BZNestQdc.set_flags_weights">
<span class="sig-name descname"><span class="pre">set_flags_weights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#brille._brille.BZNestQdc" title="brille._brille.BZNestQdc"><span class="pre">brille._brille.BZNestQdc</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">values_flags</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.23)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">values_weights</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.23)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vectors_flags</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.23)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vectors_weights</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.23)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#brille._brille.BZNestQdc.set_flags_weights" title="Permalink to this definition"></a></dt>
<dd><p>Set <a class="reference internal" href="#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> and cost functions plus
relative cost weights for the values and vectors stored in the object</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>values_flags</strong> (<em>integer, vector-like</em>) – One or more values indicating the <a class="reference internal" href="#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a>
value for the eigenvalues stored in the object, plus which cost function
to use when comparing stored eigenvalues at neighbouring grid points for
scalar- and vector-like eigenvalues.</p></li>
<li><p><strong>values_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvalue elements stored in the grid</p></li>
<li><p><strong>vectors_flags</strong> (<em>integer, vector-like</em>) – One or more values indicating the <a class="reference internal" href="#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a>
value for the eigenvectors stored in the object, plus which cost function
to use when comparing stored eigenvectors at neighbouring grid points for
scalar- and vector-like eigenvectors.</p></li>
<li><p><strong>vectors_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvector elements stored in the grid</p></li>
<li><p><strong>sort</strong> (<em>bool, optional</em>) – Whether the equivalent-mode permutations should be (re)determined following
the update to the flags and weights.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Mapping of integers to <a class="reference internal" href="#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> values:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 15%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>Real</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>Reciprocal</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>Axial</cite></p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p><cite>Gamma</cite></p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to scalar cost function:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(x,y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>magnitude(x-y)</p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to vector cost function:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 16%" />
<col style="width: 84%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(vec_x, vec_y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>sin(hermitian_angle(vec_x, vec_y))</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>vector_distance(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>1 - vector_product(vec_x, vec_y)</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>vector_angle(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>hermitian_angle(vec_x, vec_y)</p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 0.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille._brille.BZNestQdc.sort">
<span class="sig-name descname"><span class="pre">sort</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#brille._brille.BZNestQdc" title="brille._brille.BZNestQdc"><span class="pre">brille._brille.BZNestQdc</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#brille._brille.BZNestQdc.sort" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille._brille.BZNestQdc.to_file">
<span class="sig-name descname"><span class="pre">to_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#brille._brille.BZNestQdc" title="brille._brille.BZNestQdc"><span class="pre">brille._brille.BZNestQdc</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">entry</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'BZNestQdc'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'ac'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#brille._brille.BZNestQdc.to_file" title="Permalink to this definition"></a></dt>
<dd><p>Save the object to an HDF5 file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> (<em>str</em>) – The full path specification for the file to write into</p></li>
<li><p><strong>entry</strong> (<em>str</em>) – The group path, e.g., “my/cool/grid”, where to write inside the file,
with a default equal to the object Class name</p></li>
<li><p><strong>flags</strong> (<em>str</em>) – The HDF5 permissions to use when opening the file. Default ‘a’ writes to an
existing file – if <cite>entry</cite> exists in the file it is overwritten.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Possible <cite>flags</cite> are:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 18%" />
<col style="width: 50%" />
<col style="width: 32%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><cite>flags</cite></p></th>
<th class="head"><p>meaning</p></th>
<th class="head"><p>HDF equivalent</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>‘r’</p></td>
<td><p>read</p></td>
<td><p>H5F_ACC_RDONLY</p></td>
</tr>
<tr class="row-odd"><td><p>‘x’</p></td>
<td><p>write, error if exists</p></td>
<td><p>H5F_ACC_EXCL</p></td>
</tr>
<tr class="row-even"><td><p>‘a’</p></td>
<td><p>write, append to file</p></td>
<td><p>H5F_ACC_RDWR</p></td>
</tr>
<tr class="row-odd"><td><p>‘c’</p></td>
<td><p>write, error if exists</p></td>
<td><p>H5F_ACC_CREAT</p></td>
</tr>
<tr class="row-even"><td><p>‘t’</p></td>
<td><p>write, replace existing</p></td>
<td><p>H5F_ACC_TRUNC</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Indication of writing success.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille._brille.BZNestQdc.values">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">values</span></span><a class="headerlink" href="#brille._brille.BZNestQdc.values" title="Permalink to this definition"></a></dt>
<dd><p>Return a shared view of the stored eigenvalues</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille._brille.BZNestQdc.vectors">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">vectors</span></span><a class="headerlink" href="#brille._brille.BZNestQdc.vectors" title="Permalink to this definition"></a></dt>
<dd><p>Return a shared view of the stored eigenvectors</p>
</dd></dl>

</dd></dl>

</section>
</section>
<section id="hybrid-grids">
<span id="id1"></span><h2>Hybrid grids<a class="headerlink" href="#hybrid-grids" title="Permalink to this headline"></a></h2>
<p>A hybrid grid employs both a regular grid of parallelepipeds and, where the regular grid
passes the Brillouin zone boundary, individually triangulated cells.
This enables fast location of the cell containing any interpolation point and, if it
is triangulated, subsequent fast location of the containing tetrahedron.</p>
<div class="figure" style="text-align: center"><p><img  src="../_images/tikz-a450bd1beb5d81714a5f1534187864aca2a5136d.svg" alt="Figure made with TikZ" /></p>
</div><p>The three exposed hybrid grid implementations have the same set of methods and are:</p>
<dl class="py class">
<dt class="sig sig-object py" id="brille._brille.BZTrellisQdd">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">brille._brille.</span></span><span class="sig-name descname"><span class="pre">BZTrellisQdd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille._brille.BZTrellisQdd" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: brille._brille.BZTrellisQdd, <a href="#id14"><span class="problematic" id="id15">bz_</span></a>: brille._brille.BrillouinZone, node_volume_fraction: float = 0.1, always_triangulate: bool = False) -&gt; None</p></li>
<li><p>__init__(self: brille._brille.BZTrellisQdd, <a href="#id16"><span class="problematic" id="id17">bz_</span></a>: brille._brille.BrillouinZone, node_volume_fraction: float, always_triangulate: bool, approx_config: brille::approx_float::Config) -&gt; None</p></li>
</ol>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="brille._brille.BZTrellisQcc">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">brille._brille.</span></span><span class="sig-name descname"><span class="pre">BZTrellisQcc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille._brille.BZTrellisQcc" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: brille._brille.BZTrellisQcc, <a href="#id18"><span class="problematic" id="id19">bz_</span></a>: brille._brille.BrillouinZone, node_volume_fraction: float = 0.1, always_triangulate: bool = False) -&gt; None</p></li>
<li><p>__init__(self: brille._brille.BZTrellisQcc, <a href="#id20"><span class="problematic" id="id21">bz_</span></a>: brille._brille.BrillouinZone, node_volume_fraction: float, always_triangulate: bool, approx_config: brille::approx_float::Config) -&gt; None</p></li>
</ol>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="brille._brille.BZTrellisQdc">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">brille._brille.</span></span><span class="sig-name descname"><span class="pre">BZTrellisQdc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille._brille.BZTrellisQdc" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: brille._brille.BZTrellisQdc, <a href="#id22"><span class="problematic" id="id23">bz_</span></a>: brille._brille.BrillouinZone, node_volume_fraction: float = 0.1, always_triangulate: bool = False) -&gt; None</p></li>
<li><p>__init__(self: brille._brille.BZTrellisQdc, <a href="#id24"><span class="problematic" id="id25">bz_</span></a>: brille._brille.BrillouinZone, node_volume_fraction: float, always_triangulate: bool, approx_config: brille::approx_float::Config) -&gt; None</p></li>
</ol>
<dl class="py property">
<dt class="sig sig-object py" id="brille._brille.BZTrellisQdc.bytes_per_point">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bytes_per_point</span></span><a class="headerlink" href="#brille._brille.BZTrellisQdc.bytes_per_point" title="Permalink to this definition"></a></dt>
<dd><p>Return the memory required per interpolation point <em>result</em> in bytes</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille._brille.BZTrellisQdc.fill">
<span class="sig-name descname"><span class="pre">fill</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#brille._brille.BZTrellisQdc.fill" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>fill(self: brille._brille.BZTrellisQdc, values_data: numpy.ndarray[numpy.float64], values_elements: numpy.ndarray[numpy.int32], vectors_data: numpy.ndarray[numpy.complex128], vectors_elements: numpy.ndarray[numpy.int32], sort: bool = False) -&gt; None</p></li>
</ol>
<p>Provide data required for interpolation to the grid without cost information.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul>
<li><p><strong>values_data</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.23)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – The eigenvalue data to be stored in the grid. The first dimension must be
equal in size to the number of grid-vertices. If two dimensional the second
dimension is interpreted as all information for a single mode flattened
and concatenated into (scalars, vectors, matrices) – in that order.
If more than two dimensional, the second dimension indexes modes and
higher dimensions will be flattened <em>as if row ordered</em> and must flatten into
a concatenated list of (scalars, vectors, matrices).
If the provided array can be interpreted as a contiguous row-ordered two
dimensional array it will be used in place, otherwise a copy will be made.</p></li>
<li><p><strong>values_elements</strong> (<em>integer vector-like</em>) –</p>
<dl class="simple">
<dt>A multi-purpose vector containing, in order:</dt><dd><ul class="simple">
<li><p>the number of scalar-like eigenvalue elements,</p></li>
<li><p>the number of vector-like eigenvalue <em>elements</em> (must be <span class="math">\(3\times N\)</span>),</p></li>
<li><p>the number of matrix-like eigenvalue <em>elements</em> (must be <span class="math">\(9\times N\)</span>),</p></li>
<li><p>an integer <a class="reference internal" href="#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> value denoting
<em>how</em> the vector-like and matrix-like parts transform under application
of a symmetry operation (see note below).</p></li>
</ul>
</dd>
</dl>
</li>
<li><p><strong>vectors_data</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.23)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – The eigenvector data to be stored in the grid. Same shape restrictions as
<strong>values_data</strong></p></li>
<li><p><strong>vectors_elements</strong> – Like <strong>values_elements</strong> but for the eigenvectors</p></li>
<li><p><strong>sort</strong> (logical (default <code class="docutils literal notranslate"><span class="pre">False</span></code>)) – Whether the equivalent-mode permutations should be (re)determined following
the update to the flags and weights.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Mapping of integers to <a class="reference internal" href="#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> values:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 15%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>Real</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>Reciprocal</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>Axial</cite></p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p><cite>Gamma</cite></p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 0.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>fill(self: brille._brille.BZTrellisQdc, values_data: numpy.ndarray[numpy.float64], values_elements: numpy.ndarray[numpy.int32], values_weights: numpy.ndarray[numpy.float64], vectors_data: numpy.ndarray[numpy.complex128], vectors_elements: numpy.ndarray[numpy.int32], vectors_weights: numpy.ndarray[numpy.float64], sort: bool = False) -&gt; None</p></li>
</ol>
<p>Provide all data required for interpolation to the grid at once</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul>
<li><p><strong>values_data</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.23)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – The eigenvalue data to be stored in the grid. The first dimension must be
equal in size to the number of grid-vertices. If two dimensional the second
dimension is interpreted as all information for a single mode flattened
and concatenated into (scalars, vectors, matrices) – in that order.
If more than two dimensional, the second dimension indexes modes and
higher dimensions will be flattened <em>as if row ordered</em> and must flatten into
a concatenated list of (scalars, vectors, matrices).
If the provided array can be interpreted as a contiguous row-ordered two
dimensional array it will be used in place, otherwise a copy will be made.</p></li>
<li><p><strong>values_elements</strong> (<em>integer vector-like</em>) –</p>
<dl class="simple">
<dt>A multi-purpose vector containing, in order:</dt><dd><ul class="simple">
<li><p>the number of scalar-like eigenvalue elements,</p></li>
<li><p>the number of vector-like eigenvalue <em>elements</em> (must be <span class="math">\(3\times N\)</span>),</p></li>
<li><p>the number of matrix-like eigenvalue <em>elements</em> (must be <span class="math">\(9\times N\)</span>),</p></li>
<li><p>an integer <a class="reference internal" href="#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> value denoting
<em>how</em> the vector-like and matrix-like parts transform under application
of a symmetry operation (see note below),</p></li>
<li><p>which scalar cost function should be used (see below),</p></li>
<li><p>which vector cost function should be used (see below).</p></li>
</ul>
</dd>
</dl>
<p>See the note below fore the meaning of the last three values.</p>
</li>
<li><p><strong>values_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvalue elements stored in the grid</p></li>
<li><p><strong>vectors_data</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.23)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – The eigenvector data to be stored in the grid. Same shape restrictions as
<strong>values_data</strong></p></li>
<li><p><strong>vectors_elements</strong> – Like <strong>values_elements</strong> but for the eigenvectors</p></li>
<li><p><strong>vectors_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvector elements stored in the grid</p></li>
<li><p><strong>sort</strong> (logical (default <code class="docutils literal notranslate"><span class="pre">False</span></code>)) – Whether the equivalent-mode permutations should be (re)determined following
the update to the flags and weights.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Mapping of integers to <a class="reference internal" href="#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> values:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 15%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>Real</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>Reciprocal</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>Axial</cite></p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p><cite>Gamma</cite></p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to scalar cost function:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(x,y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>magnitude(x-y)</p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to vector cost function:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 16%" />
<col style="width: 84%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(vec_x, vec_y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>sin(hermitian_angle(vec_x, vec_y))</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>vector_distance(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>1 - vector_product(vec_x, vec_y)</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>vector_angle(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>hermitian_angle(vec_x, vec_y)</p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 0.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille._brille.BZTrellisQdc.from_file">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">entry</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'BZTrellisQdc'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#brille._brille.BZTrellisQdc" title="brille._brille.BZTrellisQdc"><span class="pre">brille._brille.BZTrellisQdc</span></a></span></span><a class="headerlink" href="#brille._brille.BZTrellisQdc.from_file" title="Permalink to this definition"></a></dt>
<dd><p>Save the object to an HDF5 file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> (<em>str</em>) – The full path specification for the file to read from</p></li>
<li><p><strong>entry</strong> (<em>str</em>) – The group path, e.g., “my/cool/grid”, where to read from inside the file,
with a default equal to the object Class name</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>clsObj</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille._brille.BZTrellisQdc.interpolate_at">
<span class="sig-name descname"><span class="pre">interpolate_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#brille._brille.BZTrellisQdc" title="brille._brille.BZTrellisQdc"><span class="pre">brille._brille.BZTrellisQdc</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.23)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">useparallel</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threads</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">do_not_move_points</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.23)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.23)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.complex128</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#brille._brille.BZTrellisQdc.interpolate_at" title="Permalink to this definition"></a></dt>
<dd><p>Perform linear interpolation of the stored data at equivalent points</p>
<p>The first Brillouin zone is the part of reciprocal space which is invariant
under application of the integer translations of a reciprocal space lattice.
This method finds points equivalent to the input within the first Brillouin
zone and then interpolates pre-stored information to provide an estimate at
the found positions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Q</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.23)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – A two dimensional array with <code class="docutils literal notranslate"><span class="pre">Q.shape[1]</span> <span class="pre">==</span> <span class="pre">3</span></code> containing the positions at
which an interpolated result is required, expressed in units of the
reciprocal lattice.</p></li>
<li><p><strong>useparallel</strong> (<em>bool, optional</em>) – Whether a serial or parallel code should be utilised</p></li>
<li><p><strong>threads</strong> (<em>int, optional</em>) – How many OpenMP workers should be utilised; if this value is less than one
the environment variable <code class="docutils literal notranslate"><span class="pre">OMP_NUM_THREADS</span></code> will be used.</p></li>
<li><p><strong>do_not_move_points</strong> (<em>bool, optional</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code> the provided <strong>Q</strong> points must already lie within the first Brillouin
zone. No check is made to verify this requirement and if any <strong>Q</strong> lie outside
of the gridded volume out-of-bounds errors may result in bad data or runtime
errors.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The interpolated eigenvalues and eigenvectors at the equivalent
first Brillouin zone points.
The shape of each output will depend on the shape of the data provided to
the <a class="reference internal" href="#brille._brille.BZTrellisQdc.fill" title="brille._brille.BZTrellisQdc.fill"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fill()</span></code></a> method.
If the filled eigenvalues were of shape
<code class="docutils literal notranslate"><span class="pre">[N_grid_points,</span> <span class="pre">N_modes,</span> <span class="pre">A,</span> <span class="pre">...,</span> <span class="pre">B]</span></code>, the eigenvectors were of shape
<code class="docutils literal notranslate"><span class="pre">[N_grid_points,</span> <span class="pre">N_modes,</span> <span class="pre">C,</span> <span class="pre">...,</span> <span class="pre">D]</span></code>, and the provided points of shape
<code class="docutils literal notranslate"><span class="pre">[N_Q_points,</span> <span class="pre">3]</span></code> then the output shapes will be
<code class="docutils literal notranslate"><span class="pre">[N_Q_points,</span> <span class="pre">N_modes,</span> <span class="pre">A,</span> <span class="pre">...,</span> <span class="pre">B]</span></code> and <code class="docutils literal notranslate"><span class="pre">[N_Q_points,</span> <span class="pre">N_modes,</span> <span class="pre">C,</span> <span class="pre">...,</span> <span class="pre">D]</span></code>
for the eigenvalues and eigenvectors, respectively.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille._brille.BZTrellisQdc.ir_interpolate_at">
<span class="sig-name descname"><span class="pre">ir_interpolate_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#brille._brille.BZTrellisQdc" title="brille._brille.BZTrellisQdc"><span class="pre">brille._brille.BZTrellisQdc</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.23)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">useparallel</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threads</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">do_not_move_points</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Tuple</span><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.23)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.23)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.complex128</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#brille._brille.BZTrellisQdc.ir_interpolate_at" title="Permalink to this definition"></a></dt>
<dd><p>Perform linear interpolation of the stored data at irreducible equivalent points</p>
<p>The irreducible first Brillouin zone is the part of reciprocal space which is
invariant under application of the integer translations <em>and</em> the pointgroup
operations of a reciprocal space lattice. This method finds points equivalent
to the input within the irreducible first Brillouin zone and then interpolates
pre-stored information to provide an estimate at the found positions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Q</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.23)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – A two dimensional array with <code class="docutils literal notranslate"><span class="pre">Q.shape[1]</span> <span class="pre">==</span> <span class="pre">3</span></code> containing the positions at
which an interpolated result is required, expressed in units of the
reciprocal lattice.</p></li>
<li><p><strong>useparallel</strong> (<em>bool, optional</em>) – Whether a serial or parallel code should be utilised</p></li>
<li><p><strong>threads</strong> (<em>int, optional</em>) – How many OpenMP workers should be utilised; if this value is less than one
the environment variable <code class="docutils literal notranslate"><span class="pre">OMP_NUM_THREADS</span></code> will be used.</p></li>
<li><p><strong>do_not_move_points</strong> (<em>bool, optional</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code> the provided <strong>Q</strong> points must already lie within the first Brillouin
zone. No check is made to verify this requirement and if any <strong>Q</strong> lie outside
of the gridded volume out-of-bounds errors may result in bad data or runtime
errors.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The interpolated eigenvalues and eigenvectors at the equivalent
irreducible first Brillouin zone points.
The shape of each output will depend on the shape of the data provided to
the <a class="reference internal" href="#brille._brille.BZTrellisQdc.fill" title="brille._brille.BZTrellisQdc.fill"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fill()</span></code></a> method. i
If the filled eigenvalues were of shape
<code class="docutils literal notranslate"><span class="pre">[N_grid_points,</span> <span class="pre">N_modes,</span> <span class="pre">A,</span> <span class="pre">...,</span> <span class="pre">B]</span></code>, the eigenvectors were of shape
<code class="docutils literal notranslate"><span class="pre">[N_grid_points,</span> <span class="pre">N_modes,</span> <span class="pre">C,</span> <span class="pre">...,</span> <span class="pre">D]</span></code>, and the provided points of shape
<code class="docutils literal notranslate"><span class="pre">[N_Q_points,</span> <span class="pre">3]</span></code> then the output shapes will be
<code class="docutils literal notranslate"><span class="pre">[N_Q_points,</span> <span class="pre">N_modes,</span> <span class="pre">A,</span> <span class="pre">...,</span> <span class="pre">B]</span></code> and <code class="docutils literal notranslate"><span class="pre">[N_Q_points,</span> <span class="pre">N_modes,</span> <span class="pre">C,</span> <span class="pre">...,</span> <span class="pre">D]</span></code>
for the eigenvalues and eigenvectors, respectively.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille._brille.BZTrellisQdc.set_flags_weights">
<span class="sig-name descname"><span class="pre">set_flags_weights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#brille._brille.BZTrellisQdc" title="brille._brille.BZTrellisQdc"><span class="pre">brille._brille.BZTrellisQdc</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">values_flags</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.23)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">values_weights</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.23)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vectors_flags</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.23)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vectors_weights</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.23)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#brille._brille.BZTrellisQdc.set_flags_weights" title="Permalink to this definition"></a></dt>
<dd><p>Set <a class="reference internal" href="#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> and cost functions plus
relative cost weights for the values and vectors stored in the object</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>values_flags</strong> (<em>integer, vector-like</em>) – One or more values indicating the <a class="reference internal" href="#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a>
value for the eigenvalues stored in the object, plus which cost function
to use when comparing stored eigenvalues at neighbouring grid points for
scalar- and vector-like eigenvalues.</p></li>
<li><p><strong>values_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvalue elements stored in the grid</p></li>
<li><p><strong>vectors_flags</strong> (<em>integer, vector-like</em>) – One or more values indicating the <a class="reference internal" href="#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a>
value for the eigenvectors stored in the object, plus which cost function
to use when comparing stored eigenvectors at neighbouring grid points for
scalar- and vector-like eigenvectors.</p></li>
<li><p><strong>vectors_weights</strong> (<em>float, vector-like</em>) – The relative cost weights between scalar-, vector-, and matrix- like
eigenvector elements stored in the grid</p></li>
<li><p><strong>sort</strong> (<em>bool, optional</em>) – Whether the equivalent-mode permutations should be (re)determined following
the update to the flags and weights.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Mapping of integers to <a class="reference internal" href="#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a> values:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 15%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p><a class="reference internal" href="#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotatesLike</span></code></a></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p><cite>Real</cite></p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p><cite>Reciprocal</cite></p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p><cite>Axial</cite></p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p><cite>Gamma</cite></p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to scalar cost function:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(x,y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>magnitude(x-y)</p></td>
</tr>
</tbody>
</table>
<p>Mapping of integers to vector cost function:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 16%" />
<col style="width: 84%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>value</p></th>
<th class="head"><p>function(vec_x, vec_y)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>sin(hermitian_angle(vec_x, vec_y))</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>vector_distance(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>1 - vector_product(vec_x, vec_y)</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>vector_angle(vec_x, vec_y)</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>hermitian_angle(vec_x, vec_y)</p></td>
</tr>
</tbody>
</table>
<p>Integer values outside of the mapped range (or missing) are replaced by 0.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille._brille.BZTrellisQdc.sort">
<span class="sig-name descname"><span class="pre">sort</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#brille._brille.BZTrellisQdc" title="brille._brille.BZTrellisQdc"><span class="pre">brille._brille.BZTrellisQdc</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#brille._brille.BZTrellisQdc.sort" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="brille._brille.BZTrellisQdc.to_file">
<span class="sig-name descname"><span class="pre">to_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#brille._brille.BZTrellisQdc" title="brille._brille.BZTrellisQdc"><span class="pre">brille._brille.BZTrellisQdc</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">entry</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'BZTrellisQdc'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'ac'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#brille._brille.BZTrellisQdc.to_file" title="Permalink to this definition"></a></dt>
<dd><p>Save the object to an HDF5 file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> (<em>str</em>) – The full path specification for the file to write into</p></li>
<li><p><strong>entry</strong> (<em>str</em>) – The group path, e.g., “my/cool/grid”, where to write inside the file,
with a default equal to the object Class name</p></li>
<li><p><strong>flags</strong> (<em>str</em>) – The HDF5 permissions to use when opening the file. Default ‘a’ writes to an
existing file – if <cite>entry</cite> exists in the file it is overwritten.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Possible <cite>flags</cite> are:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 18%" />
<col style="width: 50%" />
<col style="width: 32%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><cite>flags</cite></p></th>
<th class="head"><p>meaning</p></th>
<th class="head"><p>HDF equivalent</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>‘r’</p></td>
<td><p>read</p></td>
<td><p>H5F_ACC_RDONLY</p></td>
</tr>
<tr class="row-odd"><td><p>‘x’</p></td>
<td><p>write, error if exists</p></td>
<td><p>H5F_ACC_EXCL</p></td>
</tr>
<tr class="row-even"><td><p>‘a’</p></td>
<td><p>write, append to file</p></td>
<td><p>H5F_ACC_RDWR</p></td>
</tr>
<tr class="row-odd"><td><p>‘c’</p></td>
<td><p>write, error if exists</p></td>
<td><p>H5F_ACC_CREAT</p></td>
</tr>
<tr class="row-even"><td><p>‘t’</p></td>
<td><p>write, replace existing</p></td>
<td><p>H5F_ACC_TRUNC</p></td>
</tr>
</tbody>
</table>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Indication of writing success.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille._brille.BZTrellisQdc.values">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">values</span></span><a class="headerlink" href="#brille._brille.BZTrellisQdc.values" title="Permalink to this definition"></a></dt>
<dd><p>Return a shared view of the stored eigenvalues</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="brille._brille.BZTrellisQdc.vectors">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">vectors</span></span><a class="headerlink" href="#brille._brille.BZTrellisQdc.vectors" title="Permalink to this definition"></a></dt>
<dd><p>Return a shared view of the stored eigenvectors</p>
</dd></dl>

</dd></dl>

</section>
<section id="helper-classes">
<h2>Helper classes<a class="headerlink" href="#helper-classes" title="Permalink to this headline"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="brille._brille.RotatesLike">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">brille._brille.</span></span><span class="sig-name descname"><span class="pre">RotatesLike</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#brille._brille.RotatesLike" title="brille._brille.RotatesLike"><span class="pre">brille._brille.RotatesLike</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#brille._brille.RotatesLike" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Enumeration indicating how vector and matrix values transform</p>
</div></blockquote>
<p>Members:</p>
<blockquote>
<div><p>Real : real space vector or matrix</p>
<p>Reciprocal : reciprocal scpace vector or matrix</p>
<p>Axial : real space axial vector</p>
<p>Gamma : (real space) phonon eigenvector</p>
</div></blockquote>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="bz.html" class="btn btn-neutral float-left" title="Brillouin Zone" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="symmetry.html" class="btn btn-neutral float-right" title="Symmetry" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, Gregory Tucker.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>